<h1 align="center">Picomatch</h1>

<p align="center">
<a href="https://npmjs.org/package/picomatch">
<img src="https://img.shields.io/npm/v/picomatch.svg" alt="version">
</a>
<a href="https://github.com/micromatch/picomatch/actions?workflow=Tests">
<img src="https://github.com/micromatch/picomatch/workflows/Tests/badge.svg" alt="test status">
</a>
<a href="https://coveralls.io/github/micromatch/picomatch">
<img src="https://img.shields.io/coveralls/github/micromatch/picomatch/master.svg" alt="coverage status">
</a>
<a href="https://npmjs.org/package/picomatch">
<img src="https://img.shields.io/npm/dm/picomatch.svg" alt="downloads">
</a>
</p>

<br>
<br>

<p align="center">
<strong>Blazing fast and accurate glob matcher written in JavaScript.</strong></br>
<em>No dependencies and full support for standard and extended Bash glob features, including braces, extglobs, POSIX brackets, and regular expressions.</em>
</p>

<br>
<br>

## Why picomatch?

* **Lightweight** - No dependencies
* **Minimal** - Tiny API surface. Main export is a function that takes a glob pattern and returns a matcher function.
* **Fast** - Loads in about 2ms (that's several times faster than a [single frame of a HD movie](http://www.endmemo.com/sconvert/framespersecondframespermillisecond.php) at 60fps)
* **Performant** - Use the returned matcher function to speed up repeat matching (like when watching files)
* **Accurate matching** - Using wildcards (`*` and `?`), globstars (`**`) for nested directories, [advanced globbing](#advanced-globbing) with extglobs, braces, and POSIX brackets, and support for escaping special characters with `\` or quotes.
* **Well tested** - Thousands of unit tests

See the [library comparison](#library-comparisons) to other libraries.

<br>
<br>

## Table of Contents

<details><summary> Click to expand </summary>

- [Install](#install)
- [Usage](#usage)
- [API](#api)
  * [picomatch](#picomatch)
  * [.test](#test)
  * [.matchBase](#matchbase)
  * [.isMatch](#ismatch)
  * [.parse](#parse)
  * [.scan](#scan)
  * [.compileRe](#compilere)
  * [.makeRe](#makere)
  * [.toRegex](#toregex)
- [Options](#options)
  * [Picomatch options](#picomatch-options)
  * [Scan Options](#scan-options)
  * [Options Examples](#options-examples)
- [Globbing features](#globbing-features)
  * [Basic globbing](#basic-globbing)
  * [Advanced globbing](#advanced-globbing)
  * [Braces](#braces)
  * [Matching special characters as literals](#matching-special-characters-as-literals)
- [Library Comparisons](#library-comparisons)
- [Benchmarks](#benchmarks)
- [Philosophies](#philosophies)
- [About](#about)
  * [Author](#author)
  * [License](#license)

_(TOC generated by [verb](https://github.com/verbose/verb) using [markdown-toc](https://github.com/jonschlinkert/markdown-toc))_

</details>

<br>
<br>

## Install

Install with [npm](https://www.npmjs.com/):

```sh
npm install --save picomatch
```

<br>

## Usage

The main export is a function that takes a glob pattern and an options object and returns a function for matching strings.

```js
const pm = require('picomatch');
const isMatch = pm('*.js');

console.log(isMatch('abcd')); //=> false
console.log(isMatch('a.js')); //=> true
console.log(isMatch('a.md')); //=> false
console.log(isMatch('a/b.js')); //=> false
```

<br>

## API

### [picomatch](lib/picomatch.js#L32)

Creates a matcher function from one or more glob patterns. The returned function takes a string to match as its first argument, and returns true if the string is a match. The returned matcher function also takes a boolean as the second argument that, when true, returns an object with additional information.

**Params**

* `globs` **{String|Array}**: One or more glob patterns.
* `options` **{Object=}**
* `returns` **{Function=}**: Returns a matcher function.

**Example**

```js
const picomatch = require('picomatch');
// picomatch(glob[, options]);

const isMatch = picomatch('*.!(*a)');
console.log(isMatch('a.a')); //=> false
console.log(isMatch('a.b')); //=> true
```

### [.test](lib/picomatch.js#L117)

Test `input` with the given `regex`. This is used by the main `picomatch()` function to test the input string.

**Params**

* `input` **{String}**: String to test.
* `regex` **{RegExp}**
* `returns` **{Object}**: Returns an object with matching info.

**Example**

```js
const picomatch = require('picomatch');
// picomatch.test(input, regex[, options]);

console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
// { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
```

### [.matchBase](lib/picomatch.js#L161)

Match the basename of a filepath.

**Params**

* `input` **{String}**: String to test.
* `glob` **{RegExp|String}**: Glob pattern or regex created by [.makeRe](#makeRe).
* `returns` **{Boolean}**

**Example**

```js
const picomatch = require('picomatch');
// picomatch.matchBase(input, glob[, options]);
console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
```

### [.isMatch](lib/picomatch.js#L183)

Returns true if **any** of the given glob `patterns` match the specified `string`.

**Params**

* **{String|Array}**: str The string to test.
* **{String|Array}**: patterns One or more glob patterns to use for matching.
* **{Object}**: See available [options](#options).
* `returns` **{Boolean}**: Returns true if any patterns match `str`

**Example**

```js
const picomatch = require('picomatch');
// picomatch.isMatch(string, patterns[, options]);

console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
```

### [.parse](lib/picomatch.js#L199)

Parse a glob pattern to create the source string for a regular expression.

**Params**

* `pattern` **{String}**
* `options` **{Object}**
* `returns` **{Object}**: Returns an object with useful properties and output to be used as a regex source string.

**Example**

```js
const picomatch = require('picomatch');
const result = picomatch.parse(pattern[, options]);
```

### [.scan](lib/picomatch.js#L231)

Scan a glob pattern to separate the pattern into segments.

**Params**

* `input` **{String}**: Glob pattern to scan.
* `options` **{Object}**
* `returns` **{Object}**: Returns an object with

**Example**

```js
const picomatch = require('picomatch');
// picomatch.scan(input[, options]);

const result = picomatch.scan('!./foo/*.js');
console.log(result);
{ prefix: '!./',
  input: '!./foo/*.js',
  start: 3,
  base: 'foo',
  glob: '*.js',
  isBrace: false,
  isBracket: false,
  isGlob: true,
  isExtglob: false,
  isGlobstar: false,
  negated: true }
```

### [.compileRe](lib/picomatch.js#L245)

Compile a regular expression from the `state` object returned by the
[parse()](#parse) method.

**Params**

* `state` **{Object}**
* `options` **{Object}**
* `returnOutput` **{Boolean}**: Intended for implementors, this argument allows you to return the raw output from the parser.
* `returnState` **{Boolean}**: Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.
* `returns` **{RegExp}**

### [.makeRe](lib/picomatch.js#L286)

Create a regular expression from a parsed glob pattern.

**Params**

* `state` **{String}**: The object returned from the `.parse` method.
* `options` **{Object}**
* `returnOutput` **{Boolean}**: Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.
* `returnState` **{Boolean}**: Implementors may use this argument to return the state from the parsed glob with the returned regular expression.
* `returns` **{RegExp}**: Returns a regex created from the given pattern.

**Example**

```js
const picomatch = require('picomatch');
const state = picomatch.parse('*.js');
// picomatch.compileRe(state[, options]);

console.log(picomatch.compileRe(state));
//=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
```

### [.toRegex](lib/picomatch.js#L321)

Create a regular expression from the given regex source string.

**Params**

* `source` **{String}**: Regular expression source string.
* `options` **{Object}**
* `returns` **{RegExp}**

**Example**

```js
const picomatch = require('picomatch');
// picomatch.toRegex(source[, options]);

const { output } = picomatch.parse('*.js');
console.log(picomatch.toRegex(output));
//=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
```

<br>

## Options

### Picomatch options

The following options may be used with the main `picomatch()` function or any of the methods on the picomatch API.

| **Option** | **Type** | **Default value** | **Description** |
| --- | --- | --- | --- |
| `basename`            | `boolean`      | `false`     | If set, then patterns without slashes will be matched against the basename of the path if it contains slashes.  For example, `a?b` would match the path `/xyz/123/acb`, but not `/xyz/acb/123`. |
| `bash`                | `boolean`      | `false`     | Follow bash matching rules more strictly - disallows backslashes as escape characters, and treats single stars as globstars (`**`). |
| `capture`             | `boolean`      | `undefined` | Return regex matches in supporting methods. |
| `contains`            | `boolean`      | `undefined` | Allows glob to match any part of the given string(s). |
| `cwd`                 | `string`       | `process.cwd()` | Current working directory. Used by `picomatch.split()` |
| `debug`               | `boolean`      | `undefined` | Debug regular expressions when an error is thrown. |
| `dot`                 | `boolean`      | `false`     | Enable dotfile matching. By default, dotfiles are ignored unless a `.` is explicitly defined in the pattern, or `options.dot` is true |
| `expandRange`         | `function`     | `undefined` | Custom function for expanding ranges in brace patterns, such as `{a..z}`. The function receives the range values as two arguments, and it must return a string to be used in the generated regex. It's recommended that returned strings be wrapped in parentheses. |
| `failglob`            | `boolean`      | `false`     | Throws an error if no matches are found. Based on the bash option of the same name. |
| `fastpaths`           | `boolean`      | `true`      | To speed up processing, full parsing is skipped for a handful common glob patterns. Disable this behavior by setting this option to `false`. |
| `flags`               | `string`      | `undefined` | Regex flags to use in the generated regex. If defined, the `nocase` option will be overridden. |
| [format](#optionsformat) | `function` | `undefined` | Custom function for formatting the returned string. This is useful for removing leading slashes, converting Windows paths to Posix paths, etc. |
| `ignore`              | `array\|string` | `undefined` | One or more glob patterns for excluding strings that should not be matched from the result. |
| `keepQuotes`          | `boolean`      | `false`     | Retain quotes in the generated regex, since quotes may also be used as an alternative to backslashes.  |
| `literalBrackets`     | `boolean`      | `undefined` | When `true`, brackets in the glob pattern will be escaped so that only literal brackets will be matched. |
| `matchBase`           | `boolean`      | `false`     | Alias for `basename` |
| `maxLength`           | `boolean`      | `65536`     | Limit the max length of the input string. An error is thrown if the input string is longer than this value. |
| `nobrace`             | `boolean`      | `false`     | Disable brace matching, so that `{a,b}` and `{1..3}` would be treated as literal characters. |
| `nobracket`           | `boolean`      | `undefined` | Disable matching with regex brackets. |
| `nocase`              | `boolean`      | `false`     | Make matching case-insensitive. Equivalent to the regex `i` flag. Note that this option is overridden by the `flags` option. |
| `nodupes`             | `boolean`      | `true`      | Deprecated, use `nounique` instead. This option will be removed in a future major release. By default duplicates are removed. Disable uniquification by setting this option to false. |
| `noext`               | `boolean`      | `false`     | Alias for `noextglob` |
| `noextglob`           | `boolean`      | `false`     | Disable support for matching with extglobs (like `+(a\|b)`) |
| `noglobstar`          | `boolean`      | `false`     | Disable support for matching nested directories with globstars (`**`) |
| `nonegate`            | `boolean`      | `false`     | Disable support for negating with leading `!` |
| `noquantifiers`       | `boolean`      | `false`     | Disable support for regex quantifiers (like `a{1,2}`) and treat them as brace patterns to be expanded. |
| [onIgnore](#optionsonIgnore) | `function` | `undefined` | Function to be called on ignored items. |
| [onMatch](#optionsonMatch) | `function` | `undefined` | Function to be called on matched items. |
| [onResult](#optionsonResult) | `function` | `undefined` | Function to be called on all items, regardless of whether or not they are matched or ignored. |
| `posix`               | `boolean`      | `false`     | Support POSIX character classes ("posix brackets"). |
| `posixSlashes`        | `boolean`      | `undefined` | Convert all slashes in file paths to forward slashes. This does not convert slashes in the glob pattern itself |
| `prepend`             | `boolean`      | `undefined` | String to prepend to the generated regex used for matching. |
| `regex`               | `boolean`      | `false`     | Use regular expression rules for `+` (instead of matching literal `+`), and for stars that follow closing parentheses or brackets (as in `)*` and `]*`). |
| `strictBrackets`      | `boolean`      | `undefined` | Throw an error if brackets, braces, or parens are imbalanced. |
| `strictSlashes`       | `boolean`      | `undefined` | When true, picomatch won't match trailing slashes with single stars. |
| `unescape`            | `boolean`      | `undefined` | Remove backslashes preceding escaped characters in the glob pattern. By default, backslashes are retained. |
| `unixify`             | `boolean`      | `undefined` | Alias for `posixSlashes`, for backwards compatibility. |

picomatch has automatic detection for regex positive and negative lookbehinds. If the pattern contains a negative lookbehind, you must be using Node.js >= 8.10 or else picomatch will throw an error.

### Scan Options

In addition to the main [picomatch options](#picomatch-options), the following options may also be used with the [.scan](#scan) method.

| **Option** | **Type** | **Default value** | **Description** |
| --- | --- | --- | --- |
| `tokens` | `boolean` | `false` | When `true`, the returned object will include an array of tokens (objects), representing each path "segment" in the scanned glob pattern |
| `parts` | `boolean` | `false` | When `true`, the returned object will include an array of strings representing each path "segment" in the scanned glob pattern. This is automatically enabled when `options.tokens` is true |

**Example**

```js
const picomatch = require('picomatch');
const result = picomatch.scan('!./foo/*.js', { tokens: true });
console.log(result);
// {
//   prefix: '!./',
//   input: '!./foo/*.js',
//   start: 3,
//   base: 'foo',
//   glob: '*.js',
//   isBrace: false,
//   isBracket: false,
//   isGlob: true,
//   isExtglob: false,
//   isGlobstar: false,
//   negated: true,
//   maxDepth: 2,
//   tokens: [
//     { value: '!./', depth: 0, isGlob: false, negated: true, isPrefix: true },
//     { value: 'foo', depth: 1, isGlob: false },
//     { value: '*.js', depth: 1, isGlob: true }
//   ],
//   slashes: [ 2, 6 ],
//   parts: [ 'foo', '*.js' ]
// }
```

<br>

### Options Examples

#### options.expandRange

**Type**: `function`

**Default**: `undefined`

Custom function for expanding ranges in brace patterns. The [fill-range](https://github.com/jonschlinkert/fill-range) library is ideal for this purpose, or you can use custom code to do whatever you need.

**Example**

The following example shows how to create a glob that matches a folder

```js
const fill = require('fill-range');
const regex = pm.makeRe('foo/{01..25}/bar', {
  expandRange(a, b) {
    return `(${fill(a, b, { toRegex: true })})`;
  }
});

console.log(regex);
//=> /^(?:foo\/((?:0[1-9]|1[0-9]|2[0-5]))\/bar)$/

console.log(regex.test('foo/00/ba48.x > 1.0))
{
(__39_outColor3049 = _urightBorderColor_S1_c0_c0);
}
else
{
float2 __41_tmp_1_coords3050 = vec2_ctor(__38_t3048.x, 0.0);
float4 __42_color3051 = lerp(_ustart_S1_c0_c0_c0_c0, _uend_S1_c0_c0_c0_c0, __41_tmp_1_coords3050.x);
(__42_color3051.x = f_src_tf_S1_c0_c0_c0_ff(__42_color3051.x));
(__42_color3051.y = f_src_tf_S1_c0_c0_c0_ff(__42_color3051.y));
(__42_color3051.z = f_src_tf_S1_c0_c0_c0_ff(__42_color3051.z));
float4 __43_color3052 = __42_color3051;
(__43_color3052.xyz = mul(transpose(_uColorXform_S1_c0_c0_c0), __43_color3052.xyz));
(__42_color3051 = __43_color3052);
(__42_color3051.x = f_dst_tf_S1_c0_c0_c0_ff(__42_color3051.x));
(__42_color3051.y = f_dst_tf_S1_c0_c0_c0_ff(__42_color3051.y));
(__42_color3051.z = f_dst_tf_S1_c0_c0_c0_ff(__42_color3051.z));
(__39_outColor3049 = __42_color3051);
}
}
(__34_input3046 = __39_outColor3049);
float4 __45_color3053 = __34_input3046;
float __46_value3054 = (gl_texture2D(_uTextureSampler_0_S1, mul(transpose(mat3x2_ctor(_umatrix_S1_c1)), vec3_ctor(_sk_FragCoord3038.xy, 1.0)), -0.474999994).x - 0.5);
float4 _output_S13055 = vec4_ctor(clamp((__45_color3053.xyz + (__46_value3054 * _urange_S1)), 0.0, __45_color3053.w), __45_color3053.w);
{
(out_sk_FragColor = (_output_S13055 * _outputCoverage_S03044));
}
return generateOutput();
}
                                                 R‹         out_sk_FragColor       out_sk_FragColor                o      struct GS_INPUT
{
    float4 dx_Position : SV_Position;
    float4 gl_Position : TEXCOORD3;
    float4 gl_FragCoord : TEXCOORD4;
    noperspective float4 v0 : TEXCOORD0;
    noperspective float4 v1 : TEXCOORD1;
    noperspective float2 v2 : TEXCOORD2;
};

struct GS_OUTPUT
{
    float4 dx_Position : SV_Position;
    float4 gl_Position : TEXCOORD3;
    float4 gl_FragCoord : TEXCOORD4;
    noperspective float4 v0 : TEXCOORD0;
    noperspective float4 v1 : TEXCOORD1;
    noperspective float2 v2 : TEXCOORD2;
};

void copyVertex(inout GS_OUTPUT output, GS_INPUT input, GS_INPUT flatinput)
{
    output.gl_Position = input.gl_Position;
    output.v0 = input.v0; 
    output.v1 = input.v1; 
    output.v2 = input.v2; 
    output.gl_FragCoord = input.gl_FragCoord;
#ifndef ANGLE_POINT_SPRITE_SHADER
    output.dx_Position = input.dx_Position;
#endif  // ANGLE_POINT_SPRITE_SHADER
}
              º   ª   ª   ¬      DXBCf]Ø`*Y¯a€Dî®G    ¬     4   ¤    À    RDEFh     ˜      <    şÿ Á  =  RD11<          (   $          |                              …                            $Globals DriverConstants «««|      È   P           …      Ì  @           @            T      ÿÿÿÿ    ÿÿÿÿ    x           T      ÿÿÿÿ    ÿÿÿÿ    ‰      ,      ¨      ÿÿÿÿ    ÿÿÿÿ    _sk_RTAdjust float4                             M  _ulocalMatrix_S0 _umatrix_S1_c0_c0_c1 float3x3 «                              ”            T      ÿÿÿÿ    ÿÿÿÿ    ¢             ¸      ÿÿÿÿ    ÿÿÿÿ    Ü  0          ¸      ÿÿÿÿ    ÿÿÿÿ    é  8               ÿÿÿÿ    ÿÿÿÿ    (  <               ÿÿÿÿ    ÿÿÿÿ    dx_ViewAdjust dx_ViewCoords float2 «                            °  dx_ViewScale clipControlOrigin float «««                             û  clipControlZeroToOne Microsoft (R) HLSL Shader Compiler 10.1 «««ISGN\         P                    P                  P                  TEXCOORD «««OSGN°         ˜                    ¤                   ¤                   ¤                    ¤                   ¤                  SV_Position TEXCOORD «««SHEXH  P  ’   j Y  F         Y  F        _  2     _  ò    _  ò    g  ò         e  ò     e  ò     e  ò     e  ò     e  2     h     9        @                  :€        7  	B      
      @      @     ?2  2      F     †€          Ö…          8  "            *€        6  Â      @                €?6  ’           6  ò     F     6  ò     F     6  ò     F    6  ò     F    2  2      †€         F     Ö…         6  B      @    €?       F‚ ´ÉÈt9ÈT#'Õ ô´;ÚåÄ@¡Óñ’eƒy§-´„ŞR–OJÜ;š•¨
NÌ,Ö	òKµ
ÿ B2|•ÉøbÀS·‡ATåvvõ­İ+#ÁÓ”A
’Ò?‘h©»y·¦.DÎs¡"W—©˜x¾•\ŞŞ†y¥~ƒ.33¡ZÖ œu_D$](ÁZÁ;€õØßãÒ Mnª•<F.$*Í,;»Õš¿B%&ÔêÇ¦1.oÑ/’å°hæJÏú¦=yoGšÉ{1t>E«&˜"oadh,ŠŸiW˜Cd:S€™dæõ 2…\!­µĞ«Àj­ïÛ ³MQÒq&òcƒ¢&K úlkœq4?.êCµ/(Mj~ğÆ¬jôy‹q³Šˆ	§øC¯şcÜ|ï×wos ò'AÏ?ƒ9TáZ35>Ğè¶èNdNUê¯øs©:ÃvTğ]ê'Ñ(ÁJ<K„>ö®/Õ•%?¶HÜ’IŠú+˜zˆ¦‰•Ä,¡Ê¯‚½¼î	î$ßòŒŞŞs¶g¿ñgèŠ2{†Ùa"4¡{ª•ìËœJ³8ÿ9Lh¢]3œŞ*àë|²­;ø ¼(ƒs^Ş°³vÏUÔwÅ=X){ß-^Ì“Ş¼‡‰_>I)3{ÅT™OSDv|]4BÜú_—¸#Æc]¸DfaÇ	ØIºßeÎåÂÏ™¥ìÒŒ o×Îå¥6°Ä¯ùY¬Ï)­ayĞLWQô_À®r¡l% 1mÚQkøº'¨anN€( Šíš½E‘îvf®ÅÛk/¡¥wß ¨„Ò¯IÄ[âæd]*{u‡uÿşŞ“FÀÔ ®Exò·×ó(á<œ·‚¥%”³fY¦õÈÒîÄ
·fïÎ€:Œ&.øßZÜN¸dJ²Ùƒ&Fÿ® Í”8^ÂaG¡Ì³{_år|Qè¤uÄHúF…3ëÅ€bú~ËãI™Ûa4”5ÕüUGÿ³R³` ¢÷ Sí€yË3L°¸äªÔºíÂ=â“n„yH_"(õ)”W—ècD”w#HımpD£Ë¤ú¸ÌçuHååt3%u²NxÓ³°÷ü¨!İU+÷ÀÖ;êRìæeş?ûfò!—DW.ÁIBçN’ŞÛMUÂˆÃ¤…0{‰IıŞM7«ıqLùM³¹v	ëx.‡MrS’vŸä²'‘¢Ğ²fAiùg0Påerİ•k`¨©ºõ]„•VÌl'bü`ÈoÿÁ!¿‡h|!â·(¨ıpD8aÓúÒŠTòòÀvÙè_©ræOHxöÕKé—7ş/'õJü¡Ä­IyŒ“ëS–ƒF†Êóp­¥®R××<÷<‘Æ…!âùÔÈõĞpõ(P¦SS˜#«læ/¹õ¯R&}?KFÙ¦Rª”Å¸Ğğªß™Š9Ó£“õU²£®*†²ÏªU†>ÉT@rŸ@Ğ¯È£Şñ´ Mc?¨G±c–&ŸñòºGõ|ÔI‚~ì=éÛÏƒ‚Şyêñ¼cOt—"7¦,"İ.F]C=±ÌfÃU$¾mv9—u¸íOûïƒ÷ÛšÜP!Û®ÿË‹pñ`ˆ«®â9*"B²B—j)EJJÊéŞ|¯g±`ä’t …Á*ÅH†ÖÈ(V¨æÊŒŒ0g#qfX’UşåÍ³¶Ğ?ÁT°üyºp;§àîñ€&ÈnÂ˜·£ËHüéô}	ÓÌ›2‘ö&Œ–_–ñ¼[´`æõrÛĞ•å³ƒv÷Ò3Š?Ãˆ=OY¿yËÆOD¢F¸Õ^ ]C«ëCnÉ˜gÂ-()¶4òÙbb‘ãˆ¶p f—ÇîÜgcÜŒ_uÌÍ—RÍ”Ş¾Z»©ªZlßñI÷5?<(ªE›%y“ÒUŠ¨Ã?aøzŞt$Ï ú»&ĞşhAG«¯({@+À¹M|å¹)OS=Qq¶BÌ#W¡îuvÒ‰*ü}i78S]"Oîä8›4õÆøıÙÀ™6[ãÚy õdÖÄïÎÚ
ßÖJ­íï·µ~ƒøó†„a¸-]³Y¯‡iN5ÿ¡3Ğ‡™çöÖ¿*Á~ÃHˆÜîñw>Fá–Ë/Ós°IIã)êñ3½íá¡
JZ>Ey¯–ÀLş³ ?_–q‚jßğ¥qåºø1Ñæ¶FthOè©¤V±àÓ:5“R¸yÆ‰;©gZ&-îƒˆ[ÑÛåYîVéÑjÓ?Ø' Ç ëo…axÕŒ2ñGø®rì0¯•ÆMÃ^HAÚî¦3æpşU3´á]¿ub½ˆ[€ÃşNá¾<bÂ‹!‹
Ì'ka²+Ø>,÷S{J6}‚‹0ë,š½÷¶—Z0‰k:îê$| Å8¾pâHÅŠ8& n´–`X•¨…|ËŞK­«ZÁŒÂ¸>ğu–¥ø)b£Ê™oaI¤f§ç"^áó£ğ¢ƒI‘3½uôÿsÃá‰5W’¸ĞBÙ!ràÕj5Kˆ»>Á¡;rçT…¯/IÕ¦ú¢óU˜í/‘™¹‘,±ìÜœF‚Q—rí	èyêMLÀúü®î^`#¡ƒ1—ÏT}ÌÒí‰ú÷6‹=r— é&…©}#÷qé˜EE`€,AÎ9©`*ğ…… ¤­ò( b€7òÆNaµ²*DLsŒ[†ËE¢PJu}ßn	§r¼ìa6»’z	ãıM¶é0X˜"1âhŞ	µ%à]¥æÜ
Í¿I§ÒL˜Ùê¹Ø1è|k¼‘âRºÌ³•¿…h/lº•‰sŠ°JùÏ¹Ç0aÿËR×ƒ(¯¾F†ıÚzQ,~³«gVTM»·š4ißP¼ÎĞ·T–¿Ä° ÇfOÔvúx|­ğ1ë˜d}^Àò¸¯Œ= ””`(Rî2ûY"t:Á€¤ÖÏ_×mÙõ_âÁAºy…Q÷¼İÚ)d¸	qw¹ÒúÒg³H<_½öa+1?è¤+âÁèSôŒ NH††™Ñ²Â>kæ«éÇÅEKÙ…šíM((˜cy/ëøµÛÙÅ·ƒä‡ÚOÓ6ÛYœLOç_!Ìè‚’¨XêW@¥[X2nd5¶ª×Ê&ƒLªëU	Û›;r÷ıÊ¸&¹‚nõÉ#¤„äˆJÕ-âÎPaN0î1º5+	t\s0q×z¡S‹K—o(sA›O)"½9¸*vÕß&>ŞqÛ¯´ŠÌsBE6pª;qjë–ÄtÌ [‡ÑÒíÂ©CS1ÌK“dAü$¤~‘[k4¬	Ô”3š•î'g“Á¥L:fõşƒ R³,p°õ¸“g$ã©eÒ˜Œ×4X ïˆŒ=»ÇÀR`16ä¨v¶ò†6«r*¹eÅ'ÑïêÀŸèJ óí!	»oz´vO‹›[òâÕ†]äàév}`?ÀU3¥£[1£r“+1!íçÈÆ—i.O4ãjúnWâ±ì™pé˜~&e—õªå,İ¬ &K»®œ—S™/Iég7CòÚVÁ6é(aWÅSÀ´já·”‡N_Ùğ8Ï)eœ™ñêOƒä…óÚ/î{­<%ş…àtx‰Ò-óW?7Á4¹áİE"QÏâÓj³µë/XM É7ßÖ:]XKğg#W}_"Ñ;õ!ÜÕÕ·ñ½€2ÄÆ=UÈêdŠ¾ùÓeˆ® >æìÛ++ëµg;´1 ÓÈ,Å`œ„j³~AÆ“àbÌ’ı©™{î§ĞNÕ
õOåE•ö ¨ÙvZ®#ZŸˆ[ˆ#ıŸş3²¨´æ=
N±i`KM\?÷')rÈ
Ñ…WCÅŒh’)6›&îja]ø¸é[ÖUğsÉh³ğ}§šÇ Ÿ{«jPÁE¥Êt°;QµFhèÇ‘•£áêêA³dØÃÛ%6ï„K¢Ü–Ff¶E“fØq"A3æ8¥"¹D6nDú¹Yôş$qNã«¤4”åŞ×­	ãòUj¸"âíË¸ˆtº²ô:¡‹:·ş¯Ã8á‰ÎPs=›è¶Äc?ÕZçÙ¶¤ùËÜãoÅ
³`±¬Í‚IøU*Ç«®:¼cº	^D¦­^*ŠUÂºgí™+<Ù³‰“úŞcx)'r†³ïs,fÈåZìë“†ñX‹5(\_ùU`§8¾v(×Nö‚
…Ê}OP„¹W))õÈÃ 'V ÁâÊ´4è3òAØïØ7wõ³ˆTö—	¢‹ÌÄşø^Il‹hL0'Š;i6Qx gûÏ>Wc³]y­qØg•ŸF.µ.“…K¨†‹lt•y¸ŸÙ6«zeÃ~ò0’­(~së‡`õ²ñ¿âìtİÉlÃ
u6Ï.ˆŠ
‡Ìªaö¸±Š´âPÅÇ37ã±k?—Cæ8ˆFKÕñy!‚¶ú×Ü¤«û~ŞkLà6D Ó_éíÊªÿ«kn<wsåïkLú%Â’hú«¶ó²¸<$:ò9¡û8SŸçft›jÍ…ì¨€ùçâLğş6îoƒ[')Æ1òÓèmõè)ÒíZ³ƒğ…Ç_kæPk]Â¡V€ E"œ‹Ieş‹Shÿ‡iiö¨M¯°ÄÚuå¾zêR
®Öüô`ö4ªÌ«KNÉuqá&çÙ+¯ULË`ƒ®Ü¨Ôµ9İP¶yg}Ğğtè[%ëÄ*èr¯–ØÛôQË?àF ¬¦ZIŞÆß8‚’=ÌîºªVÑs†‰R˜ÎÒ¤J0ÖÎYª]—îLæùîBRŒ%4Ÿq·ŠÑ½¦+ÙSÀ87!?­5ß·w³Óš%Ch/ëÉä›“N„N56_Iœ‰c±w#3qÂSœá4¹êáÈeÇY?éW]3½úîü°,fW\æí9F_Uvÿ–a'—&Mß< ])÷×»üQ§1ÈcÌ-ÓÔ÷9G·´yÿkÓâtph’@¬è6CJë?bZV¡¢İ†&@¼)¼ 7¾ì~ïºK§ÈÔÉ5õ|_"oyw ğ6ß9Üø¡(0&zîîã5¸!¢±ú÷<öñ`‰• £‘J,e»PAaK;
wÕ<6Hˆ~)uQÜİS·Ú®¤qùfİÈö=øŠ ÊóuyÉ%6l·eï^·FÿÕ?&wºfÉ­f|	*®mÈ!fˆeHlÒ[)~*ÁŒYGÉ¨<Ùk”¹|4´¯†2Ÿ½d¬…”µEèhÔ£'UåÀ]87mù<='y²Ùïf]=C÷£Ç¥@¿°fnzY¾ÈIyz–dmùæ×)-ËõÅôÆÔ›©:CO‚Ro’àE•™ësƒÑª–;…§‹      
í—klW€¿;~Ä±çµ­Ó†YÛ»±Ó4%YÛy8µ]×ë<Jgv÷z3íìÌff6ñÔ„Q„6BıAT„(RCÚĞ†F-ñÌ¨PEQ%T$"(B¥QŠ*ÔtïÎ:k;%ê/„è±|öç=çÜ3wÎ`‡EˆVc¿8Ê~ãèQŒ¥¢ù°Ìæ·¹(‹~P1¢¹Í8Jš6æ¥VµöÈ t|¯Ö*qÈ±° £½Ó4,¦GíŠëÛyÄa´®2`’&İøf´U	S¼Ù"hkûõC4-Eøüš½ÙÁ!µl ZLØ	ì¼	Æ/ÎL ”Òx#°h†¡VX ÷-†k£êÃ ‰Q¦ærSÏİÇ¸:ôevõ	T%«{JYV²3Ùu³â4á›X}/|Ó€ïªu&
¯êĞš@…¼zw†|,Vë»€HÉ”~Ÿëgãıó–ÃçñO‘d%z÷EªT@;°4^«zUóú½¨FØÌbÒhæ1%cŸ5ÿAÍÜF‹ÑÌ|¡ğ'Å%ÑÌI½Ş¯ñkZzFãŸj¼Có+´Êûz½‡ªÆ|:Á:Œf®¥Ãhe-Æbºè0Vp³^§é0V1¨×wh|§Æ¶ÆÆ5®hlÑÆ&,–ÑÅ*²X¬æ,Öñ¸Æ?Á"ÉKXÜÂkšó7[„E?·q«°Èh»8(,r÷ğ¬°5/ˆÆcÕS©æké×^“9½`²Î˜Ë{(æ©&…ëŒ~£Ö²ğ­Ô|ú…ÓÔêÔ¶Ô[¢3dËfP«bŠ=2ùA7Ãv8SÉ©î˜“ŒS±$5•bó°Ÿ/»ò#d*a$‹ÖXÙ‹œ¢dÔµ=I:e1ëV†edçíÈNGQàdË‘d@fË…‚uåe^M{Ü‰êÙãvPÑöÀ.ÊÃ~pÏ\ıí+ãf®pĞ›ôƒ¢9¾g»ï¨5 Ã\à”¢wNÚe7J»^–öûÅ’ãjÇcÒµ§ô*œk=øùr.š+è÷K•À)¨õe”[×±½+K¶W¹,ˆ‹­ù‘“u\'ª“Î<+Îİñ
5ÉH¹('Zy×yÜQ¶#xïMÛËIWæTrô9…A/’`©F˜½EÍáìjô€c<?ŒêX5Ój5e‘Á!''Ã¸A¯0ìçåVµC}
®œª=CŸ±*oM¼|vû}§_üË«gŸ¦Ñ¢¥ÁD4™B,Y¢Èö&Óííji´œÛ2qtÉ¯Z7©ËTCíYn´èÅê–7VîìÒˆïm›ÊIİ'ãÿp(Z„ºh-‚k­‘mãı~ Ó¥Ò‡ãzßz¨«ÓêŒ·/Ÿná',¹veÄ.ÊùÊÄT*+mqöê±hÊw4“2ô²şTÌ].X4»Æ4é—‹2Ç§X¬ss­`Ñ`˜ö£Z¯LK®¬vrú“‘Ùï%?Ğ­IuáŒyE©e¦]×ÔíšepHæ-X*X¨²±’İ=VoOgR‚D•µ.×JnÈ%eçdª'/{7¦’©.;—”ùî=Éœìí•]]½Ù”NcñôÆ0U™tDÇdÉÈ*»×<E¥pS"Qp¢å¬•ó‹‰¼y2Š€÷G½û«kô=ÿàëÏ®Ï|é…‡ş¼şä÷O_úö/øåÁ³¿iøNâ·­êñ[şğÔòK?¿h~ewÇ/Ÿhœ˜:~á}o}êC/®lbİÛOÿè†—öı½ü…k®ôßøS×OŒ¤¾|q»6œ?ÙÛpşøWxqçıC§Íœ:wê|Ã/Üıèùô×'ÚOlİ šã{»ú^GªV9<|¼Rí¯é7Ç2àF`áZ¸sÖ1İ1Œe2'Ù¶õş'_éûáïúì˜·ö´ò‘˜H„A.TŸª„DÎ¤‹Â„Ÿ½;1«ccÒ•v(ŒÔù¬Ïª†–Ál=«”Ï’Ù™îŞĞC¼çØ½ñ*¯-¹Ê¾Ÿ}í™‡Ÿ\’¹ëcñÌ¤àĞÚéWË¨ÍVU˜è÷ƒ×¶b˜ó)õ¤à_˜sÒÿ/€ĞA\3gÔ«NtWà×fÇ}[á5`ÅğFCJ½dÉ0Á¶1F†Ang„	a;·k½4şõíªŸVÎ_¿]èÁ•¶ÔİT³‡5
ö`°É “øZ¾F[`ãâbáàãÅÎ5îkP>2D8x®à)¥u:§ÿRdUØÈb5càS¤ˆÄ#B¯*„DHŠXŒPÖRå?§åC¬œ¶+éØ*Œ`k-ÃZ3À'Äg’Sk”4®Ïb§¡ó ’PÛ:”fäzµ˜6Ó^çg–…uö]tbéÿ$İô`ÑK$uËº^Ê€‡[—ÑŞÛ"«¿a!BRĞTÎ%*Z³ÀÔıvó]ÔÇÒ_OÊ»Yç%Ô”ª”Šâ’<0ªó¸=ÖTİ ¢¨ÕÄ{×ùlÕg3ª#ÍS&Gt•s~S{Ü¦¿áÓ9Ç~öÉÔŸË:rt“"Ér$‘t2IŠòHzÙ¨e)º°cyºÙHIrZ§I]ô’E=¹iA&ÔÕ*’Å¥‚9'TEõÿ=øŸ³úş9ı}şüßÁªFÏ.Jc¹`^^†Ñh‘Âû7ò@3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 