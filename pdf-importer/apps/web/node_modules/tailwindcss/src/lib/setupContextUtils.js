import fs from 'fs'
import url from 'url'
import postcss from 'postcss'
import dlv from 'dlv'
import selectorParser from 'postcss-selector-parser'

import transformThemeValue from '../util/transformThemeValue'
import parseObjectStyles from '../util/parseObjectStyles'
import prefixSelector from '../util/prefixSelector'
import isPlainObject from '../util/isPlainObject'
import escapeClassName from '../util/escapeClassName'
import nameClass, { formatClass } from '../util/nameClass'
import { coerceValue } from '../util/pluginUtils'
import { variantPlugins, corePlugins } from '../corePlugins'
import * as sharedState from './sharedState'
import { env } from './sharedState'
import { toPath } from '../util/toPath'
import log from '../util/log'
import negateValue from '../util/negateValue'
import isSyntacticallyValidPropertyValue from '../util/isSyntacticallyValidPropertyValue'
import { generateRules, getClassNameFromSelector } from './generateRules'
import { hasContentChanged } from './cacheInvalidation.js'
import { Offsets } from './offsets.js'
import { flagEnabled } from '../featureFlags.js'
import { finalizeSelector, formatVariantSelector } from '../util/formatVariantSelector'

export const INTERNAL_FEATURES = Symbol()

const VARIANT_TYPES = {
  AddVariant: Symbol.for('ADD_VARIANT'),
  MatchVariant: Symbol.for('MATCH_VARIANT'),
}

const VARIANT_INFO = {
  Base: 1 << 0,
  Dynamic: 1 << 1,
}

function prefix(context, selector) {
  let prefix = context.tailwindConfig.prefix
  return typeof prefix === 'function' ? prefix(selector) : prefix + selector
}

function normalizeOptionTypes({ type = 'any', ...options }) {
  let types = [].concat(type)

  return {
    ...options,
    types: types.map((type) => {
      if (Array.isArray(type)) {
        return { type: type[0], ...type[1] }
      }
      return { type, preferOnConflict: false }
    }),
  }
}

function parseVariantFormatString(input) {
  /** @type {string[]} */
  let parts = []

  // When parsing whitespace around special characters are insignificant
  // However, _inside_ of a variant they could be
  // Because the selector could look like this
  // @media { &[data-name="foo bar"] }
  // This is why we do not skip whitespace

  let current = ''
  let depth = 0

  for (let idx = 0; idx < input.length; idx++) {
    let char = input[idx]

    if (char === '\\') {
      // Escaped characters are not special
      current += '\\' + input[++idx]
    } else if (char === '{') {
      // Nested rule: start
      ++depth
      parts.push(current.trim())
      current = ''
    } else if (char === '}') {
      // Nested rule: end
      if (--depth < 0) {
        throw new Error(`Your { and } are unbalanced.`)
      }

      parts.push(current.trim())
      current = ''
    } else {
      // Normal character
      current += char
    }
  }

  if (current.length > 0) {
    parts.push(current.trim())
  }

  parts = parts.filter((part) => part !== '')

  return parts
}

function insertInto(list, value, { before = [] } = {}) {
  before = [].concat(before)

  if (before.length <= 0) {
    list.push(value)
    return
  }

  let idx = list.length - 1
  for (let other of before) {
    let iidx = list.indexOf(other)
    if (iidx === -1) continue
    idx = Math.min(idx, iidx)
  }

  list.splice(idx, 0, value)
}

function parseStyles(styles) {
  if (!Array.isArray(styles)) {
    return parseStyles([styles])
  }

  return styles.flatMap((style) => {
    let isNode = !Array.isArray(style) && !isPlainObject(style)
    return isNode ? style : parseObjectStyles(style)
  })
}

function getClasses(selector, mutate) {
  let parser = selectorParser((selectors) => {
    let allClasses = []

    if (mutate) {
      mutate(selectors)
    }

    selectors.walkClasses((classNode) => {
      allClasses.push(classNode.value)
    })

    return allClasses
  })
  return parser.transformSync(selector)
}

/**
 * Ignore everything inside a :not(...). This allows you to write code like
 * `div:not(.foo)`. If `.foo` is never found in your code, then we used to
 * not generated it. But now we will ignore everything inside a `:not`, so
 * that it still gets generated.
 *
 * @param {selectorParser.Root} selectors
 */
function ignoreNot(selectors) {
  selectors.walkPseudos((pseudo) => {
    if (pseudo.value === ':not') {
      pseudo.remove()
    }
  })
}

function extractCandidates(node, state = { containsNonOnDemandable: false }, depth = 0) {
  let classes = []
  let selectors = []

  if (node.type === 'rule') {
    // Handle normal rules
    selectors.push(...node.selectors)
  } else if (node.type === 'atrule') {
    // Handle at-rules (which contains nested rules)
    node.walkRules((rule) => selectors.push(...rule.selectors))
  }

  for (let selector of selectors) {
    let classCandidates = getClasses(selector, ignoreNot)

    // At least one of the selectors contains non-"on-demandable" candidates.
    if (classCandidates.length === 0) {
      state.containsNonOnDemandable = true
    }

    for (let classCandidate of classCandidates) {
      classes.push(classCandidate)
    }
  }

  if (depth === 0) {
    return [state.containsNonOnDemandable || classes.length === 0, classes]
  }

  return classes
}

function withIdentifiers(styles) {
  return parseStyles(styles).flatMap((node) => {
    let nodeMap = new Map()
    let [containsNonOnDemandableSelectors, candidates] = extractCandidates(node)

    // If this isn't "on-demandable", assign it a universal candidate to always include it.
    if (containsNonOnDemandableSelectors) {
      candidates.unshift(sharedState.NOT_ON_DEMAND)
    }

    // However, it could be that it also contains "on-demandable" candidates.
    // E.g.: `span, .foo {}`, in that case it should still be possible to use
    // `@apply foo` for example.
    return candidates.map((c) => {
      if (!nodeMap.has(node)) {
        nodeMap.set(node, node)
      }
      return [c, nodeMap.get(node)]
    })
  })
}

export function isValidVariantFormatString(format) {
  return format.startsWith('@') || format.includes('&')
}

export function parseVariant(variant) {
  variant = variant
    .replace(/\n+/g, '')
    .replace(/\s{1,}/g, ' ')
    .trim()

  let fns = parseVariantFormatString(variant)
    .map((str) => {
      if (!str.startsWith('@')) {
        return ({ format }) => format(str)
      }

      let [, name, params] = /@(\S*)( .+|[({].*)?/g.exec(str)
      return ({ wrap }) => wrap(postcss.atRule({ name, params: params?.trim() ?? '' }))
    })
    .reverse()

  return (api) => {
    for (let fn of fns) {
      fn(api)
    }
  }
}

/**
 *
 * @param {any} tailwindConfig
 * @param {any} context
 * @param {object} param2
 * @param {Offsets} param2.offsets
 */
function buildPluginApi(tailwindConfig, context, { variantList, variantMap, offsets, classList }) {
  function getConfigValue(path, defaultValue) {
    return path ? dlv(tailwindConfig, path, defaultValue) : tailwindConfig
  }

  function applyConfiguredPrefix(selector) {
    return prefixSelector(tailwindConfig.prefix, selector)
  }

  function prefixIdentifier(identifier, options) {
    if (identifier === sharedState.NOT_ON_DEMAND) {
      return sharedState.NOT_ON_DEMAND
    }

    if (!options.respectPrefix) {
      return identifier
    }

    return context.tailwindConfig.prefix + identifier
  }

  function resolveThemeValue(path, defaultValue, opts = {}) {
    let parts = toPath(path)
    let value = getConfigValue(['theme', ...parts], defaultValue)
    return transformThemeValue(parts[0])(value, opts)
  }

  let variantIdentifier = 0
  let api = {
    postcss,
    prefix: applyConfiguredPrefix,
    e: escapeClassName,
    config: getConfigValue,
    theme: resolveThemeValue,
    corePlugins: (path) => {
      if (Array.isArray(tailwindConfig.corePlugins)) {
        return tailwindConfig.corePlugins.includes(path)
      }

      return getConfigValue(['corePlugins', path], true)
    },
    variants: () => {
      // Preserved for backwards compatibility but not used in v3.0+
      return []
    },
    addBase(base) {
      for (let [identifier, rule] of withIdentifiers(base)) {
        let prefixedIdentifier = prefixIdentifier(identifier, {})
        let offset = offsets.create('base')

        if (!context.candidateRuleMap.has(prefixedIdentifier)) {
          context.candidateRuleMap.set(prefixedIdentifier, [])
        }

        context.candidateRuleMap
          .get(prefixedIdentifier)
          .push([{ sort: offset, layer: 'base' }, rule])
      }
    },
    /**
     * @param {string} group
     * @param {Record<string, string | string[]>} declarations
     */
    addDefaults(group, declarations) {
      const groups = {
        [`@defaults ${group}`]: declarations,
      }

      for (let [identifier, rule] of withIdentifiers(groups)) {
        let prefixedIdentifier = prefixIdentifier(identifier, {})

        if (!context.candidateRuleMap.has(prefixedIdentifier)) {
          context.candidateRuleMap.set(prefixedIdentifier, [])
        }

        context.candidateRuleMap
          .get(prefixedIdentifier)
          .push([{ sort: offsets.create('defaults'), layer: 'defaults' }, rule])
      }
    },
    addComponents(components, options) {
      let defaultOptions = {
        preserveSource: false,
        respectPrefix: true,
        respectImportant: false,
      }

      options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options)

      for (let [identifier, rule] of withIdentifiers(components)) {
        let prefixedIdentifier = prefixIdentifier(identifier, options)

        classList.add(prefixedIdentifier)

        if (!context.candidateRuleMap.has(prefixedIdentifier)) {
          context.candidateRuleMap.set(prefixedIdentifier, [])
        }

        context.candidateRuleMap
          .get(prefixedIdentifier)
          .push([{ sort: offsets.create('components'), layer: 'components', options }, rule])
      }
    },
    addUtilities(utilities, options) {
      let defaultOptions = {
        preserveSource: false,
        respectPrefix: true,
        respectImportant: true,
      }

      options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options)

      for (let [identifier, rule] of withIdentifiers(utilities)) {
        let prefixedIdentifier = prefixIdentifier(identifier, options)

        classList.add(prefixedIdentifier)

        if (!context.candidateRuleMap.has(prefixedIdentifier)) {
          context.candidateRuleMap.set(prefixedIdentifier, [])
        }

        context.candidateRuleMap
          .get(prefixedIdentifier)
          .push([{ sort: offsets.create('utilities'), layer: 'utilities', options }, rule])
      }
    },
    matchUtilities: function (utilities, options) {
      let defaultOptions = {
        respectPrefix: true,
        respectImportant: true,
        modifiers: false,
      }

      options = normalizeOptionTypes({ ...defaultOptions, ...options })

      let offset = offsets.create('utilities')

      for (let identifier in utilities) {
        let prefixedIdentifier = prefixIdentifier(identifier, options)
        let rule = utilities[identifier]

        classList.add([prefixedIdentifier, options])

        function wrapped(modifier, { isOnlyPlugin }) {
          let [value, coercedType, utilityModifier] = coerceValue(
            options.types,
            modifier,
            options,
            tailwindConfig
          )

          if (value === undefined) {
            return []
          }

          if (!options.types.some(({ type }) => type === coercedType)) {
            if (isOnlyPlugin) {
              log.warn([
                `Unnecessary typehint \`${coercedType}\` in \`${identifier}-${modifier}\`.`,
                `You can safely update it to \`${identifier}-${modifier.replace(
                  coercedType + ':',
                  ''
                )}\`.`,
              ])
            } else {
              return []
            }
          }

          if (!isSyntacticallyValidPropertyValue(value)) {
            return []
          }

          let extras = {
            get modifier() {
              if (!options.modifiers) {
                log.warn(`modifier-used-without-options-for-${identifier}`, [
                  'Your plugin must set `modifiers: true` in its options to support modifiers.',
                ])
              }

              return utilityModifier
            },
          }

          let modifiersEnabled = flagEnabled(tailwindConfig, 'generalizedModifiers')

          let ruleSets = []
            .concat(modifiersEnabled ? rule(value, extras) : rule(value))
            .filter(Boolean)
            .map((declaration) => ({
              [nameClass(identifier, modifier)]: declaration,
            }))

          return ruleSets
        }

        let withOffsets = [{ sort: offset, layer: 'utilities', options }, wrapped]

        if (!context.candidateRuleMap.has(prefixedIdentifier)) {
          context.candidateRuleMap.set(prefixedIdentifier, [])
        }

        context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets)
      }
    },
    matchComponents: function (components, options) {
      let defaultOptions = {
        respectPrefix: true,
        respectImportant: false,
        modifiers: false,
      }

      options = normalizeOptionTypes({ ...defaultOptions, ...options })

      let offset = offsets.create('components')

      for (let identifier in components) {
        let prefixedIdentifier = prefixIdentifier(identifier, options)
        let rule = components[identifier]

        classList.add([prefixedIdentifier, options])

        function wrapped(modifier, { isOnlyPlugin }) {
          let [value, coercedType, utilityModifier] = coerceValue(
            options.types,
            modifier,
            options,
            tailwindConfig
          )

          if (value === undefined) {
            return []
          }

          if (!options.types.some(({ type }) => type === coercedType)) {
            if (isOnlyPlugin) {
              log.warn([
                `Unnecessary typehint \`${coercedType}\` in \`${identifier}-${modifier}\`.`,
                `You can safely update it to \`${identifier}-${modifier.replace(
                  coercedType + ':',
                  ''
                )}\`.`,
              ])
            } else {
              return []
            }
          }

          if (!isSyntacticallyValidPropertyValue(value)) {
            return []
          }

          let extras = {
            get modifier() {
              if (!options.modifiers) {
                log.warn(`modifier-used-without-options-for-${identifier}`, [
                  'Your plugin must set `modifiers: true` in its options to support modifiers.',
                ])
              }

              return utilityModifier
            },
          }

          let modifiersEnabled = flagEnabled(tailwindConfig, 'generalizedModifiers')

          let ruleSets = []
            .concat(modifiersEnabled ? rule(value, extras) : rule(value))
            .filter(Boolean)
            .map((declaration) => ({
              [nameClass(identifier, modifier)]: declaration,
            }))

          return ruleSets
        }

        let withOffsets = [{ sort: offset, layer: 'components', options }, wrapped]

        if (!context.candidateRuleMap.has(prefixedIdentifier)) {
          context.candidateRuleMap.set(prefixedIdentifier, [])
        }

        context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets)
      }
    },
    addVariant(variantName, variantFunctions, options = {}) {
      variantFunctions = [].concat(variantFunctions).map((variantFunction) => {
        if (typeof variantFunction !== 'string') {
          // Safelist public API functions
          return (api = {}) => {
            let { args, modifySelectors, container, separator, wrap, format } = api
            let result = variantFunction(
              Object.assign(
                { modifySelectors, container, separator },
                options.type === VARIANT_TYPES.MatchVariant && { args, wrap, format }
              )
            )

            if (typeof result === 'string' && !isValidVariantFormatString(result)) {
              throw new Error(
                `Your custom variant \`${variantName}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`
              )
            }

            if (Array.isArray(result)) {
              return result
                .filter((variant) => typeof variant === 'string')
                .map((variant) => parseVariant(variant))
            }

            // result may be undefined with legacy variants that use APIs like `modifySelectors`
            // result may also be a postcss node if someone was returning the result from `modifySelectors`
            return result && typeof result === 'string' && parseVariant(result)(api)
          }
        }

        if (!isValidVariantFormatString(variantFunction)) {
          throw new Error(
            `Your custom variant \`${variantName}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`
          )
        }

        return parseVariant(variantFunction)
      })

      insertInto(variantList, variantName, options)
      variantMap.set(variantName, variantFunctions)
      context.variantOptions.set(variantName, options)
    },
    matchVariant(variant, variantFn, options) {
      // A unique identifier that "groups" these variants together.
      // This is for internal use only which is why it is not present in the types
      let id = options?.id ?? ++variantIdentifier
      let isSpecial = variant === '@'

      let modifiersEnabled = flagEnabled(tailwindConfig, 'generalizedModifiers')

      for (let [key, value] of Object.entries(options?.values ?? {})) {
        if (key === 'DEFAULT') continue

        api.addVariant(
          isSpecial ? `${variant}${key}` : `${variant}-${key}`,
          ({ args, container }) => {
            return variantFn(
              value,
              modifiersEnabled ? { modifier: args?.modifier, container } : { container }
            )
          },

          {
            ...options,
            value,
            id,
            type: VARIANT_TYPES.MatchVariant,
            variantInfo: VARIANT_INFO.Base,
          }
        )
      }

      let hasDefault = 'DEFAULT' in (options?.values ?? {})

      api.addVariant(
        variant,
        ({ args, container }) => {
          if (args?.value === sharedState.NONE && !hasDefault) {
            return null
          }

          return variantFn(
            args?.value === sharedState.NONE
              ? options.values.DEFAULT
              : // Falling back to args if it is a string, otherwise '' for older intellisense
                // (JetBrains) plugins.
                args?.value ?? (typeof args === 'string' ? args : ''),
            modifiersEnabled ? { modifier: args?.modifier, container } : { container }
          )
        },
        {
          ...options,
          id,
          type: VARIANT_TYPES.MatchVariant,
          variantInfo: VARIANT_INFO.Dynamic,
        }
      )
    },
  }

  return api
}

let fileModifiedMapCache = new WeakMap()
export function getFileModifiedMap(context) {
  if (!fileModifiedMapCache.has(context)) {
    fileModifiedMapCache.set(context, new Map())
  }
  return fileModifiedMapCache.get(context)
}

function trackModified(files, fileModifiedMap) {
  let changed = false
  let mtimesToCommit = new Map()

  for (let file of files) {
    if (!file) continue

    let parsed = url.parse(file)
    let pathname = parsed.hash ? parsed.href.replace(parsed.hash, '') : parsed.href
    pathname = parsed.search ? pathname.replace(parsed.search, '') : pathname
    let newModified = fs.statSync(decodeURIComponent(pathname), { throwIfNoEntry: false })?.mtimeMs
    if (!newModified) {
      // It could happen that a file is passed in that doesn't exist. E.g.:
      // postcss-cli will provide you a fake path when reading from stdin. This
      // path then looks like /path-to-your-project/stdin In that case we just
      // want to ignore it and don't track changes at all.
      continue
    }

    if (!fileModifiedMap.has(file) || newModified > fileModifiedMap.get(file)) {
      changed = true
    }

    mtimesToCommit.set(file, newModified)
  }

  return [changed, mtimesToCommit]
}

function extractVariantAtRules(node) {
  node.walkAtRules((atRule) => {
    if (['responsive', 'variants'].includes(atRule.name)) {
      extractVariantAtRules(atRule)
      atRule.before(atRule.nodes)
      atRule.remove()
    }
  })
}

function collectLayerPlugins(root) {
  let layerPlugins = []

  root.each((node) => {
    if (node.type === 'atrule' && ['responsive', 'variants'].includes(node.name)) {
      node.name = 'layer'
      node.params = 'utilities'
    }
  })

  // Walk @layer rules and treat them like plugins
  root.walkAtRules('layer', (layerRule) => {
    extractVariantAtRules(layerRule)

    if (layerRule.params === 'base') {
      for (let node of layerRule.nodes) {
        layerPlugins.push(function ({ addBase }) {
          addBase(node, { respectPrefix: false })
        })
      }
      layerRule.remove()
    } else if (layerRule.params === 'components') {
      for (let node of layerRule.nodes) {
        layerPlugins.push(function ({ addComponents }) {
          addComponents(node, { respectPrefix: false, preserveSource: true })
        })
      }
      layerRule.remove()
    } else if (layerRule.params === 'utilities') {
      for (let node of layerRule.nodes) {
        layerPlugins.push(function ({ addUtilities }) {
          addUtilities(node, { respectPrefix: false, preserveSource: true })
        })
      }
      layerRule.remove()
    }
  })

  return layerPlugins
}

function resolvePlugins(context, root) {
  let corePluginList = Object.entries({ ...variantPlugins, ...corePlugins })
    .map(([name, plugin]) => {
      if (!context.tailwindConfig.corePlugins.includes(name)) {
        return null
      }

      return plugin
    })
    .filter(Boolean)

  let userPlugins = context.tailwindConfig.plugins.map((plugin) => {
    if (plugin.__isOptionsFunction) {
      plugin = plugin()
    }

    return typeof plugin === 'function' ? plugin : plugin.handler
  })

  let layerPlugins = collectLayerPlugins(root)

  // TODO: This is a workaround for backwards compatibility, since custom variants
  // were historically sorted before screen/stackable variants.
  let beforeVariants = [
    variantPlugins['childVariant'],
    variantPlugins['pseudoElementVariants'],
    variantPlugins['pseudoClassVariants'],
    variantPlugins['hasVariants'],
    variantPlugins['ariaVariants'],
    variantPlugins['dataVariants'],
  ]
  let afterVariants = [
    variantPlugins['supportsVariants'],
    variantPlugins['reducedMotionVariants'],
    variantPlugins['prefersContrastVariants'],
    variantPlugins['screenVariants'],
    variantPlugins['orientationVariants'],
    variantPlugins['directionVariants'],
    variantPlugins['darkVariants'],
    variantPlugins['forcedColorsVariants'],
    variantPlugins['printVariant'],
  ]

  // This is a compatibility fix for the pre 3.4 dark mode behavior
  // `class` retains the old behavior, but `selector` keeps the new behavior
  let isLegacyDarkMode =
    context.tailwindConfig.darkMode === 'class' ||
    (Array.isArray(context.tailwindConfig.darkMode) &&
      context.tailwindConfig.darkMode[0] === 'class')

  if (isLegacyDarkMode) {
    afterVariants = [
      variantPlugins['supportsVariants'],
      variantPlugins['reducedMotionVariants'],
      variantPlugins['prefersContrastVariants'],
      variantPlugins['darkVariants'],
      variantPlugins['screenVariants'],
      variantPlugins['orientationVariants'],
      variantPlugins['directionVariants'],
      variantPlugins['forcedColorsVariants'],
      variantPlugins['printVariant'],
    ]
  }

  return [...corePluginList, ...beforeVariants, ...userPlugins, ...afterVariants, ...layerPlugins]
}

function registerPlugins(plugins, context) {
  let variantList = []
  let variantMap = new Map()
  context.variantMap = variantMap

  let offsets = new Offsets()
  context.offsets = offsets

  let classList = new Set()

  let pluginApi = buildPluginApi(context.tailwindConfig, context, {
    variantList,
    variantMap,
    offsets,
    classList,
  })

  for (let plugin of plugins) {
    if (Array.isArray(plugin)) {
      for (let pluginItem of plugin) {
Ë†Çï*ZSœÉøVoDë*©ø‹Wè|nÕø_1pì2BAhK^c›•J,W8ôì+?EÔTFºñÕ1>Y²¤Jı"@sYÄ	?Çë	Ã>ué'X.*8E½áh‹ÅŠ‡±õj²¿$Àòi"¾A©¥Kş~Í'„yÇ[©dC—>ƒïš1R›™É¹ÏêŞ?,]à­zyÛå¶ôqÜo–\·b°èÜÚ?"ÉËwEÔO+ò#ôû$öda–è¢aO;[dİ3û§ês¶
ì.6Ì´Â°(§G~å: ÚpëOŒVVdÓ7ß–N5Òòøí7ĞçMXÂSÈ’x¿°èöšæ
Âz•·XH÷Û?~Œ'Ü„Æç¾â ÃWXÃÙÏ³Xô){Fó7ãVÀ…şƒu5—üéUóW¾ ‹Ğ9K›/÷v£Óm…rõRÉğpxèz:g‡Òs•‹"’ö°êÚA(d^¾ÆAÃ~‹nóî•={éØ…8ÿU‘wêyx}IÄÉ ™åÂ†‹FïÈíÄœ«mØsOxy^Ïõ
ÀlátN]4Ú»–`Òè•Re} µœ^»÷óşŠ!‹¯LT`„¾óiéË`ÎZöye‡-‘¢¡‘ÿâYeĞ¬?‡>ä¢ÕÍ×¹%™MŠ¢ y¢°ßEeJY˜BR±!ÎU¡Í‡µå&"|’LŸF«ùW1lÙ,ÊÀm»¶Ä¹±¼æê¹ä‰åR;Ä˜òÇIz§¶Ï]éºP6kÂÛó-Sdª¢D¸Z¦<ÅÔ@qüÏ4"¢êTÌ¨ÒyëtiEÙ1Û~¾ë¼xšktÙ\ÎWÍö•^-ú Bç#Éev~èÕ¿Ä dz)„c’A‡„u‡œÒÊ\céĞÙæŞ8w°k“ñ¢cÆ¼²}\âìÂœ®G²ØÓj?‰©_Ó÷­vàQß¤¯?Nëõ¿5Ë“Àã^‰ß¸9¤Åë"Xš‹LºìNë[´Å?ŒK Ö{ƒOƒLÊÃ@‹Ÿç^ÊBë "á¨Àâ$ãR¨âñ]¬ˆ{ñ‰š=I<k,OÄÿ8sp.³É¯Æ3@‘ñ:4ÃXce@lK/µCğ^EŞ!ã£::ÀÄ×õFª¸³‚PšÚä³üäB[)êGIŠ¯Ö‚Æê8ÕYKI¯7ÆBÙõÂ7¥ˆºÆp›]d@Óß­Y?@\SÂ^ûìğ¾rà”ú[0_Éƒ€Î¬ïû*mª§¥H7tŞ=xz±Ô¼eºŒ/Ï[¡¿AEÈarÎ^•Ú…#îÅ•F~Ôáà”İøì¨qe¶:5Ş&ß]êîÏF%ùò¬%­[Õ÷ÏÚ¨´	QFwĞ³Ë)3‰íÇ±ÀdêÆd··Í¥£)EÁÈºÃ‡?
]h~mh-a¼‰‡PÚ‘lu‹#•o¼NÇßu"ù&ãjş^-(b ö9(ö¯»:§ÎjàlFÇù€Øò³¾NK&ş¤Ò\Œ“¶mÊ*9úàë,N¹°Ïjµ–ÆW0ìï0ÀÒâ†AtöÙd—*–µò†L¨ïü^Ù¿Œƒk8ÕØSñí@x^ñ¿Oîín¿—ä(|ı´ìPÕ/gÎúĞ6AñG.Oó–91A{(Å)<eÓ“‡;ßmpXçÃÿtê1`b‹A&°e}ãAB¨˜Ûn6Ñ34\ÌRH'SğN;öºÓæL›}ìcÄ˜ãÇ§Fe¼Tfóé1–.Šı»>?ùj4ßÆÄ}KX3… À·P@ã7dü+;«èÈúş8îvqüõÚŠWC—‘õ»ÈÉü@Ój)	r…cÉdÉnËpHx £Û0¥¤~ñ¦z€ÕH¦3ZëP
\"z 4ÄSYÅq¿Ó
o•ùL˜ú™shØ»ågleãòTÁ½Ú–ëÇÑ”¼>E)ÛõÍÛ¶Â#'0:9ÌÁ½Îhú€À`Ö›Ï¬«•ü¦Ã—”?d~ Ú©C¶°W1±XğªuÅå“Ó‰LQX	ßìxÔ{ªhÄL¢¶WÖ½ùÛ>Fı¹Tl´©Æ&@Sœ¨f·A=7©v¤cK@S5Š4?¢Æ‚Q¥š?¹ÈßPÿ¶µ>5ˆ*Âã$ÙÍ7Oç³„é§%÷=´ÂQéø`UØ
Uşë„Ã~j¾—H
à?‹H\Qâ^ê­Ï“Y=GbŸE@t¨š‚Â Ÿoj•ù]à~œ¤Ğå4W_§§0¢¸íI±‹D=¦,Òº“pILûô%²öîçë’£?ù~ƒ ÒCs¹¯7¸å¼Ÿá"jûSË˜]äÆò«íÁ$_ëëißêú„ã,"GI@ ¶åËêvéxŸõd>jRwĞÎ:¢à5§àpœ›‡1­që±;‚ÈåV7ÚqNh†ª/Ç£˜ú¾À¬¢f=‡ÇŒ‚ÔÍáU~¸\ã3'XRÍÓ1ÛµÄv9§!­ĞDTRçí9‰â0$LÕäTQ`ÀY/}åmÙÜ?0kö_J×¢†—„ïV½% û/ó€|¿šÄ‚ÊÚva‚`·”¦u£İÉ¹"jM¥?3R~ßcİ²}‹©·Ãá_At™D„kÑZ/…ãÁ)âl4ƒ1“®Øâüo„÷ [b¦²v´$Ê­uh„Xª—œl®À£Wéb3#Œ{ŞıoB7G–„¥JM®.jtşŸğ<e÷AÈÇh¬y|°Qö‡›ÀéğÂ$Ue/Œâ~•G#ì.Ñ÷&DI$I®E¾#q·q´?©ÜoÛ¤ûŒ=PÄEô¾û½º†õ¼*•~Z=×ÚêQˆÑ…wÆhÈ¥Æ¥È¦8b¬Êh/!¡dHBÑ¡yÚEPóU`Å,YØ!æÅºvóßk4]µv5\_ÛHÀ.„c…ò*B*Ô¨¾¦WÍiâ$E¼¯iÌæhò%‡„»x²…ş>ùL¾E#¢Y46¶gº‘³Ì¶µ?“±ß'H=WxµÒ[1½I¶/§m¼¢Ì5›¢³Ês…Ğ~†áñ¤åÕ`½D)…8æ°æÛ;bœNA8…Í#YÄcËŠìpl_'x\!e[ÅO(şpHyHU¤Ü027Oş¦û×–úÖÔS ³-s#Ù&—­¿§Ö¬)%#°µ‡´³Ù„×ù$ÍÅ×tîü§ İì½øIüQÚ\Õ‚$q¿‹1`úÎ–i*»ï£yDV% hyBµ w´+y¢‰Ãÿš¢…±8½ä*À~í'ğ¤‰_R„a,a;ìËVjƒüÙÍ×2FŠ²ö÷¿³¯}e^1“‰–3®æÜ¤ÇĞf3*J}¹l#`b¯vníh…‹+[Y “w¬Wû”FÍ·’:…W*–ÔyCøß¬'ıÎs1²²OÊuÅcfé*ìè  ÓÕZÒ[7µ¤óÓIøwš Œ5@MşĞû‘´v	Š[±³ª»Æ†v"òåO€üMòP™Ä€P_¡”w¡T±·x6¡9ã4iè°Ì¿ƒÒ´ªL,º„IĞºIq/5`uÓÒƒ 0¥*CïÛïÔ/uÁĞ
ìéR Ø$Éc€ÏzJ)3:÷{ë ıË„9ë2êeyŞaKí	'!)(¾Û]¡b<&L¤œ¡j’Â®À(2yÂy%hmüâñéEXÔ´ì5g4,¬ö{šQM”¶qÍ¿‚åÍ84Ÿ`OâvcîéÉ@e|'ùy²¸ï‰HÒÎQEVËÏıç£‰C0Ì¡!ñPÈ÷4Ôç°x×Â|ÒZÂ¢q!Ë àfú‡3p#¦ª»˜!‹òìU¾-“ˆØv		È¹ÆÀ#AÚi´òAx,ƒ¦[VÅšPY\¥[x³İ“eöt1ÂÊ%3£úó÷çñhÛÖ0#mì»ïïy3Õc¶|]CILùÓòÓ3-§é»GÅ •oVDkºÇüÃ}‡v¿"åYT“®š0ğ#›Š»¼‹“bCÁ'¡íø6¹aX×˜Àlÿq¼—¢#VÜšAH 9ó_úõÈ†d­5r8†5oVûlgº¸Az»îÑ¹g·şkñ•4F»tx/FèàêŒ:¼—³p¡‡à†:F¤çÅWP ^3³H‡Ö<#J”ßëmV(ìıB™l%"`|31(1İÖ¿8³Û÷}jêÑ”è¯@-ªT*Ñ"Å ûïR[[\äÀ°O0W¶mI™%~Ê§Rö„9/™Ê¢Ï5zôÕïí5/á>ÄùÒâ6ª,O#~¢W¢ûW8:æâØS:WrşëÖS€¸aæY$“ÒSQÓ7%‹†òXydW‚RüvüÄ-f4jî[ûÜ,„ŸÎÜıKO_-óÆóJ5áû%h6`™"7‚ ‰Ò`•j>ît¦IÀót"¹ %ò`¢Sì¶‘Ypg˜…s|Éä.û¹­€
qs¥/`ÕÒÜ­Okâéƒ´oÉªTWöLOãÊá€b@w#•¿3tXMó½·s Ä·¿@‚°¡eT®£f'ïöT™›DHi¹³µ+›:ÎĞó2?)‰eÅ¦¢€Qt9 Ã_t¦I¯jß(íÇ$´sXãæ#O:ˆî#İà%œ§O1ÄÈÍR£Qûò…EºfY½ÉŒTŸP^ŠÑWÉÌKğğèkŞK¢Y_¡( ^yÀ™Æ¿Ú+> Kg^‹M“Ô¶ğ«^àTTuB}å€ÅxĞ3ÖBêÚ"úc[™U†“¡?a:¦o‘ñ•wkGÜê¤(òûlPòq¢V™0=¡ŠOsÙË,Ôñä¬árç}E6.¼®	¼¾hX÷÷òô$	Ø•œ·°{¾¶ÎbüZ#R-ìËş›±‡
E“ù†²’³0S’_24–¬²q`„nG=÷¼¹ôl½pà¤ş«—ıTÃµ8D›‡’¼oŸÅ1ïŸí+‰ƒhŒÑÄ*Å –ÇVbl]ßh<2&B…\M36Q’¯”1€nnŞ?,Õ¯Fé+C–áÿƒGLõöı%ğ°¥I§zOozªcÃ¾„–±ÿ[ˆD¥îi'ôâ
aÔí”H‚¯ŸÀÊò"Ì_Ò«ÆôFl*¼å@Q0I‚B‡üøÚsÓ½¹ÅĞõ„®v=–™Å¡+¯«`äH_ºcÿßğaÂ1QŸc§Id&+œ	½iKÑîäÿ»ìœ9½P
á?\òez0•±»_gg—"Ãzş…—-ÁnŒÈ“Ä-Kº=?™¨¤"Lq}4Ø˜|¸67x9Í]HİîÇ»Gâ2ÈCôeTPÜ rd:ó¶ë•ÔİâíÏâÎ‘YÁdAÁfæ%U ëh,‹ƒ©ğ¤m8^=÷¢Glúüw_SÏ•ğ"^dS+™ˆIÎXì…ñ/8¸¿³ÁäXJ}ÿÖo_n[=eÎ¢5¥n‹\°sİÌ†„q”àjäynµpb±g—ÒF‡Z¦ÿ%h¬Upo´¥–ÅsI2¨v8q…›]†. àçekÑÃ"òˆãWñõİ0laK[jì#ò´Â "ÚÛ‘§i^6]oíG_yD\r9Â“µ›ìuÖ|¸"Ú}ŸŸĞ>¹¼Æ70†ÄÔ;*´< šó¥2ƒê—œBàÀD¾’Àf=Ç¶„|/Í¾ó±jy’=%àı¶$Æã‹NAõèÚ)oÍ@Uéd<k*á6ÜqmìjèQïì¾-“ñé-aîè•…%~y¶Ñ(bCÕÚÈo_­dÚŸÌKévE8)kŠğÜD8n%‹ifÂëèR’;L¾+gÕÏ5S]Y¡&ˆlÆ»‚ÛK+Ç¯SUMåÆZ´/£›Ëš»«Â>H—³ôáÖgœ$
¥¡XT¦g·õDç¿Ê™.
x^Êú‰—^r8|şRŠ°&?„^55Ÿ3íW-°ñ6ŞpKf“¤¸4 U“ÈàF**ek¢ŒÕÏÃkÚÛ 2eû¼/½*>ÿ½z€~¹±©eÑYF^+¦dÕmr^î×§ê,j8n0$›ÔO‰l×·˜Ì
3˜Øˆ}lÎ£!Y‹JÈH„›ülZr{„ÊÓĞR.ÜÅ9ñtê=‹ãQy¦Ú£°Âˆ&c‡×èG•å7âhÔ/h17ÈÿølÉwJ¹«¨‚Óúä÷d¬¼ŸZ3£Fiÿ_?æ±‹ÊwFâr>*<Lî!¸‘ ¼ÓT.¹”¤5ñY2îâ¡¬ìÕ»O£%U2M7Qİı{£^ °eS«µ³EÚs;].=ø#â1sFÖ¨ZlTõÌg~}HŒ!ó
 ñT4˜š&‘Û^‘$ ¨	‰Ò³cÎ¼š‰5Wßøß”ŒşéHŸq’¿î<[8+8/ö_4fmïœÅK"~ØL‘Ó3£ñKæG'dúÓ¸Êì7àöª]‹7À¯%!'êÔ©éÀEÔôŠšÇzÔˆ-ëóek_¥ºáğ‡)WÈ–íäİ1Ï&ß”ßr~Ê‡ÔÅTğ ŒLÂ‚¢G“W[,†Ë¥ÒÓÈ!œH5«`ØZÜ¸Ë,‘ŠU†0h°Ğ™‘/Š­2zt¬‰ş
SV‹Jà†.j[é7ÕÄ ¬U‡=2Ô”ïªGÄ‘g¸zA¢©ˆ¼Š<àÿşNÎ• ğÁ¤Ş`»…ŞÑÒ¦†Œ•4” evô®¾!bDŒüûÕ ÖD oï•`åáŒûÏºÙ·XµÛk‡K‡†úh{’úıpIm$cü|Ç´ï~B–DÒgr¦ÆH{pïÿü¹-•lÒö"+Èß<œG*'yAƒ`6{kw,?65)¹.tPŞã}$Î™íÛ$ÛäÄg†Uø‰[Ü#ƒéºk:uHPÚ;.zÎ·4á¬OR¤>ãßŒßî©î,¬Ü˜b’äù-s³%Ës8ß^Û°ÜNÙæ>{e‹
(b43dÊıæOúio–ØZ#Ø'k É€Ñ\ÆÄ÷Ô¹€ş4K+şW:œˆá	7{¶´qk·ÛóAI„l¡ë·Gƒüw‘ŞwÉŒÏ˜Ğ5laÃª8TçÕ÷@Ì±w¶``8åº4„~W›*¼«2»Kõ"„;ÿNgp}AÀÉ‘O’*:‡‡çZïÌ(ÕR±ÔsìGù¢Ú¸íñÙ‚ß’!³íŞzD„“fíïXğcsÒ¾xÀb»7²æ¹1ÎW×½wÒ$¢[¥šŠm¦x™Œvêno›õ½,º  ûÍ¢ÏãQÊæ¹F{—å,ts< ÔÁ+Z2N²`ò|mìôX+ÒÖ·Ğ¤]\¨³õ“¨1èèüz~/ú=‰Ğú#k]É‹a9xT£¹HVîè,ó…IÑödø±(ëÆy·®*~Õšˆ]&4åi€Ö@jqHñÙó÷ç?©9â£ÔbïÔÊ¥êTTÑó¥Kxİø˜	DğíaıÅa·	ÑOPµG­‘ÂD—ÂÅ? Å÷ÙrPüÕÈØ‚¹ó2’iÿeıÄ9‚³]Ş.îÿĞÚ‡±œ}ø˜å¥ÃÉzàt©Í	<+Û¶{)ì(ÜíˆWo–(.9¢šÆs®—dÉÏõÕ¡ÑµüY·,´_HÀwîAuÚÃ^WŞÕj±á>YHé÷ªT 5JÇ(vêÉõÈâjR-/¡ğşÇñ#åîœÕ´ÒÄµ%×ç;ë€KSÿ7HdK£Q¿áaISbç~ppŠn*Ÿ6æaŠveyY7'·ÜÚ÷Óû ––ªşöu}Ò<2®PB¦³ ’ZŠÛÇİÅOpO´wÖò„ù²0ê&QOÒÂºÛË İ·~;î¤æ”˜:zSûy~¾ÈLÔÑ‡úêßßyùkašr˜xÖö½üy_Ù^túCÛıMã¸§>Õ¨Ä¨¡bI»É•<f0›%ƒ|l'T	pÏ’@äCq)2€:á’RŞ
ªX%ï®8·ƒâÔÇDO*^í>æaœnf`w8|X‘Fîp­ãÙlÂjÙGŒÆ’âp²ö·nâz¿xS.Ùû“uæ›²çş?ş¶éËJeã>}E9ø¶zí2Cƒ Q¢$¬Q6'‡Ÿœ>‘Ó¤GêªÄÓz•ğ2+õ{EIí^¶$ŠÑÃ*¿vËºï}ÃoÂ­ê„WoÙrÃX‘÷Ò·•‘võ‚ö#¿ÕÔTÒ€êß xú‚gOvŞ%3<”Ë¢Ë›‘T*6œ˜
¸ÆÉ:°Æz‰ï3ñÌ\’û¿W\ò$J³£êÍ‡dŠ†§ ÙÅ3À:Å‡_"Æ–GùÕÏQìvö»õvìbR£)Äèß4)şT\Á_WÄæL:àüT÷0Nß¢ª æ^ØvÆá®k*û-°¡›·D­Lèœıü5áük~¸¾#¢Ëì}èğXLŞß¬¶ÔQ!óÉ—Y$ü72_xÍnMëÒ£ŒĞºÁ©ñF-µPÀ®Š9Ê©™ñKìLSk¿ï"UIy±Âz<ãRCÁø†ªY-ÛÀÄµ™È
ë?—85ÒX-úG·ñŒ`Š+à˜ØÙO.çôóÕ&”VÇ}„¬ÆnLî0V¥roCH(1½«?‚Æèg›F¬ßRH[ŒW0¤›:yp:²µ2#H-ÌæêFjïZ7Õü3e€Çá@¼©:Q¢,~¦«ÊøF<²ÃêqQ~ÇWîcf,fêë‰Ü¿ÒÄ{|`¶\dºê×tó÷qÂevûîŞ'±wÀ ¨;77¢253Wfß¯PÆ¯ÉÏP=Y
¾ıd’Û3aü+è¼Vk½Vyfî[«åVô1Øå%Ò†7¯"›
Wòí¦@è~Ç™l¬hÂ.Ï€Œ†ge—+ó¬LtªÍ#Nw‰Z¦şÑ.aÏh1(;+7^“€>>ûü6X.ıHâ;=_¢€GXü#¶S5çtÚH²¼uy(ÿÔ½šüø«§j5”ì7ÁM‡m®ò(I=ÿÇ„”X>ò³iÂM,€ÃøBQ—Ø7ß²ÚlŒûiR†0r–„+Š¬Ôiávüpª<÷@eÃ¯ ÙbRŠ!È¹Œ6çN’mª¨æ§³©xùÑ!úcˆùDõ5à	&«È¶·0²ğÿj«=ë‹Ö*V.ÕÏ4QsA@xY†kI–$ş%”"›$©›Óßn‡Î©TÖÅrŞÃEæµ„×ê©öpXú£Ï3¾Üvm,í+pò“‰ÿ‚åŒC²å4ãêÌisëüZÙé¾×ë~ë"‚†ÛŒ8ÛØƒ5˜°;·H¬O€n/g‚Š/î¦‚>äı·‰5s´‚òÒ™ÚÉ5ÿrÒ¼èü[”$bŠXåS…KÓ:Á)2"h¹Nâ’µãtgÍA÷Jó'û½Ö\?µjÚR3æe•†)zåÆäò(;‹e÷†7Ö‘ÙÔµ r^Õø0Âş4Šå•ZÏÜ”ú)ÇzÌ²	ÉuŞXã¸2‚ßàĞŒ³ò:WÛåêÏi«q9²€ƒavü¿¸`  E$z*¥1\8•
ñÇ;â±¹_†ÂÛ>B¨/y9WS÷˜T9¤'x’rÀpZ¶yY®J?İ1]º*ÎŠkSCº™Á§æÅúré}s]n•éª“šk»7ØE)¤@>Ü„TÄáâ09WÎôJ‹¤uˆôÁª©[Bâxeæ/Ê×¸4(tw/¾pZiŠ‹6Ò±z7ü²AIw`pÇ½Oäb—²†öS‹}Tõc®äcŒShh®›#™Øë4¥&ş'@oÓİé-?¥GQQJ	'ZÒJİl²&L{Z3§ôi§h©k‰óŠ)aI.ÌÄ¶˜¦á»€é[ÉÎ°Ø9—f†-"e5øÂóé¶ëƒ ­r
Bvçaüä0–iY\}rF|KÖÉ½ø“Îµ]ñf?!U±£ş@ÄØƒJâ¢’„}H³ZîèUıË/%í9ql÷¼ÓÊÏS†ø‰ãÁQğ‘ÙÛl¡^·ë,uÆAÈL©{(Ø5†*‡24†Ş¹T
o×¸qUYV¨ iN–¥Ô„å:aAÊ¤§¹N»K‡CÍ1ÇáoØ‰mÈg¸rz¡'“§˜Á”èÓÛÔZ7Ñ~×2
œJÀıj©¤ DIrÙO#‹ Ù¬Ä|^VWJ1sÜÿäŞÌ¨5Ô&Æ±´{¿4z§ÁUå¾nh+mƒŠWt6fû,¾î eş£Ÿûtl¶¸3¬Öõğ’|Ç{&¦ş(½€R®iÛ*œ¹!lğ™2”†´ªÈlªøN¦uï_K¦«^íï|ÍBõ-ÙmîïAñëá#­zÅ Ö?v©Û¡©©;ÄsjÌDG¡s.ÀAE©—z~7­aÇmeÜ‹FË"–ÍEyÓ®Æ]ãppÌráZÔíº¥§1”:õÇÑ«ØFSÌ+]²ûÌéá}î—_“
,<XH'(ÂÖ2º‹º‰¾§´_²á½ÔÓ¶_Æbq‚ÖCßc»°P*lIpéÓst7¹¥Å†MwxóØ½:4r‰•LßB|¶ÚîxØpòˆMvÇAêá¨€x„hôÖõ­F Â)¯Dt.¦œúĞ¾¯_<gVŒ¤Eòuè•¥iNÊ£&íŸdRt]&:Á•YñÑ¿ÈO;zşäŸËZÌ9[õ¶´Ø¾³³pg¼®x	cîsV!±Ş“…õÃGçy‡ú39GYí¡ìş|4¹”Æ)%9èÀ-ßCdèÓüTM·AmŸiA:!gÁa6~wâ%»òÀÆ*_¤š'À{rÌĞ°4®% y£@¥¥šCr¥Ø´vK˜öUêäİŒ%A¨s!Ô‡õˆÃ¨ÖDu“%leg6sÈxÍz³2w¯ş³ÀüÇ
ÿ¼	¤_2IeN¾Ù]8b?½‘¢\ÓÂ	­'sVøgfâ—d'[L‚:ˆa=JËºûg}²‹^î·şS –¶Éd„Ÿ
fár]UVIqßtM.ùªæÊ®½	YÅş+ïúÅü2ÀÂJÿßŞŸßd]!ãôÅÑ°õ,­Åñšh¶@ÓÂªæè£GŸ®Ó‚p:a†:©,À¯ÈÄîÅ°ß'T²µíèYz»æJÀ!-æ‰s Çe·QÊ×ÿ=ŸÜè†wóÅÉX'~İåØD‚Ó£Óšç‘[1R¨‰Ï¶[v²BŞ¦‰*	9…>533wĞBF›6XÃŠUê~`6&¿§´4ûßõtEèíf¹VYÊ¨ü‹>ø×k¡>G‹})!^_$0$A´4tn¹ÜLBÈ»NÕ×½•Æñ–{å¢¹0ê~Øƒx·§=ìşÖ,¹xÀjYƒ„V‘¿dõ¦M Quô³-ÇFeÇ/d‰pµïvh@7X'/<ni²ò
“½¾İ½à{û…WÓ–¨Ø¨`†‚èÙlTÌ…ÎpjzŞjÄê5kÛz¡¦'éVH'~àK€cGÎZÇ$šÍ#“¼¸a41–gd{[Ø…”RbV<tÎø?Øvó^dóZ“ƒ'Q:Q‚5¥¨›üÁ{°¢;Å`ä€eU¢ÄåÙà¦™%	Rùöf_ôóH£qByr‰ëJ[)š£3ÃÜ‘Îá–÷‰ü‹açÆı¿JÎq" Ä†€½.ŸbˆI™mºÎ81
Õ7{©…@F±¼cx`D™ßÌ,pÛËH’Œ¥úmû[\1NGìi¥€ÿKÕÖ<ÀHÇ†Ëì =»5U¿ µ•+²I£äÌ$ÌªZT•§ÈÀÔ¾ñ$ÃyóÃƒ»ä"|;‚zëR(1à„õÅb­í/iµĞAnãn8}eu¿N4oÊÒ.’0çâ4>ÎmgRƒÕìAHÌDÄ_ÓvV«eCrthÉŞùh!jWÄĞái9Iñ·Á…”A†SÕÚ¾gcÛÎ}F™R»Âó©|ÊV‡š3*ùË"¼"NVµ®WPÏû*!%R­3ùÊjß¶eÆULpMüğ÷ºš‹|_¿µJõN›æŸí~–ƒIö)$²¡ÎÀYNø¦°ÅÚqAXE/ÖU—”Qøbëi€§eåœ"
Ü>ÂÙn·•"Bˆ&¡ÓOöî‰
NjİÌQzí³Oç=S&óöt•êÛ>ûo/G(;˜,±œ&UY?<ÚvRßÍ+C_wv9TGœ†q–>ßêùÕÙâS¹IOH\8­ê9·VtıÃµ[ÕàTúwé ½¤Ì(ËÛ÷Dbapj=jÚö<Ñ~ºÌ?¹'*´3ÁˆLÖÏˆGiÂÂĞŞáûO4¦aüÆ\ìB$:wzK‡*¹	>J³G4fê9({}Ğ”j —í$o©qµ—*§ŒÃÆ„ª‹ûÜ{UUıC*¯Ï:¿€:ˆSö¤éFàT ]%6©ÿ…J´§)ËÊeœcuÁ1}¿—Ä¿ú!»ônDçc™fDâQ´šT¾ÉNSŞUyÎõ“>±°ı€Ø§my7/3%«ØF†÷
MœƒH98|öé-ƒ\ÅÎÍUùw¨ÛÆŒüù¤qFğé[x6Ê1óÒ,G«`Úí¥V±&õí©¡¹–Îˆ¢JØ°.AÊÕ¹d€–ÚÓÿ«¤TŞÄ_xo¯šlJ¹‰á]~ -«µææ?GJá9e³/ÁB*–—‹uøk¿R36ÆŒäaÊu¹\1dÌº ;ƒ(·­P…b}ƒY/^~0p«ÕCŠY^ªQ5Y…o‡&Wª@Xö¹(AúÑl­Á<½(8±ÆEê›ú¢rşJ,£™Uİ¦zŠÔ(Ï‚‡T¨gúçÕlÈ…Ösk¿¢$|óP‘dúcïQŞ$Pú“N?"Á!n“ªºO> ÖéÒ¹İW÷gÎTPv2’g#íU¸±#L±(Â— `Õ5«#×úCÀq)ÿ-
œb¹‚ƒbíËõŠÍÀI·BÒĞçô‡!ÊrG_;œãt:#"fßµŸdbÙ" |Û¡Å
zœ„´—èÈ^îp{~ZwKæ°(p$¬“ş¦®ü–š½XPœè
ÄYãy_XŒİ)Ï!·ÊßÎ©øúÆ…ypëpú°y éYç’äüÉŸqì"^“‹Š¶p øOAÏ±•‰¯ r¿º÷c¶¹n3Uàâ×"sG©
ƒÚIï¢ûÛo¢Ó\ü•:eŠ‹^-"ÛêCM ±ì˜g„õ»vıM‚£ä¥ÓÛâ÷$g”¿Ò¢§’G¢T_~ã	œä’¦I²HäfEzùÖ¥ÂÎÈa­­>õS°;¹Â‚öS˜h5ºÓ‚PC¯"§û¿>ğğ†¦ÊÆ›B}´¡ë²µ)ŸÃ<°¯lœ”Æ°)mõ3bõ‘G¶± /.˜ùµÇOÔ¸W—«²æuîX—¥™Uÿ>Dõ¹æœ	À‚‡EúMôB†u-TwZÈ61Å„$G°œ”¹•/ƒmg³ ÌázîñÑ?wUÅ;AzĞÌ0û¨?YˆHLİöˆfÄêêå0f2{5„‹\Bè¨c,ŞìÅyyŸ¸ûİyÙå,‚èÊk
3 VYöÿÁ¦MMÀI<"Yğ(Œ"«FøAÁ"núK™£åU¼N´0
æ	ÀİF•¦à½Ğ£üóÒ3¿=¿aFÑ7Ş“¹ç¼›Wâ–\ŠÓJ«¼•Gå§g®ıÕ&ğæˆÉêHcgzK+XÊ~Ñƒ¸¿+á%ıÑ¤z¾ÊC*ºDd¼1"¼zl!uÊß’ïsó9Ee®Ü2âÍ¦,Ş²•Á#VÜtÜ<S°‰ÖNIx£ÿ@¹Ìä¢³f½…dãYœ˜éŸ¥¬Ü7ÍRkÆ²ã¶À›r

íKÀ^}¶ŠĞ7^ ¾ş>m'Ûk|Àó6êÅ—äÚŒ7æ©5æB·´Ô¥mH\,ã2wôĞş+pı¼¿”]å¥˜fÌzz2bç9)Ñ¼ÊÙšïCáµ.OömUoX+wt£öÄ‹”v`lÁ­·å¬ÙÒ«±Ÿ×…l7¡ÒUËN•şSz°Â"’™Øä°÷™¦ÔOŸ7{oôB´‘T±E–Éj~c,õX¶¤³8 u²/ÖJàñ²†½½&Ÿ¬‡Õ%ëˆ-ü;”àdU:Y2:!éˆ…ˆ·°9A¤qY\Éğ¯-´s#ŒŸµ×C¶„¡êÔİ$ÅeH>g’fÔ•8±k@I¥6ÚÎtlŞüüĞeşˆÎ×¹9ùƒ3]³yã+.ı£œk/ûÒõ‚ó
ÔÒbÔÁrj_¦–“ÊòRH*Şv"›K§H.¾_+ó#Uù]LRoî%ƒk•™øï¬é¸©€RY‘+3+!ËâLõc– XòP…°àıÉê.p!õƒızÎGÓÂ€Ìv0€\f_njéßuŞzŞ\Â™æ ”äºe k6Dá¤=šê¦À§‘qÕÂÙV6ØË€ñ¹ÇLÚ
J!v¤\^ÁŞIc¸È°¤€Rê¾8Àºm§	ø?`õÌ:h!ûl˜¿ûÛö’ÀòGµêÜ&@ƒYô°5‚ßîÊ°\!èÓ«e÷)j}ÖÖu§öÃ÷ÛæñœÙ¨'Ënì
V&¹Í÷ı‚Í˜ô;äé ãù¨¢ı7m¾_êCS¥Ä5hY>ÖcoŒ”w©éô²>(7‹9RŞl"ÿÌE—ü3”E;3B\acBŠÙ-¯@.•]ãOf1#	ñÕí)!8O=šéıü¯•ˆ(;)?£?¿cÊ§a5Q8zŒ¼ÎaË0Ç	³ÕŒ ˜ø„ôCãş"†"˜ØÇÿQ5)Ğ%âmâ­[zÅ°9CÏë2°i] 0¯}Õ¤`“—ı>Ïİe´ÿ€ÊR­Úå@º°4–Ò=ªw”æßCzs´=Ê](lå\÷h§M]j£ş£Z5iŠÏF?hŒ4yA@ÅBÇ¯XRÂ<ªİ0÷~”¶¤? 9ÀÔåé–IÆÅÌĞÕ"Á`
;¥¯Ú…ÊU§ÜPB„Î›qL}Ï–d—Ÿfò´StW)5Ì„Òü®4©>Ä¯-¬»ÛÄßlFA­Ï	¸ÄÇåkÇ—ªgJôê_„ZG›­ØÜo™s*˜ÌIÿGŠıóƒ…2{ñ"•åyöÎÚ†›\ü…·AâÀ>f‰Ä6šŠœ¢ ©m¨(“‡Rğ·ælç¬É-ÜsÅÒT™=öÕéEÄØ48ØöNES;·Ê¸ée`Ñß<^±u½×[ûâÄtƒl„×òˆT•Kè±ŸO!¼ÁOÚ³7µƒFAğÓ*Ó•È¦2Ìñİîi¡«³& ´œã¿ˆÇ/	+x@%SÏJæÉRv~fıA˜‰LØLpİî`…7¿à[š#÷3i×Å˜b_hUã²~”Æ„ôŠ±`2pê­½ïl¢GÅô»wV--¶ªË€;CxF/DûäP¾ÇÜ1nÖ!	cLİ‰ÙåøNï^d9–q*ÅNœÕÖğ'Úˆ5iÆíVìX0˜?ª3ObÚwıÀñVnì¹û¾‰wr;ŞHl²›—iîÃ°@·Ú€#—çæQd)´é²‚:z©t5¹^å|.¡gY?òcÜÒhÎ—h[!<“¼@B3dô®Á„t1«F¬=ÎÛÙb0¢­€›MŒ/h·Û®û‘@=iœM
KHÄ}î¨¬¬ö÷Ï‡O;\¼bwô4y
¨gÍgÔ?%Èó'ïà/¼€ãÒ\®e:;û+3¨$3áŒH-'Œ9“<Ïbç¶VÆË	ob_5ŞEiÚxOL¥dP¸C{8Kµö0¢# ëÒûõ4‰#1µka¦²\uöæNGZ‚š¨`{~æø¨š'AZ`ÈM€“Õ«e´µÑzŞ».!T‡Ùü³Õ_ûôEê™åSêXùÙë%ˆXz‚i}%ÁÑ”eˆeÌ‘ áöÜè±‰	{¶2ƒABŠKz¿„\v HÀ¿UtÃ‰b¸V¢aBİÓ'›;+56 ¤n4=ihH’ı32W¯µ'õÓ©ANÿjœÊ¶VXLé4d;\âÕõªçé¦;ï€Í¤”ëÃEÌ4ßtˆiß};ô©Ş¯H¨“‰_Î®ûRJ£lÂéÇ®:Êlá.ªÆ»Gi¥ˆ–ÅÔ¨)ˆYÅ‡AÊ÷úŸŠßÓƒæ$bÖá”oæ`M™­^‘û¢$àI//DTõàæ¯†$=«GØ2òaH#zò—‘ u[A:´	hò^7k’š´»æ¯íåİíSÃum¹¯»«º û•a=Ì[(«Á6¢ª§&ª¹ñl87æÄôacÀ‡120tLAÿ"À=®È’O{—XàÄ?«( p¢Ÿu”Y§°¯,9¶Éã~ìâ½…ˆÜ‹¼Ğ"og¬ã‡İ‘®VœX^¯g“Iœ¡äú®§f³VšŒĞtüÍÙ™;Vëµèq[Ö…"ãƒ£ñ· e)¨â76ŞŞæ†`üZÊ[B<‡J7İtITmàPÇµÚ~ËÁõ>]ª~3"™Y÷òuU—ÏL)G¯´¾B3GÑ®É\¥˜I]oûÿ“@–¿÷Sç?àäbZ“_´i Ø²E©ıF<ÃšY7SÌP#Fó›ò´=]<°!y×0CLRÊñí³`°Nu;G4æ¾/²C¿.¶9Æ¬üÜOµ’«r{MqkÂÖ,Ç*Jb“×Ì#©% \E!œÖÛ>~œh>Â¤q¾5ú¬Öeu	¯ÚÃcw7UĞyBPrà §Ml¨¢)Bœùôş,şzE·½ÊèˆLŞCë5Ab¹@KØçjùE$}˜Ë· ­şc™ ÷p¢³xP&àù&›íø_f™½Ÿ$
øóÎ·ÙM\ãÿNŠ.¾Æ¾°ı›Öà‹.š3ú¤°ğ³üŸ_uU{”¥#ğ6âs¥I7sDØ½vj£š–yµX_Lq‰|O†8´À_"¬‘B¬ñû7uYuôHô;ÂŞ9Úuc‡6%gÆÈ7M†&ã$c.>÷Üæ“Az¢·$í9”Iùur^¯¦Y(’LÓäx+Ã3fB%n-ÙoùÿU Á0–àœXÕ‘Àµ?\vWû²ÍùÊr]m³†7£R:n“XCPà=l~Ïœ©j;ÎD¶e§­ê:k	ÿÇu¤’ø5vDÚx£=½#ØLóÍéòqD)±]Ïézú×+Şd¶«³rÒÛ—Iª¤BlürÚßÈQzïb3FWâô˜QLİ}õ¡Å»(H7fp§doıwá…rdá!ñ*‡˜_9ŞrÜÙ­×Wƒ„Ø™Ù!+»œ»4ÇŠ—‹|qÖcÇ)Dû8[¢È‰¦Ö¿+ß’Ô^“‹ß*J³åyJê»‘.¬RÌÆ+˜€±7“T
pqôşj_¯ıŸ[BÓ˜ùI©|È-J$—¯pÍã;ºöÕûå1!o”ªMbµÑÌ´FÙş^šf„ZÎMÙx,áö¡ÂØØŞL1Í¬Ÿ†bï8E0Õp–s$tÄXbıaw±¨”–ºâòôØ(¼æŸÆ{‘{6²Œ; -Qv7²Hu¤[Ş¯›%ÁÀ;érÅ·çsV¹ltß‡ÜØöÓ»§z6nŞô?ÀtéğyñüaÆƒ)&’
tÎÑ»E€÷ù&‚@Bº¢tâ•F	J>51‡T-™É6 íEn;„Ó”F5«d¶à@ïÅS8äçcw}äŠ¶6¿¤TÚ¥Ù	8uû—ƒB¦Â˜˜7ã¯:igi¨;Ç¶c)®ğ2}yµÆÈª~ötA£9œVMp¹ †ÇCë«J¾_æ÷¹À=|1h2e§–»§3Ád~»Ík±qÀui9|ûº[_ÉÄÖËHëX£ßƒÀBE¿VVÿé6AôÚøÉ<·ÏdÏ¯R&›4û…¶ºç8¼÷-ü³ğb€öî}Ü±r"qµí;æ½ÅW“JÅB=çsY\ßÆÓ=Ü“ä•út{dˆ;îäU¿9g
±p¥è„¿5œ	«>#)Jµ:äd5Üaşd•¤}ÄoõfÄî5whÛø®#;İŞr=¯ge…ÎT®M¢’g¶ñz€Øé‹·ôçcöÛV–6n§Ôäüëã½ıñ‘m‰.İËÌÉÜv¸Q`@İ?ˆjzz^ÑDr*Õò­JíâÎ8ÈûDRS_İ í^qõÕÁ¶5Ş¦œÅPê)=l¼.—£+¹!WµırJb8û Ò[œDÔvŞZjeRÇ”4ãˆòB,Ü&ÃkeC†R“g(RÛwKÀ•ênw]°À“Ø¿øÊIsßşÌé†¢ÁËaë¶ºS|„ïg¼ü‘e‰ZôrCO±¸ûyî´S•â"@N÷õËjøVú@ŞXæõ²IÕÿl›Øº]Í¹sÎ	qVx* ª¹™Úc(˜ĞÃÇnl™óßsê¨Y…·Ïa2eÏèÖmXdcäô…MÔˆ-ÄÈs38V	EÛiiY_Äãõl†E,IaƒBıÃ¿a+&mu}Ê|˜šø«¶<hPßEÁ`³ípÇŠWÆ´3ö«
è#&zTFoù–6€^…ä¹")•¬Uİ¬‹§¹F_?š½´¤a–Í#y­¿ØxQé"ñê˜1÷BÌcşzğ(D[cÛ‘2vÿ#l½‹àñHjš_ˆtK	£'!bh£QÕól&zfTúPk]2F””»G¸„U…ÖİëîÇi¡‘æ&ÒÓ%3ŠÜ>êÍ6~OÔ
‰cG!O(PCÀõ­]€ÀÃ™U¥‰d[äšf¾(Å )p³°ù¡¿¿ŸlŸ£åæ›’6²nIˆ†Ô¢¥M÷ É‘DˆPzlŸ2<n*ÌÔ¢Üô?Ø²…öĞ­Ø~Ğµû$aÙ¨±¶\åAYlÓl>.Gd =*èä¶û­"·11›63ÂÜUÂ«oÕÀÇ	´jjgïŠ`¶XçrÃ3³Ã¨+İ`iø4Ìóx%ØšÑ]¸¦0sDgèG®*¨¹Ó5‰!)]ç'Èít%P®N—2yU=™ã0¡Ç®ÚŒ–¹b4ÿÛ -¨[z57y(Ç šD5}…ÿÃ˜"êÈ©GJ¯Âå ;àVì ‹„QsJí=x€w’$Ûxúh˜y%ÕÖ$¤î†_Î:]©îİÓyrÔz2º®‰uøí’FSHªBÚs”œ}„P­9àY!Q|ölÇy<gËgr.ï/ğRÙ¦ZŒ½^–›f¶’xéNÒSôØÊn™Ê/CÏ#ß©"Óö3~8^Ü˜­-ŸnÜŞÕD]æuÒVëOp)ãÑ~ü~)ñ G†óD.i´)NĞ*uÁ»;kø5Ï/à»jhQ‰æKYõİaÉ™:N%L‰ |Nq³d}#noä·É[…ó­f?°$o!>ñ|©a¯€Î2
Z>œH%ËÔØ;ÒrGºW†4¥Üè?Z~ì²¨ó°¨#BìQ&š,ê‡í'cğœÿt¶ò${üt<#ÇÅuôÃîk´ä«®í'òV…WŸè¹!dBûæã•nrÚ=²°ÑaHá®¦V–¬oT#!
|•<TÎ¿­‰r4õdœƒ6ÇÛ¾ñ³­cùˆÊGGÎİîÉZºL§mÜ°?ÎÙè"Ş'wÁ[•Ø·PçŒ^â»Yòw\~æævn;n}ÕÁ÷µD5Èß4İ´SºMAÂ˜U»ÔÀó§@¡Q9‰Ïlj&Q¯æ×°õN½bz%ñG)—Ö/ÛT*s:Ô>oUxBR¥µr
ìÉ7­&¸è>ï®R­¤ú_I[¯ (œ¨¸¡ª¶Ôms×¾??½wÕøÌì(fæ‡7‹r#˜MÌeÂŞA“t; åŒ+ «ªíÌqGù|A8g\¸µœøÊy°‹N•Ç¦Ò°ÎKàlˆéî­Â	o5¼–ß=ë€Ruúöl\]İ©oˆå2jƒKõ=9÷øBHJXy ú/Gu‰¡uÂÄ.Èİ±e„uHù[ÑqàæEUAXJ¶É	Ë.Ó‡{¨uÏKüaˆ¸ã>ot¥ 2ï€&©!skõkˆªÑ#<ÃÌ6Ê”'›õ~Do¾.¶Ö™–)AêğV^ÍCb­ir×Qõ*T¬,S¦—ø¶«Ï`\^{Ğ|ì+Êc‰¨PÈŠp7WP
‹jHûåˆ1J[¹´Œ¥é*:x¶<J{pjÿ³MG¹„~àÓU8€Ïš'·/¡¬Hmu†a.1ÑBÄuJ_,¬Ït{¸	à¯Úz}-ñÑŞ7@™=Gp|S=¿¯ÅÀ'ø2Ä¦ ütğd¡L/'€MÅ|ç•’İ„Ï9›ÿ’uú~:g&"ÎSİĞsê“Û¹IÇkZ»WWĞ“àùå?²+ ã±Q¶ßÄ}HÎ’ZEC„!1ˆâ@€šI”$YºZ•`?Ş°ñV«şYÃ|±kq6›"¥jİò.°™ËÓ†_7É –ãçm¿"Y¬LšL‰FgòexâühGJ:èQ’ß]İXÑTÊğw¨x0IG|Í5ú[¦(†ñŸ¶5üDà'ÁCê—Â^>ˆjÉá¾Å(ºÆé9qÚ<E;gö°<!›%".byxsº–¦Q Ş7öOìk¾Ùø•Ztuôü"µ(n*Í¾w]:”qñƒ¬CnÂâÊjŸt!á¥m°zUb‘(ÜÁ.=NÓ>£ÄÓ. ·ç50?0elÆ{ğM1¸V]hzKÙFW;y%Éø‡Æ09QÁ[&ûBÜM«x8t(¢µ"Oo†Ã}È1„|±1?F'ÈĞ©a¤F³ <T Øi3K‡h!î;1‡‰AÂ&Ë)üıfB+ìwÁ¯èbäŠZı4ŠISQ„‘°µ„ã=ÂÊÀqäc4áYˆÑ@º,Ã§á°z‰tÊåŞáã¾}™gÉÜ×S5”Æh'^Dç¥şÂ;i”ëV`×’fóäˆ#2çÑ,íŸ=PœÌ?bëLô‘ ë7n~CëÏyVZ5xÆ/D´4ØæmC¤ıIšô5£,èş}V³¥p,µC“E.T_ìçÀÓ9ØUóÈÛ^öÖ·–YE7)Y1ü6Ñƒ	£Ü
Ô Çè®2på‡²ÈÌ õ„*õ”éã1”ws±î
 äÍ~[OÊuÊ¹_4Ğòö&6€%„8P°ù;÷Ne2k± HŸ´&ÉUgÚüÁUçúÛÏ×uL"‘9F‚Ü`”PqÂ~Aÿ°¹[Ñ¡’†ftÄİV6Ä:ª±ŞvkäaöH„ÓJ«cTë¹ÈÏ&½Ù„Â€†tYø3”ŒŒŸëàlg†Tòd°b ‡¥5] „Ãëú(©Jİ÷€€¼µuv0ì­æjb¬Ì*%R®’˜©¦ú-°ŸûĞ«HòšrËrGY¨ ƒ[:ùîÑø££í®¡HÅ_–Kˆ/Pqö¥´ læÅ1±4O:”mÓÃŸs¼V!ä|†C­÷¢ƒó©{[HhàŞrï©şA¹?K(•*O8ä¨Ë¨÷ÏÊ#’¶âjıø\71îòÿeœah¤„LÄ…£Ñ—Öç%¿‹fm0Æ"×Õ-ùIÆĞÓÚÈ"¯QÜ‡gG T×›¢ 2\…í!R?*—<¼:âÚ‡rÍc›±ÕŞîy—»@U %†şxµI¿QñulÑhM$ô2UîÃeÜc ìL ˆæL,{¹İ4ÖC#Œò7AmF9Â^ÕÈ8R+Å©Dİ’Z›RP@¾yF¼bÁ[oUW·…)t+Æ=X3ã×-68Œf³¯İVV¹DeU\¸æİZ#®ÛL °%½Jºß=g¨äÓµñ•RÃÓY‰OIÇ§º%aÆ¾¶¤Ù|(¯ñ\Ÿ®Ù{^»ÌvÇ´%—QÚ5=º¯Zÿ3Àò‰9‘†¢›÷Ù	ëª —VZ¾Y¹R®ò—;J<BÜ@Wæ)­ÚQ£š¿ŞÛş|´ß l¼Ñ¨h©1L 6fMcñúa7MÅn@‚Æ2§l¬	Ã–Çz
ltÎ¨ÈÕULİ+ &èò'Ãænø€=¸¼·K
Ï¬~Q0ÁĞúÙ?L]Ò‰”…¹’¥Ñ™›Ì\ajÆDÎ¾§lµÉµ»`Âd{=îíkiüêşA4owc§œãÍT³ÊÓ¨à™F#‰¦&ª“¢«µéw45dsÏ©ÕO´Ò‚°±“<vZ@%ƒ5˜V\YßÙÜ‰ş¡ ­÷gïû-íŸÍI×p¨Ìñr=æœ¨E}Î«cÅj3Ee,!°Rëø71çÒ¬N˜-Â„Ğïd>Ù_|¬SRfry0pØPz]®m+Ú­bÆÒ&3R¡&Pã¾—G"Ç%›”¼!CyyNQMÙé›cçè
6¼æu—óÛö ¸„`IÎUüt±Î&~áÛF•oê4gWÜvî²q,XE±W¶9AùZşšá¼ïÃ¾)È2®p€½+±(O×LÀ)p—Öu†zzÔÃ€ËÙ‘iÀ¶ğçÖÙ¾³~™!g3ÁõÏ
¢Öv7… Ë)‚;	¼›êŞ˜ÿÅÑl8!âÈ2à‹Şù{_{ß>„ã”Ù¡Óƒ¬–İE†å7@|üç'°P>[5]öéÌµ‘±T!Ñª!£zÖ”Çåh“øÎÈ6&·ÈmŒªa™ö#[ÂªT}jˆHûWşúÎFÄ#$‹È0dŠ‹ÄµØÊàSAyg%/EÆ ­[-Ò\¢ıPaŞ3¨öãÔÊúy–ÂÈ;6mjÕ¯İoœÁ‰Ï@0­œµt¹ï2›=Z>ÊÑP0éa6Ÿ«à‰	E·€î$ï íts,À±‚x?9@ÿİ›Z{îÙ_£2¡õÊ±Šaş?T]‚Ú=0Dz^ œÂ'8Á'ÔxÅydA¦ê6}€Ô>ƒ–TŒšõ¶]5rõWßé<¤¼U«GHúÜ†~Œ$ç«r°´Ûh
Æ9nÃ×Ñ¢_\®É/eçÄ7£2`±X.†y¼#@Db>öfñ®‘r^Cœ(ñ+PLiGwôïöb\Ã%ıìòÚÅ›‘@ï”+*ŞÛ¨œˆñÂ>ø'<65xÏ	İ®Å¥ªäÇ?¾€Qñî0›è‡ucĞğC~¦İ€Zî~ãò[Hr—Í1Z
™lğö˜œIcqÛvTï/±|ü°ÿ;^‡R{½Œ€%^tkEØ
¸?Ø"'œ—0ÖWl»,mcé‹ÁÙ#²1BÌZ‰æŒTP	ï”6˜¹WŸıÚ*¾6Â~uşïÌ÷Üh.Ü`.œUù ÖébL
¬wNmâà›Ì/¸xq¤ÄËuíÌı¤Zâ³o¤ú×E”Ã›Y^Şç$Dò¥”¯²ôîI-ÆGúcc\ÔtCRL&±<vû—¤3ƒÓ|\¹ŸÉdÂ[À¿Õ,¼’tŠİ¼#W{}HÂˆÎ'ˆË)