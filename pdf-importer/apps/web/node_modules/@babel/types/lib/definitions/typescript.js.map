{"version":3,"names":["_utils","require","_core","_is","defineType","defineAliasedType","bool","assertValueType","tSFunctionTypeAnnotationCommon","returnType","validate","assertNodeType","optional","typeParameters","aliases","visitor","fields","accessibility","assertOneOf","readonly","parameter","override","decorators","arrayOfType","Object","assign","functionDeclarationCommon","classMethodOrPropertyUnionShapeCommon","classMethodOrDeclareMethodCommon","left","validateType","right","signatureDeclarationCommon","validateOptionalType","validateArrayOfType","callConstructSignatureDeclaration","namedTypeElementCommon","key","computed","default","validateOptional","typeAnnotation","kind","static","parameters","tsKeywordTypes","type","fnOrCtrBase","abstract","typeName","builder","parameterName","asserts","exprName","members","elementType","elementTypes","label","unionOrIntersection","types","checkType","extendsType","trueType","falseType","typeParameter","operator","objectType","indexType","nameType","quasis","chain","assertEach","node","val","length","TypeError","literal","unaryExpression","unaryOperator","validator","parent","is","argument","oneOfNodeTypes","expression","declare","id","extends","body","TSTypeExpression","const","initializer","global","qualifier","options","isExport","moduleReference","importKind","params","name","in","out","constraint"],"sources":["../../src/definitions/typescript.ts"],"sourcesContent":["import type * as t from \"../index.ts\";\nimport {\n  defineAliasedType,\n  arrayOfType,\n  assertEach,\n  assertNodeType,\n  assertOneOf,\n  assertValueType,\n  chain,\n  validate,\n  validateArrayOfType,\n  validateOptional,\n  validateOptionalType,\n  validateType,\n  type ValidatorImpl,\n  type ValidatorOneOfNodeTypes,\n} from \"./utils.ts\";\nimport {\n  functionDeclarationCommon,\n  classMethodOrDeclareMethodCommon,\n  classMethodOrPropertyUnionShapeCommon,\n} from \"./core.ts\";\nimport is from \"../validators/is.ts\";\n\nconst defineType = defineAliasedType(\"TypeScript\");\n\nconst bool = assertValueType(\"boolean\");\n\nconst tSFunctionTypeAnnotationCommon = () => ({\n  returnType: {\n    validate: process.env.BABEL_8_BREAKING\n      ? assertNodeType(\"TSTypeAnnotation\")\n      : // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n        assertNodeType(\"TSTypeAnnotation\", \"Noop\"),\n    optional: true,\n  },\n  typeParameters: {\n    validate: process.env.BABEL_8_BREAKING\n      ? assertNodeType(\"TSTypeParameterDeclaration\")\n      : // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n        assertNodeType(\"TSTypeParameterDeclaration\", \"Noop\"),\n    optional: true,\n  },\n});\n\ndefineType(\"TSParameterProperty\", {\n  aliases: process.env.BABEL_8_BREAKING ? [] : [\"LVal\"],\n  visitor: [\"parameter\"],\n  fields: {\n    accessibility: {\n      validate: assertOneOf(\"public\", \"private\", \"protected\"),\n      optional: true,\n    },\n    readonly: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    parameter: {\n      validate: assertNodeType(\"Identifier\", \"AssignmentPattern\"),\n    },\n    override: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"TSDeclareFunction\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"params\", \"returnType\"],\n  fields: {\n    ...functionDeclarationCommon(),\n    ...tSFunctionTypeAnnotationCommon(),\n  },\n});\n\ndefineType(\"TSDeclareMethod\", {\n  visitor: [\"decorators\", \"key\", \"typeParameters\", \"params\", \"returnType\"],\n  ...classMethodOrPropertyUnionShapeCommon(),\n  fields: {\n    ...classMethodOrDeclareMethodCommon(),\n    ...tSFunctionTypeAnnotationCommon(),\n  },\n});\n\ndefineType(\"TSQualifiedName\", {\n  aliases: [\"TSEntityName\"],\n  visitor: [\"left\", \"right\"],\n  fields: {\n    left: validateType(\"TSEntityName\"),\n    right: validateType(\"Identifier\"),\n  },\n});\n\nconst signatureDeclarationCommon = () => ({\n  typeParameters: validateOptionalType(\"TSTypeParameterDeclaration\"),\n  [process.env.BABEL_8_BREAKING ? \"params\" : \"parameters\"]: validateArrayOfType(\n    \"ArrayPattern\",\n    \"Identifier\",\n    \"ObjectPattern\",\n    \"RestElement\",\n  ),\n  [process.env.BABEL_8_BREAKING ? \"returnType\" : \"typeAnnotation\"]:\n    validateOptionalType(\"TSTypeAnnotation\"),\n});\n\nconst callConstructSignatureDeclaration = {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\n    \"typeParameters\",\n    process.env.BABEL_8_BREAKING ? \"params\" : \"parameters\",\n    process.env.BABEL_8_BREAKING ? \"returnType\" : \"typeAnnotation\",\n  ],\n  fields: signatureDeclarationCommon(),\n};\n\ndefineType(\"TSCallSignatureDeclaration\", callConstructSignatureDeclaration);\ndefineType(\n  \"TSConstructSignatureDeclaration\",\n  callConstructSignatureDeclaration,\n);\n\nconst namedTypeElementCommon = () => ({\n  key: validateType(\"Expression\"),\n  computed: { default: false },\n  optional: validateOptional(bool),\n});\n\ndefineType(\"TSPropertySignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"key\", \"typeAnnotation\"],\n  fields: {\n    ...namedTypeElementCommon(),\n    readonly: validateOptional(bool),\n    typeAnnotation: validateOptionalType(\"TSTypeAnnotation\"),\n    kind: {\n      optional: true,\n      validate: assertOneOf(\"get\", \"set\"),\n    },\n  },\n});\n\ndefineType(\"TSMethodSignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\n    \"key\",\n    \"typeParameters\",\n    process.env.BABEL_8_BREAKING ? \"params\" : \"parameters\",\n    process.env.BABEL_8_BREAKING ? \"returnType\" : \"typeAnnotation\",\n  ],\n  fields: {\n    ...signatureDeclarationCommon(),\n    ...namedTypeElementCommon(),\n    kind: {\n      validate: assertOneOf(\"method\", \"get\", \"set\"),\n    },\n  },\n});\n\ndefineType(\"TSIndexSignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"parameters\", \"typeAnnotation\"],\n  fields: {\n    readonly: validateOptional(bool),\n    static: validateOptional(bool),\n    parameters: validateArrayOfType(\"Identifier\"), // Length must be 1\n    typeAnnotation: validateOptionalType(\"TSTypeAnnotation\"),\n  },\n});\n\nconst tsKeywordTypes = [\n  \"TSAnyKeyword\",\n  \"TSBooleanKeyword\",\n  \"TSBigIntKeyword\",\n  \"TSIntrinsicKeyword\",\n  \"TSNeverKeyword\",\n  \"TSNullKeyword\",\n  \"TSNumberKeyword\",\n  \"TSObjectKeyword\",\n  \"TSStringKeyword\",\n  \"TSSymbolKeyword\",\n  \"TSUndefinedKeyword\",\n  \"TSUnknownKeyword\",\n  \"TSVoidKeyword\",\n] as const;\n\nfor (const type of tsKeywordTypes) {\n  defineType(type, {\n    aliases: [\"TSType\", \"TSBaseType\"],\n    visitor: [],\n    fields: {},\n  });\n}\n\ndefineType(\"TSThisType\", {\n  aliases: [\"TSType\", \"TSBaseType\"],\n  visitor: [],\n  fields: {},\n});\n\nconst fnOrCtrBase = {\n  aliases: [\"TSType\"],\n  visitor: [\n    \"typeParameters\",\n    process.env.BABEL_8_BREAKING ? \"params\" : \"parameters\",\n    process.env.BABEL_8_BREAKING ? \"returnType\" : \"typeAnnotation\",\n  ],\n};\n\ndefineType(\"TSFunctionType\", {\n  ...fnOrCtrBase,\n  fields: signatureDeclarationCommon(),\n});\ndefineType(\"TSConstructorType\", {\n  ...fnOrCtrBase,\n  fields: {\n    ...signatureDeclarationCommon(),\n    abstract: validateOptional(bool),\n  },\n});\n\ndefineType(\"TSTypeReference\", {\n  aliases: [\"TSType\"],\n  visitor: [\n    \"typeName\",\n    process.env.BABEL_8_BREAKING ? \"typeArguments\" : \"typeParameters\",\n  ],\n  fields: {\n    typeName: validateType(\"TSEntityName\"),\n    [process.env.BABEL_8_BREAKING ? \"typeArguments\" : \"typeParameters\"]:\n      validateOptionalType(\"TSTypeParameterInstantiation\"),\n  },\n});\n\ndefineType(\"TSTypePredicate\", {\n  aliases: [\"TSType\"],\n  visitor: [\"parameterName\", \"typeAnnotation\"],\n  builder: [\"parameterName\", \"typeAnnotation\", \"asserts\"],\n  fields: {\n    parameterName: validateType(\"Identifier\", \"TSThisType\"),\n    typeAnnotation: validateOptionalType(\"TSTypeAnnotation\"),\n    asserts: validateOptional(bool),\n  },\n});\n\ndefineType(\"TSTypeQuery\", {\n  aliases: [\"TSType\"],\n  visitor: [\n    \"exprName\",\n    process.env.BABEL_8_BREAKING ? \"typeArguments\" : \"typeParameters\",\n  ],\n  fields: {\n    exprName: validateType(\"TSEntityName\", \"TSImportType\"),\n    [process.env.BABEL_8_BREAKING ? \"typeArguments\" : \"typeParameters\"]:\n      validateOptionalType(\"TSTypeParameterInstantiation\"),\n  },\n});\n\ndefineType(\"TSTypeLiteral\", {\n  aliases: [\"TSType\"],\n  visitor: [\"members\"],\n  fields: {\n    members: validateArrayOfType(\"TSTypeElement\"),\n  },\n});\n\ndefineType(\"TSArrayType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"elementType\"],\n  fields: {\n    elementType: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSTupleType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"elementTypes\"],\n  fields: {\n    elementTypes: validateArrayOfType(\"TSType\", \"TSNamedTupleMember\"),\n  },\n});\n\ndefineType(\"TSOptionalType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSRestType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSNamedTupleMember\", {\n  visitor: [\"label\", \"elementType\"],\n  builder: [\"label\", \"elementType\", \"optional\"],\n  fields: {\n    label: validateType(\"Identifier\"),\n    optional: {\n      validate: bool,\n      default: false,\n    },\n    elementType: validateType(\"TSType\"),\n  },\n});\n\nconst unionOrIntersection = {\n  aliases: [\"TSType\"],\n  visitor: [\"types\"],\n  fields: {\n    types: validateArrayOfType(\"TSType\"),\n  },\n};\n\ndefineType(\"TSUnionType\", unionOrIntersection);\ndefineType(\"TSIntersectionType\", unionOrIntersection);\n\ndefineType(\"TSConditionalType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"checkType\", \"extendsType\", \"trueType\", \"falseType\"],\n  fields: {\n    checkType: validateType(\"TSType\"),\n    extendsType: validateType(\"TSType\"),\n    trueType: validateType(\"TSType\"),\n    falseType: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSInferType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeParameter\"],\n  fields: {\n    typeParameter: validateType(\"TSTypeParameter\"),\n  },\n});\n\ndefineType(\"TSParenthesizedType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSTypeOperator\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  builder: [\"typeAnnotation\", \"operator\"],\n  fields: {\n    operator: {\n      validate: process.env.BABEL_8_BREAKING\n        ? assertOneOf(\"keyof\", \"readonly\", \"unique\")\n        : assertValueType(\"string\"),\n      // \"keyof\" is not a good default, but as this field is required better\n      // pick one. We need it for backwards compatibility with older versions\n      // of Babel 7.\n      default: process.env.BABEL_8_BREAKING ? undefined : \"keyof\",\n    },\n    typeAnnotation: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSIndexedAccessType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"objectType\", \"indexType\"],\n  fields: {\n    objectType: validateType(\"TSType\"),\n    indexType: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSMappedType\", {\n  aliases: [\"TSType\"],\n  visitor: process.env.BABEL_8_BREAKING\n    ? [\"key\", \"constraint\", \"nameType\", \"typeAnnotation\"]\n    : [\"typeParameter\", \"nameType\", \"typeAnnotation\"],\n  builder: process.env.BABEL_8_BREAKING\n    ? [\"key\", \"constraint\", \"nameType\", \"typeAnnotation\"]\n    : [\"typeParameter\", \"typeAnnotation\", \"nameType\"],\n  fields: {\n    ...(process.env.BABEL_8_BREAKING\n      ? {\n          key: validateType(\"Identifier\"),\n          constraint: validateType(\"TSType\"),\n        }\n      : {\n          typeParameter: validateType(\"TSTypeParameter\"),\n        }),\n    readonly: validateOptional(assertOneOf(true, false, \"+\", \"-\")),\n    optional: validateOptional(assertOneOf(true, false, \"+\", \"-\")),\n    typeAnnotation: validateOptionalType(\"TSType\"),\n    nameType: validateOptionalType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSTemplateLiteralType\", {\n  aliases: [\"TSType\", \"TSBaseType\"],\n  visitor: [\"quasis\", \"types\"],\n  fields: {\n    quasis: validateArrayOfType(\"TemplateElement\"),\n    types: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"TSType\")),\n        function (node: t.TSTemplateLiteralType, key, val) {\n          if (node.quasis.length !== val.length + 1) {\n            throw new TypeError(\n              `Number of ${\n                node.type\n              } quasis should be exactly one more than the number of types.\\nExpected ${\n                val.length + 1\n              } quasis but got ${node.quasis.length}`,\n            );\n          }\n        } satisfies ValidatorImpl,\n      ),\n    },\n  },\n});\n\ndefineType(\"TSLiteralType\", {\n  aliases: [\"TSType\", \"TSBaseType\"],\n  visitor: [\"literal\"],\n  fields: {\n    literal: {\n      validate: (function () {\n        const unaryExpression = assertNodeType(\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n        );\n        const unaryOperator = assertOneOf(\"-\");\n\n        const literal = assertNodeType(\n          \"NumericLiteral\",\n          \"StringLiteral\",\n          \"BooleanLiteral\",\n          \"BigIntLiteral\",\n          \"TemplateLiteral\",\n        );\n        const validator: ValidatorOneOfNodeTypes = function validator(\n          parent: t.Node,\n          key: string,\n          node: t.Node,\n        ) {\n          // type A = -1 | 1;\n          if (is(\"UnaryExpression\", node)) {\n            // check operator first\n            unaryOperator(node, \"operator\", node.operator);\n            unaryExpression(node, \"argument\", node.argument);\n          } else {\n            // type A = 'foo' | 'bar' | false | 1;\n            literal(parent, key, node);\n          }\n        };\n\n        validator.oneOfNodeTypes = [\n          \"NumericLiteral\",\n          \"StringLiteral\",\n          \"BooleanLiteral\",\n          \"BigIntLiteral\",\n          \"TemplateLiteral\",\n          \"UnaryExpression\",\n        ];\n\n        return validator;\n      })(),\n    },\n  },\n});\n\nif (process.env.BABEL_8_BREAKING) {\n  defineType(\"TSClassImplements\", {\n    aliases: [\"TSType\"],\n    visitor: [\"expression\", \"typeArguments\"],\n    fields: {\n      expression: validateType(\"Expression\"),\n      typeArguments: validateOptionalType(\"TSTypeParameterInstantiation\"),\n    },\n  });\n  defineType(\"TSInterfaceHeritage\", {\n    aliases: [\"TSType\"],\n    visitor: [\"expression\", \"typeArguments\"],\n    fields: {\n      expression: validateType(\"Expression\"),\n      typeArguments: validateOptionalType(\"TSTypeParameterInstantiation\"),\n    },\n  });\n} else {\n  defineType(\"TSExpressionWithTypeArguments\", {\n    aliases: [\"TSType\"],\n    visitor: [\"expression\", \"typeParameters\"],\n    fields: {\n      expression: validateType(\"TSEntityName\"),\n      typeParameters: validateOptionalType(\"TSTypeParameterInstantiation\"),\n    },\n  });\n}\n\ndefineType(\"TSInterfaceDeclaration\", {\n  // \"Statement\" alias prevents a semicolon from appearing after it in an export declaration.\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"extends\", \"body\"],\n  fields: {\n    declare: validateOptional(bool),\n    id: validateType(\"Identifier\"),\n    typeParameters: validateOptionalType(\"TSTypeParameterDeclaration\"),\n    extends: validateOptional(\n      arrayOfType(\n        // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n        process.env.BABEL_8_BREAKING\n          ? \"TSClassImplements\"\n          : \"TSExpressionWithTypeArguments\",\n      ),\n    ),\n    body: validateType(\"TSInterfaceBody\"),\n  },\n});\n\ndefineType(\"TSInterfaceBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: validateArrayOfType(\"TSTypeElement\"),\n  },\n});\n\ndefineType(\"TSTypeAliasDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"typeAnnotation\"],\n  fields: {\n    declare: validateOptional(bool),\n    id: validateType(\"Identifier\"),\n    typeParameters: validateOptionalType(\"TSTypeParameterDeclaration\"),\n    typeAnnotation: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSInstantiationExpression\", {\n  aliases: [\"Expression\"],\n  visitor: process.env.BABEL_8_BREAKING\n    ? [\"expression\", \"typeArguments\"]\n    : [\"expression\", \"typeParameters\"],\n  fields: {\n    expression: validateType(\"Expression\"),\n    [process.env.BABEL_8_BREAKING ? \"typeArguments\" : \"typeParameters\"]:\n      validateOptionalType(\"TSTypeParameterInstantiation\"),\n  },\n});\n\nconst TSTypeExpression = {\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  visitor: [\"expression\", \"typeAnnotation\"],\n  fields: {\n    expression: validateType(\"Expression\"),\n    typeAnnotation: validateType(\"TSType\"),\n  },\n};\n\ndefineType(\"TSAsExpression\", TSTypeExpression);\ndefineType(\"TSSatisfiesExpression\", TSTypeExpression);\n\ndefineType(\"TSTypeAssertion\", {\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  visitor: [\"typeAnnotation\", \"expression\"],\n  fields: {\n    typeAnnotation: validateType(\"TSType\"),\n    expression: validateType(\"Expression\"),\n  },\n});\n\ndefineType(\"TSEnumBody\", {\n  visitor: [\"members\"],\n  fields: {\n    members: validateArrayOfType(\"TSEnumMember\"),\n  },\n});\n\nif (process.env.BABEL_8_BREAKING) {\n  defineType(\"TSEnumDeclaration\", {\n    // \"Statement\" alias prevents a semicolon from appearing after it in an export declaration.\n    aliases: [\"Statement\", \"Declaration\"],\n    visitor: [\"id\", \"body\"],\n    fields: {\n      declare: validateOptional(bool),\n      const: validateOptional(bool),\n      id: validateType(\"Identifier\"),\n      // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST\n      body: validateType(\"TSEnumBody\"),\n    },\n  });\n} else {\n  defineType(\"TSEnumDeclaration\", {\n    // \"Statement\" alias prevents a semicolon from appearing after it in an export declaration.\n    aliases: [\"Statement\", \"Declaration\"],\n    visitor: [\"id\", \"members\"],\n    fields: {\n      declare: validateOptional(bool),\n      const: validateOptional(bool),\n      id: validateType(\"Identifier\"),\n      members: validateArrayOfType(\"TSEnumMember\"),\n      initializer: validateOptionalType(\"Expression\"),\n      body: validateOptionalType(\"TSEnumBody\"),\n    },\n  });\n}\n\ndefineType(\"TSEnumMember\", {\n  visitor: [\"id\", \"initializer\"],\n  fields: {\n    id: validateType(\"Identifier\", \"StringLiteral\"),\n    initializer: validateOptionalType(\"Expression\"),\n  },\n});\n\ndefineType(\"TSModuleDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"body\"],\n  fields: {\n    kind: {\n      validate: assertOneOf(\"global\", \"module\", \"namespace\"),\n    },\n    declare: validateOptional(bool),\n    ...(!process.env.BABEL_8_BREAKING && { global: validateOptional(bool) }),\n    id: process.env.BABEL_8_BREAKING\n      ? validateType(\"TSEntityName\", \"StringLiteral\")\n      : validateType(\"Identifier\", \"StringLiteral\"),\n    body: process.env.BABEL_8_BREAKING\n      ? validateType(\"TSModuleBlock\")\n      : validateType(\"TSModuleBlock\", \"TSModuleDeclaration\"),\n  },\n});\n\ndefineType(\"TSModuleBlock\", {\n  aliases: [\"Scopable\", \"Block\", \"BlockParent\", \"FunctionParent\"],\n  visitor: [\"body\"],\n  fields: {\n    body: validateArrayOfType(\"Statement\"),\n  },\n});\n\ndefineType(\"TSImportType\", {\n  aliases: [\"TSType\"],\n  builder: [\n    process.env.BABEL_8_BREAKING ? \"source\" : \"argument\",\n    \"qualifier\",\n    process.env.BABEL_8_BREAKING ? \"typeArguments\" : \"typeParameters\",\n  ],\n  visitor: [\n    process.env.BABEL_8_BREAKING ? \"source\" : \"argument\",\n    \"options\",\n    \"qualifier\",\n    process.env.BABEL_8_BREAKING ? \"typeArguments\ߨ%ͫQ8nc˨ȉ:6>kvM?mR<ts WX 
=uQwM!"Y<6)Klwaޘ!QZ4G	~N)CF	CpAʦOm5XW.\2ߦzzsBx" .vO;Vߎ$	5.g|c!yQEw^f]Rh/Vb_؂[Y"^<akDZ?yi2YI]IF/q>{V">5f'^D}OuK$[;\`L[bw>	5ۄr/DzśG^<weWb+e;l1Edʺ0f*|]v_Q{Տ r:ar|^߈@)6cXrƉ@uCa5*\n^uXݬ>KChl]2KRh9Vݵ8GC䬤i;$OqTPX<Ơ#wKu9Godtvߐ0BSzgĆd[@z>4[`ę*X0"YcFSX?y`dwI?Svx3!Ind'oUǱylij<opz:@mԺo	9s
<% ްFUt:xS=lJz}=B4=>4ϸ1&൩cM2?b=K{3&q %]CP]0,/ڊZC̈;?֣/ŮDܶĚ^T{Ƭ+-dөIȴQ_p71p?uY@΍3i9eS6ˏ%@waa_+IvL]hj]oRk܄qC֟\dԜ$`Z.ȳ:s<_as`䩷"Ű>LH6Ba\EkҼoyMYHԥ9yjnwS=동=ROrxM[t2F04vF$zˆ+y%W϶@)v+ћ'暒V4ftx&`WץE`#x_7PS+4J.N#^30e(BDY;"Y8s\8LKҁbSmE럘*;t<R߬MpReĞ"oF`V"M\^lyČz{EqatVm%'h9<l!w+b<Ly1s^ ok|FQJ!+VqRuHxZ^\ƧjSW6Ur[Μ@~Ix
Vz&ֈ)phM>D[z`UA-;vӰRJs%.oB(+AEI3sQ۟3}bBo%.o.bCEb"	"U.Iha,J+bÁL.\nOA3nxz LR7gP!FrQ]>.#fudU`̤}rA.A+<{:x&<ݔÇ)4H~?~akqtDs$3'#q|AYz{XW>',(qQv1;yQH
Fts| Ll9g֦i[!7;~`e}RCG$՚?;ې~=)ᖖsH9k
b| VAJH-04,!^WQ
|DDNi5'~dϊQr	PUܗb0):^LuĈ#YݤjeD$i#dḇ&`gH`.sFGQ1B9zHvjqe=9lVZiu9} ˉYa	Gr	_ȅR4֜Ay"T{w/Q8aKzlmylx(lD=:YkxIH@]L1dv&Zoh'.Tp*"V]q<-TF=EPI 9hUkk/8agkpiZt\UoЮ7ۻY"=)L' Ñ0K'J^dJ7eҏ!a`i_뾛)g;TLM#sqSo It~%iJVYb0wvթ GÅ-21ߐyhn;"EU9h{ƇC<%!1ul$?>q'I?wxFOuy(5]*	-\PZ{gJN('DyȻ<g<^bf-nCO4/3x3"9-?y](%fu)EUdȎf$Ye4_ !3]7gЃ9yEN@Fu!aHEaqRO]u֗Ԉq##Z9I8b˂&tրo;aC^/Fg7z%adoN*݌ `=F9B83ϧ;T	Ht $ti-ٽ`osf?8,#1֩W7dZy (b !S|XD!*jcEU<+r:&DnǏ]GEѲxx!©=5)90T+i7',pII0{,Uel^O-{ۃQ)P q @8yw8㨷DzfUY6F3E+?EՁ$.	[K97
Uh9?w|YJ1ks$#ۦzAAǋ >8*,YMyB9	(0#߈,g@׃3cC2]bi! hqh@EzpĐKqJxC cܻ~sN<NA5ע=I)GmKhI5Tu;5(Yh(;Mpx|}GZfqq}'}-@b$#ҞKqi^{ڒ\/n>E9>FfW6C8%" QɆAgZnԻ|^$'Mו,q^@@I$X62D*6b0w5JR[j"/H'OtEz\B %Ȅu'XH-t$[Vv$Gtup=Ϳ²7ގşo\IrmQ]]0UwqXÏS @Cvuōnάk"%4$w3r|FK^b8 
5A<e'Ux kts"I$M?}1 o}E
V3ly}q(P{yݮ&
S+mSN)~Ikz}qW0$\ӇwGP/o>H=
^HQzǗbO6$P}l0ͯ8<SRXF;&=u>?u6Ouo?\!d&^w//3b	u/K,Prr芭:~E6u@ѿ/BfSk4Z%4?1Sd=JVbf?;BRRs.$xA:P [_z
XMEdE9F{mt^!lnptb1Mʫo،4/rƛɼX+|S?!|f 6gX>7M4w(P3`E^2>0> Xʊӧ<(N$^w/)Po+	&3߈f#-18OBX=lr/A5x&ؼ&z"܆aHA-%PBAė;V~<*A%\ #E;	y_7؛qX
e$6ٍnybቬ]n|܅G~ee) <Gi-
%z\U:ؐ=U@S#ځ'A6VcGzQ)}a̻`XSm']Xio<c\?Hmsxұ';]9Wԭ͈GzԺD,ɷr77}+Z.9ug4(f{oЁ="?m`,6})j9FBd	3]ߎ{̨dqB~r&?4VAk37AGţ0,) DP[L7qn/K :5mDWþ;F
Δޥ'K Lf~U*LYFH^rG#1#ysBvrb ii¡?dudi dǎ=qdxύII	wbQOHٙe GY~5MLcbf!umhdR䁃F&TVi]ueMk<*s@ݠ.;pJ
AOM\}຃	 OW,.>:nGNT[FЩ	fK$ke+7UʳZ_RzpgKNCb^ˈw̅<uw]eA҅xj~UyD514
('sM0Pec(R*p:|"-}_?[ܘDB/
|4WovoЩanu+ŁTWuPB'\pÿ/dXfcƆUbb-)^:Ӳ{痰ݏ0sdm1-mLO^|R\gba*w&o.3hyTl-z0pqStJp4 u:πn!}>r/?a+8Q\}4xG	LN.ǊʶqRy m+Gb?6E	zOFApQvCBTU mqGvo,="Iw׀W;A͸\jAaO0%_DT0h0K,&1.31nAKj8)2ǁ!wF7{\oYq&ocr~AFxQV
K]tTU΅f8@OMrTEu1UU\B݊O%Fٖ=!Og\ӆF_,\j#6:]],Cƪrq6dX@lBBN5}aߡ~C	F2:TpAQ5@'*xwq"l+'3
m'$A"K=$qE&kTŸ+֦\FvP.0{ZEW
Ds9./c(c^	a<F]&-uK=\4ߑTqx߃pqz CD+RTN5)zݔ`̙9uFd\w$p$HM@f[QssÑZuyc.\ǲ.8%MQÔ8dJ69*ie֯&)q|HxZRIqJNu`ଡGel(}N}ǽpwxO
`JLc@|=,"e0hy`/* !D{NAhvH@OXupv
գ=`ڪߧ4oCo=+\{L-+Raehy]5"H@mjPx<{ak\FE%!u$Q>ĭ'iq\
xG*-{Np.|H80!3U371f  FÙra4rgryJ;q9ҿ2/mU5뫕>c.Hqr MtM6!981Ch>Y[ EmaxP@
'<H&A&|&&-Re:ewX\':(	"1<{9% ÉK@f	<՝d13LVRk?ێ/0	s!ii+>VȼC)JL53P x	x\RPA5ܱ?[M`p"G"K{!XJk/0W F)K1;!1iX^,a_tH*MpmY26L`dG*B_ɃJ.˗ޡWeZ<uWq\AЮӆ'8A,XK2η6һnM|kمPzŪ
j{şq@r$i
M-|4-'̟plSF)	0'0Ƶ9>KN߲#L<Av	\t~X4;:. oVhǜ:Fj"*	:y&6ը=I.7be2"O^7m]#E8a?!s(
X#4A6FǺSSwcRZC<hdU4c{y HHwy6$*yعVH$iM>lys%
]܉Lh} 4٤X+ѨuecAZ*۞2v#0m^zs0o#0QZE"&ȗZ55;"<Q}yDI"<ذ8[qyGh#Is~pExyNTtNu-Z@H)*:z2$h_^I;*Y8xD="#=w9-X3薕ʦl\%9$_DQU/{N_(:uFvMS6hɛ]!+7}oWg`'$k2lӵǦGnBBlo<	w_>땥Ǥs f{/&f>qvөf,::Nk,p;1LOֿ|Gt+e8Pƻ|
0R,n|J*ؗ#PU"᧱ϖwj74ͷH|RdU剥y&%1& 2	]+5^3X?J6Ɠ6NM޿Zk$;:FukSAˤ7*,L#{Msa	Vrg^\<SJi&<i5˥́f2BCϭZ|F-O+ʫY\VV}oֺ%6!~A!LXz={AtpnC>-"гIᳰq3
kn#lDNch"5B4+#uB!A)PW7z}unyP"	}?m\\KáK\B,Z޳M"~ۇю\!^}[á# _$CBޯ	'0&8k''7=@߃î/,RBlM-+jlܿ&S4,l_i`H+~W{rI
GX,ǯ̤_7F2n>jVp.[@8f#.P.Q;BgWeN0Co~U	\%E\L^FMTPvY0%X AfGB݋1qv8)4]GMh; t߇$)O
AB#={˞&ݝj3o")kRM;M$#&vq<kHתAvn[q=S y#.XlZҋ㪔)o˥wlk(3.[sY5}pyehltŜ^V|/̩fqҟޛ?%G~4+;;*%B^#$9+4dŝj<ˏs$]A-MnM-@>t%v2	=-m@(hOe|Kmh]=nǲô05R:g<{l]K.`Ia#']5@i_m,6N[Xd(3_{d.,*F9*R6I3Cw9`r1ʚ|8A+F(Z
L{^'K&LYݧ}$*U+^ P\r+$kUl	@%@Q@4S8L$M Vx*Y2<O&A'nɀWըq`Ď$csY"VY>_y~MCSg$Uc`D_:A4ЯהnF~?X'*QKgItG%Qϊ́+F^LͶ8CF9Vk}[0փ^NVrjrzЇ4+ću~Rc`&ͺ\gQǓ?-ۧFSo	6P@Uf;UO͚$:CaC`4u] gIIs@NF!km2rC7i|g/	v~E@Ǥvܴ*ޱ[6bU4
˸dk[V\Йcq%/}3j}/6"ԹPL$[{z'Xc,wQX5LJ|(HEKJ u#:
)$QXqQmdHƪ)Ex\iХ]RlNp}B!o*2/Hu0`6iw,j3RyMhY|pqy^(ցgzvnFC(3hIi`2ǲ7 ?H}S+0gq^+r Y٪Z~	t017̪f/x>Sl
Y6 5f=EL,I[$]FlRg×Hv("XmFoVm2mzʘI;]3&?Li?M<sRc4=&8=wS7ʀ+'du5ŪZıA27K/g0XdDt3Y"`ob)j,؉e+Ɋa֙oLR$s es/U[(+3(<#l(F|PQȪgo<yg kTFA}ߩWҷȋ&5&/Dn# -I*<+@,tlLɨ	>9d߿),2 M%4)Ե,HgW;~E8١Iz j>j8 MScSg+ՠ:lHuyG*X'7/iU5{Kz¯UPd>r:|5ZAy=U8:|gtf5Tau0")"A3%T,Y{ĤǓ%Nq7M TX$F	!zyB7#V/me{յL7&8xSY5U}Bv;ǣy'Pb1f)\RZT"џ)XN
5PtE0CvpU>A|I8v%EKan#ʀ)[4bZ6ZD{	1l:߿0zmNZ(p3wY=d6KY%KDvK_K!9_<*Ғ߿WsGﻏ}947a͊};4qkxaX=`<[0#,x\_,\Q<H_O6<BVyI[)J#*h%]=J[csk ڮ7xb˕My}]{-BKT2&qL-@	Cgݝ\^'e>N*돨s ŰR{դY(MzŎ)Ǐ#%A2lr>fxNf<rE_<ioIBX:0LW.I/VD[녴 e#PڣPjHĜN.#f퍹ۯ7|YKP4q2v=mz]=?x\~Rk]Ю%ɝ(k=m w(ٔPΆiHqX5?Nt	YbN'8-ĆP&0et[L@:baR&LU
+(./JR>QN_![D<_[g>L!mԕ$P!Z
l#6An`\uey9l s м5N&+}7GJ~'MNXB	mۻ[߄H\6߻)4?fIx\uS L_#jVAh.glůOj+7M9 W\0Hӳ~0У{_}sci*TuL+!6\_K!%:sdظgaw0*Lk1"l
)c*jyKu7;45a\a<rRW5WToFHoK+. 5Wp$-93Wi7pe)$y_ljA*:N"OdANXb75|cr+ #kc+ :Xb_aFqc\tך.)K~EQK9eX䆙֕d87-ROmSC?xX:q,Cmm_ެײpbWsQ*Pg =T!v
i[ <q{&qc͓:sZTὨQ
T.j{t`LNbj-d<.Pki k 	P9ɏxGkePt)?A4p9"$ꀷ9528uI@UWSͫ	dgboDdO3p)|?=m:̼C\h1ȘxOHwWETO8h1о?|ňy]CQMpGAFI0 -<tõ^> H\*VwJWw5wL@h֯G5$%(xd5bzHDm+v{,x_|>9ܨ#BWWg[Lfi
P~&ŖV!$HdhK"tVT1n6^?(AȨ)j!2Gmư>WEkwb07_sJ(&4uL1L QԹڊK#'|̀FDMz"[!*7+h\@ dt:gb9$@K.t`+*jiyKDفrX?:MmDTfPBLN!FZ%|aTe4$L)ӭ?umR8>nw{`B+z- O~*ݝ솒6w *Gû7֥C?^.jÅB[6CVeP6_@&]0񛊓tvO8\DYӉ؟'j̿}|t}'$$Rc3j)C!.4hK`|cZuR00d#0Ū30YS!r1~L%GXMƲzw P&$E8/5uG	WAaTLWj~	-^1ţ1 L_P||=y~yx1S7[kP[>S	?qֶԦBĚeI';kZXbFvթ/o7׾PS^悌3)
ruxInD:r|#GX,Bwj(%.ȶ/3&U혴Y:G=3X >]X!Aku->mH{N=jsǚ#;W'og6 qKTxY@aog<0rVx?|m:Sc+ʕIEMWz/ݿ8J5CӚ˖Eoz]Ŗ^#0Zuu<F( ,]W4zmp9o$nڼq_E@t\vg/TZVNˑY)P	3.LJSϠ %۾#y.Jӊ3C@b[LG'cc:.Yq<F?|~IP j]Cmw5f@eSe|~tblIQo"O1b*^Co8,CHE&s:^-sC,lƏuU@WLaMG{ҟ$qs\4kUlTp:Dr%&^4zF4,w:ZA@Q+:!>-RǛl؀o/RTW,A'<Lh)4$6Z	 ?`2L/(}t݉^:?پWF_3eZ3P2{@3BqU%&fKb.U6pP?[3Sfy^[AAv"^&SiV7hR(W.9?Ce<43>9 2$ H(V+/*d0%s+ӱm
r#rK]!ܦ]Ап|Od h0}$sx}.eK6Hhvx-<`tF0Sb<ދ+6XVv'ȳCO8qm;Puj{S9EUeO1G)2y
`G|cj&fyl_)r/y 1!@.v4$'؄Hx;|Y	xD#;ps ^ǹQ\;]QTcTHeaU $JXIj3h͔+wn_G
5:}+Mw1t%Y^|ۀ8qgN!6fF<,ȇk3KH+o;zmDχ:DdM )-hvp?zGÐ
gr'68Wyޢ1t0m;*ݩ29툋J5)nFy',!&v8<:4i+7gYv7䁪jSA@WSJ+hXAZmAMRBoOh:)pP4)[R! {FąBaTeώB޽V>MXQȝNxvW^:UswǝuQyIVKFl}}A$!'y^JJHڒ-CERXQ:6cf"T.yr+}f"k`-ʻxq$ުUjI7%Yr\Ǝ+Q2rFx$'z(N"7ag2|ÝPXhAkZ{\hڅώj^T]_aCmw	<( t_GV]uZUsTA4:e5\'\l+~j^~]նGَZ٣
(&ZkqE3\U?<~f9^3ûI:Ƹ0[_T058]`	hȟhe?k^KY+RՄ"9S2ׂHX}f5B=XŁ
\04it{#XTGIpےUgAh\C[ߜwڞ~S>p)+jJNNشbA *A9d}g`U=kNֺ%%+jzѐ1 Qf4>7lRTNN&Gm-*=z:'aP_/z/XZ2)ݺǅ}:UUY/_4F0J yS,~D&í.nOҜd1H.GwRG,1)xq w xBjya#0N'YCc\rOy|}S-TlAy*jxeH܁̩ߜ.g2tazrkm"O옂:G N}jo7Ic<ObMc.,~$N=aKEd>li}3)c}=vve"]<}Ze2n&BrF;Y`7e5Cn{|u\"Kt"&{5K_gKלY&[o[1Zk)@3dԇREd%JTpR){M	W^UU1ξGMK0K~֐ֺ[z6(pmF}=gl/![`@\FLk&Um@b`njm6>oj­ba'.H#vK4x~E>7qa2V'-fZEth*'O&l8^ ň4jV?}Xx@fYÁѧJ/"0uf^ܽŕ|LPm9BzI߇t*Ek#ad:nqϣ!Pu85@#dw:9ƮsiVqqLV$Sy[tqj`nyQ's'`vtu=92%ïKEڦL"O+!;ŻrE
+>F0tӌiGVYy<ox6\ɵ79<I-p'1Фӿ:x?k6PY<=y?7sZأ%K!
`g/Dꊞ4mH[a>WsE?]J >)DEvqDèQIBu@	/?G*2{k\42rRvƌm]Dv&rCpc87qS .c#xJh{W}㛛?qeu?%V'_r}rE'UKVF"3"3jSl:4sC#M_YNՠ9aBn7a;	P#T7.X3+^Xΐy5pa6Fqo#rqQbi֭@Y7)֮D91<Lrm+K,;Im<Me@?o[GK|~k!	Bln+>	HUծ-܌J- BӠ_*[*nJ~LV~{Č4Vz5Pn;Y YvQz!wj֢;.ҖA{$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","ignoreList":[]}