{"version":3,"names":["_convertSourceMap","data","require","_generator","_mergeMap","generateCode","pluginPasses","file","opts","ast","code","inputMap","generatorOpts","inputSourceMap","toObject","results","plugins","plugin","generatorOverride","result","generate","undefined","push","length","then","Error","outputCode","decodedMap","outputMap","map","__mergedMap","Object","assign","mergeSourceMap","sourceFileName","sourceMaps","convertSourceMap","fromObject","toComment"],"sources":["../../../src/transformation/file/generate.ts"],"sourcesContent":["import type { PluginPasses } from \"../../config/index.ts\";\nimport convertSourceMap from \"convert-source-map\";\nimport type { GeneratorResult } from \"@babel/generator\";\nimport generate from \"@babel/generator\";\n\nimport type File from \"./file.ts\";\nimport mergeSourceMap from \"./merge-map.ts\";\n\nexport default function generateCode(\n  pluginPasses: PluginPasses,\n  file: File,\n): {\n  outputCode: string;\n  outputMap: GeneratorResult[\"map\"] | null;\n} {\n  const { opts, ast, code, inputMap } = file;\n  const { generatorOpts } = opts;\n\n  generatorOpts.inputSourceMap = inputMap?.toObject();\n\n  const results = [];\n  for (const plugins of pluginPasses) {\n    for (const plugin of plugins) {\n      const { generatorOverride } = plugin;\n      if (generatorOverride) {\n        const result = generatorOverride(ast, generatorOpts, code, generate);\n\n        if (result !== undefined) results.push(result);\n      }\n    }\n  }\n\n  let result;\n  if (results.length === 0) {\n    result = generate(ast, generatorOpts, code);\n  } else if (results.length === 1) {\n    result = results[0];\n\n    // @ts-expect-error check if generatorOverride returned a promise\n    if (typeof result.then === \"function\") {\n      throw new Error(\n        `You appear to be using an async codegen plugin, ` +\n          `which your current version of Babel does not support. ` +\n          `If you're using a published plugin, ` +\n          `you may need to upgrade your @babel/core version.`,\n      );\n    }\n  } else {\n    throw new Error(\"More than one plugin attempted to override codegen.\");\n  }\n\n  // Decoded maps are faster to merge, so we attempt to get use the decodedMap\n  // first. But to preserve backwards compat with older Generator, we'll fall\n  // back to the encoded map.\n  let { code: outputCode, decodedMap: outputMap = result.map } = result;\n\n  // @ts-expect-error For backwards compat.\n  if (result.__mergedMap) {\n    /**\n     * @see mergeSourceMap\n     */\n    outputMap = { ...result.map };\n  } else {\n    if (outputMap) {\n      if (inputMap) {\n        // mergeSourceMap returns an encoded map\n        outputMap = mergeSourceMap(\n          inputMap.toObject(),\n          outputMap,\n          generatorOpts.sourceFileName,\n        );\n      } else {\n        // We cannot output a decoded map, so retrieve the encoded form. Because\n        // the decoded form is free, it's fine to prioritize decoded first.\n        outputMap = result.map;\n      }\n    }\n  }\n\n  if (opts.sourceMaps === \"inline\" || opts.sourceMaps === \"both\") {\n    outputCode += \"\\n\" + convertSourceMap.fromObject(outputMap).toComment();\n  }\n\n  if (opts.sourceMaps === \"inline\") {\n    outputMap = null;\n  }\n\n  // @ts-expect-error outputMap must be an EncodedSourceMap or null\n  return { outputCode, outputMap };\n}\n"],"mappings":";;;;;;AACA,SAAAA,kBAAA;EAAA,MAAAC,IAAA,GAAAC,OAAA;EAAAF,iBAAA,YAAAA,CAAA;IAAA,OAAAC,IAAA;EAAA;EAAA,OAAAA,IAAA;AAAA;AAEA,SAAAE,WAAA;EAAA,MAAAF,IAAA,GAAAC,OAAA;EAAAC,UAAA,YAAAA,CAAA;IAAA,OAAAF,IAAA;EAAA;EAAA,OAAAA,IAAA;AAAA;AAGA,IAAAG,SAAA,GAAAF,OAAA;AAEe,SAASG,YAAYA,CAClCC,YAA0B,EAC1BC,IAAU,EAIV;EACA,MAAM;IAAEC,IAAI;IAAEC,GAAG;IAAEC,IAAI;IAAEC;EAAS,CAAC,GAAGJ,IAAI;EAC1C,MAAM;IAAEK;EAAc,CAAC,GAAGJ,IAAI;EAE9BI,aAAa,CAACC,cAAc,GAAGF,QAAQ,oBAARA,QAAQ,CAAEG,QAAQ,CAAC,CAAC;EAEnD,MAAMC,OAAO,GAAG,EAAE;EAClB,KAAK,MAAMC,OAAO,IAAIV,YAAY,EAAE;IAClC,KAAK,MAAMW,MAAM,IAAID,OAAO,EAAE;MAC5B,MAAM;QAAEE;MAAkB,CAAC,GAAGD,MAAM;MACpC,IAAIC,iBAAiB,EAAE;QACrB,MAAMC,MAAM,GAAVkzUWJuaFl3YzJKVkplNmxyNVM0RzdETHNMRkpGQ2lGUGtNKzNwNUgzSjRxc0VHVXlXbFNHaG9GR08KUW5DNks0WTlZNGx4WUNLSXEwWEduSzRzWGZtVDBpS1FWVUFvMlR3YzczZDlUMkw0Tk56eElRZldoOWVzNWpkMXNIdEk1aEpkZ0lsWAppUDdnYmw2NGsvMkg4dnhtckg0K1RQTWtmS055Q1E5dEh3SytEVzVjYk1wRWFELytta0pIS2VIV0JnWEJ4UjVFMlRwczRZc2NVcEZjCmQxSkZMcHJ6SzVMZEZHejl2U2FkeUFkWHdtTkYwc0JqSkk4ZXdoRUhhV3pEK01QaHBVQUtSeU9vVVl4emJSYUE0dlhWbHZTTEN1RnAKWG5Da0drVzVUdVZKZ3RwS24wamxGcE9TeTA4RkZPSzdKSmNrT0lvd0ZqalNMSGltR2RnL3hKUGdzY05MMENuUzJqZ09WQ3Fsa1o4awpiaWRSV1VDNlJiWTdFU3ZxQzNXdTZ1bjN0TmdUOXJtWmdCRnBCK3d1S1ovVXI3WEVJNk1pQU5iSURUQkZQYlNEb2V4NlM4TXI5Y3NFCkJwbURCZDVCVER2aDdPd3h4cnAzcG1ZZ29QYkM1eTBYT3dEaG9vRUwzSVZqMFVOSnpHTml1NDhvKzl4VWg3QjY1WWN3dkdueXZDL0IKV2RPZjRzQzNFYmhJdHlpd3ZyVlo2SHgrZ2RRWE1hWVROZmFITWxrVHRydFFEQTk2cU9pR0Z6aHJNL21obWc4QWdXWEpraUI5Z0V4bwovZU5sZUlNdlBNSXdXblVWWjlZMHpPMUM3T0VTQlVBTm5id05KZE5mc3l2dEJuR3JIZjlyLzZ3V0Y4cGMwaXFNL3JpSExVRmk1QXRmCmlMRzdEL2VEYzFOYng5SkJXQW9IeFVsbExCTEF1NEVqVEwvaWxYbFVhTmZJeEwrZmdJSW9vWmszUTM3SWtpMFU4dzVheGg5bFlLQ00KMHRZbklkVkdSc3RVa1VkczZnUUp1OW12NVJEUzUvb3gxR0xyeXNaS3g2YVVxTWs1bENvcXhEblJDT0VZeEpxTmltQWRSMWdGaUllWQo1REVnVXZ3Q05hZk5mTTZmVmFEbGtIMHphNjB1b2k3RnhKTXRzclRpb0tkS09UZlBDY0N6YW92K3dmVDZzSi8yVktBOEtaQWV6dUpPCmVhaTJiRVlST1VIRG52cEtpS0xOdEJNbmJ3WDVoNEFpbjM0MjVQalVmZ3ZPK3RU