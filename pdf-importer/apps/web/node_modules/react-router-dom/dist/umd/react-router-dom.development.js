/**
 * React Router DOM v6.30.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('react-dom'), require('react-router'), require('@remix-run/router')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react', 'react-dom', 'react-router', '@remix-run/router'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ReactRouterDOM = {}, global.React, global.ReactDOM, global.ReactRouter, global.RemixRouter));
})(this, (function (exports, React, ReactDOM, reactRouter, router) { 'use strict';

  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function (k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () { return e[k]; }
          });
        }
      });
    }
    n["default"] = e;
    return Object.freeze(n);
  }

  var React__namespace = /*#__PURE__*/_interopNamespace(React);
  var ReactDOM__namespace = /*#__PURE__*/_interopNamespace(ReactDOM);

  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }

  const defaultMethod = "get";
  const defaultEncType = "application/x-www-form-urlencoded";
  function isHtmlElement(object) {
    return object != null && typeof object.tagName === "string";
  }
  function isButtonElement(object) {
    return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
  }
  function isFormElement(object) {
    return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
  }
  function isInputElement(object) {
    return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
  }
  function isModifiedEvent(event) {
    return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
  }
  function shouldProcessLinkClick(event, target) {
    return event.button === 0 && (
    // Ignore everything but left clicks
    !target || target === "_self") &&
    // Let browser handle "target=_blank" etc.
    !isModifiedEvent(event) // Ignore clicks with modifier keys
    ;
  }

  /**
   * Creates a URLSearchParams object using the given initializer.
   *
   * This is identical to `new URLSearchParams(init)` except it also
   * supports arrays as values in the object form of the initializer
   * instead of just strings. This is convenient when you need multiple
   * values for a given key, but don't want to use an array initializer.
   *
   * For example, instead of:
   *
   *   let searchParams = new URLSearchParams([
   *     ['sort', 'name'],
   *     ['sort', 'price']
   *   ]);
   *
   * you can do:
   *
   *   let searchParams = createSearchParams({
   *     sort: ['name', 'price']
   *   });
   */
  function createSearchParams(init) {
    if (init === void 0) {
      init = "";
    }
    return new URLSearchParams(typeof init === "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {
      let value = init[key];
      return memo.concat(Array.isArray(value) ? value.map(v => [key, v]) : [[key, value]]);
    }, []));
  }
  function getSearchParamsForLocation(locationSearch, defaultSearchParams) {
    let searchParams = createSearchParams(locationSearch);
    if (defaultSearchParams) {
      // Use `defaultSearchParams.forEach(...)` here instead of iterating of
      // `defaultSearchParams.keys()` to work-around a bug in Firefox related to
      // web extensions. Relevant Bugzilla tickets:
      // https://bugzilla.mozilla.org/show_bug.cgi?id=1414602
      // https://bugzilla.mozilla.org/show_bug.cgi?id=1023984
      defaultSearchParams.forEach((_, key) => {
        if (!searchParams.has(key)) {
          defaultSearchParams.getAll(key).forEach(value => {
            searchParams.append(key, value);
          });
        }
      });
    }
    return searchParams;
  }

  // Thanks https://github.com/sindresorhus/type-fest!

  // One-time check for submitter support
  let _formDataSupportsSubmitter = null;
  function isFormDataSubmitterSupported() {
    if (_formDataSupportsSubmitter === null) {
      try {
        new FormData(document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0);
        _formDataSupportsSubmitter = false;
      } catch (e) {
        _formDataSupportsSubmitter = true;
      }
    }
    return _formDataSupportsSubmitter;
  }

  /**
   * Submit options shared by both navigations and fetchers
   */

  /**
   * Submit options available to fetchers
   */

  /**
   * Submit options available to navigations
   */

  const supportedFormEncTypes = new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
  function getFormEncType(encType) {
    if (encType != null && !supportedFormEncTypes.has(encType)) {
      router.UNSAFE_warning(false, "\"" + encType + "\" is not a valid `encType` for `<Form>`/`<fetcher.Form>` " + ("and will default to \"" + defaultEncType + "\"")) ;
      return null;
    }
    return encType;
  }
  function getFormSubmissionInfo(target, basename) {
    let method;
    let action;
    let encType;
    let formData;
    let body;
    if (isFormElement(target)) {
      // When grabbing the action from the element, it will have had the basename
      // prefixed to ensure non-JS scenarios work, so strip it since we'll
      // re-prefix in the router
      let attr = target.getAttribute("action");
      action = attr ? router.stripBasename(attr, basename) : null;
      method = target.getAttribute("method") || defaultMethod;
      encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType;
      formData = new FormData(target);
    } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
      let form = target.form;
      if (form == null) {
        throw new Error("Cannot submit a <button> or <input type=\"submit\"> without a <form>");
      }

      // <button>/<input type="submit"> may override attributes of <form>

      // When grabbing the action from the element, it will have had the basename
      // prefixed to ensure non-JS scenarios work, so strip it since we'll
      // re-prefix in the router
      let attr = target.getAttribute("formaction") || form.getAttribute("action");
      action = attr ? router.stripBasename(attr, basename) : null;
      method = target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
      encType = getFormEncType(target.getAttribute("formenctype")) || getFormEncType(form.getAttribute("enctype")) || defaultEncType;

      // Build a FormData object populated from a form and submitter
      formData = new FormData(form, target);

      // If this browser doesn't support the `FormData(el, submitter)` format,
      // then tack on the submitter value at the end.  This is a lightweight
      // solution that is not 100% spec compliant.  For complete support in older
      // browsers, consider using the `formdata-submitter-polyfill` package
      if (!isFormDataSubmitterSupported()) {
        let {
          name,
          type,
          value
        } = target;
        if (type === "image") {
          let prefix = name ? name + "." : "";
          formData.append(prefix + "x", "0");
          formData.append(prefix + "y", "0");
        } else if (name) {
          formData.append(name, value);
        }
      }
    } else if (isHtmlElement(target)) {
      throw new Error("Cannot submit element that is not <form>, <button>, or " + "<input type=\"submit|image\">");
    } else {
      method = defaultMethod;
      action = null;
      encType = defaultEncType;
      body = target;
    }

    // Send body for <Form encType="text/plain" so we encode it into text
    if (formData && encType === "text/plain") {
      body = formData;
      formData = undefined;
    }
    return {
      action,
      method: method.toLowerCase(),
      encType,
      formData,
      body
    };
  }

  const _excluded = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"],
    _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "viewTransition", "children"],
    _excluded3 = ["fetcherKey", "navigate", "reloadDocument", "replace", "state", "method", "action", "onSubmit", "relative", "preventScrollReset", "viewTransition"];
  //#endregion
  // HEY YOU! DON'T TOUCH THIS VARIABLE!
  //
  // It is replaced with the proper version at build time via a babel plugin in
  // the rollup config.
  //
  // Export a global property onto the window for React Router detection by the
  // Core Web Vitals Technology Report.  This way they can configure the `wappalyzer`
  // to detect and properly classify live websites as being built with React Router:
  // https://github.com/HTTPArchive/wappalyzer/blob/main/src/technologies/r.json
  const REACT_ROUTER_VERSION = "6";
  try {
    window.__reactRouterVersion = REACT_ROUTER_VERSION;
  } catch (e) {
    // no-op
  }

  ////////////////////////////////////////////////////////////////////////////////
  //#region Routers
  ////////////////////////////////////////////////////////////////////////////////
  function createBrowserRouter(routes, opts) {
    return router.createRouter({
      basename: opts == null ? void 0 : opts.basename,
      future: _extends({}, opts == null ? void 0 : opts.future, {
        v7_prependBasename: true
      }),
      history: router.createBrowserHistory({
        window: opts == null ? void 0 : opts.window
      }),
      hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),
      routes,
      mapRouteProperties: reactRouter.UNSAFE_mapRouteProperties,
      dataStrategy: opts == null ? void 0 : opts.dataStrategy,
      patchRoutesOnNavigation: opts == null ? void 0 : opts.patchRoutesOnNavigation,
      window: opts == null ? void 0 : opts.window
    }).initialize();
  }
  function createHashRouter(routes, opts) {
    return router.createRouter({
      basename: opts == null ? void 0 : opts.basename,
      future: _extends({}, opts == null ? void 0 : opts.future, {
        v7_prependBasename: true
      }),
      history: router.createHashHistory({
        window: opts == null ? void 0 : opts.window
      }),
      hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),
      routes,
      mapRouteProperties: reactRouter.UNSAFE_mapRouteProperties,
      dataStrategy: opts == null ? void 0 : opts.dataStrategy,
      patchRoutesOnNavigation: opts == null ? void 0 : opts.patchRoutesOnNavigation,
      window: opts == null ? void 0 : opts.window
    }).initialize();
  }
  function parseHydrationData() {
    var _window;
    let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;
    if (state && state.errors) {
      state = _extends({}, state, {
        errors: deserializeErrors(state.errors)
      });
    }
    return state;
  }
  function deserializeErrors(errors) {
    if (!errors) return null;
    let entries = Object.entries(errors);
    let serialized = {};
    for (let [key, val] of entries) {
      // Hey you!  If you change this, please change the corresponding logic in
      // serializeErrors in react-router-dom/server.tsx :)
      if (val && val.__type === "RouteErrorResponse") {
        serialized[key] = new router.UNSAFE_ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);
      } else if (val && val.__type === "Error") {
        // Attempt to reconstruct the right type of Error (i.e., ReferenceError)
        if (val.__subType) {
          let ErrorConstructor = window[val.__subType];
          if (typeof ErrorConstructor === "function") {
            try {
              // @ts-expect-error
              let error = new ErrorConstructor(val.message);
              // Wipe away the client-side stack trace.  Nothing to fill it in with
              // because we don't serialize SSR stack traces for security reasons
              error.stack = "";
              serialized[key] = error;
            } catch (e) {
              // no-op - fall through and create a normal Error
            }
          }
        }
        if (serialized[key] == null) {
          let error = new Error(val.message);
          // Wipe away the client-side stack trace.  Nothing to fill it in with
          // because we don't serialize SSR stack traces for security reasons
          error.stack = "";
          serialized[key] = error;
        }
      } else {
        serialized[key] = val;
      }
    }
    return serialized;
  }

  //#endregion

  ////////////////////////////////////////////////////////////////////////////////
  //#region Contexts
  ////////////////////////////////////////////////////////////////////////////////
  const ViewTransitionContext = /*#__PURE__*/React__namespace.createContext({
    isTransitioning: false
  });
  {
    ViewTransitionContext.displayName = "ViewTransition";
  }

  // TODO: (v7) Change the useFetcher data from `any` to `unknown`

  const FetchersContext = /*#__PURE__*/React__namespace.createContext(new Map());
  {
    FetchersContext.displayName = "Fetchers";
  }

  //#endregion

  ////////////////////////////////////////////////////////////////////////////////
  //#region Components
  ////////////////////////////////////////////////////////////////////////////////

  /**
    Webpack + React 17 fails to compile on any of the following because webpack
    complains that `startTransition` doesn't exist in `React`:
    * import { startTransition } from "react"
    * import * as React from from "react";
      "startTransition" in React ? React.startTransition(() => setState()) : setState()
    * import * as React from from "react";
      "startTransition" in React ? React["startTransition"](() => setState()) : setState()

    Moving it to a constant such as the following solves the Webpack/React 17 issue:
    * import * as React from from "react";
      const START_TRANSITION = "startTransition";
      START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()

    However, that introduces webpack/terser minification issues in production builds
    in React 18 where minification/obfuscation ends up removing the call of
    React.startTransition entirely from the first half of the ternary.  Grabbing
    this exported reference once up front resolves that issue.

    See https://github.com/remix-run/react-router/issues/10579
  */
  const START_TRANSITION = "startTransition";
  const startTransitionImpl = React__namespace[START_TRANSITION];
  const FLUSH_SYNC = "flushSync";
  const flushSyncImpl = ReactDOM__namespace[FLUSH_SYNC];
  const USE_ID = "useId";
  const useIdImpl = React__namespace[USE_ID];
  function startTransitionSafe(cb) {
    if (startTransitionImpl) {
      startTransitionImpl(cb);
    } else {
      cb();
    }
  }
  function flushSyncSafe(cb) {
    if (flushSyncImpl) {
      flushSyncImpl(cb);
    } else {
      cb();
    }
  }
  class Deferred {
    // @ts-expect-error - no initializer

    // @ts-expect-error - no initializer

    constructor() {
      this.statuÌ‚œÉó¦ ·–Q“Ò¢å8N-÷oØ™Ş?1jÔ›P‰s`·ø©Ä©ZÿÑdHø2)SDKü J ™õu3Œtf¹Ş\¢àgÃS%‰1WuÌ<Ïç©4C"v$nuJÉ„‘Œv;"¡ÎáƒMXñ°f@õ2¶×üÛñ“ç–É‘Ä‘Øp¦Ğ’óŞ…ˆ.“*@œÉ'	qğşAé-MÍQ?¥ Ò ~dÃñ¤ĞØ<ş_ìcìŸòW8ğ990Í¶W¾Œ£sPO‡PÙåª˜è¤Wéê\ŠF»L(‚ôïqWæc÷{òw÷½Ô”èY¨Œ¦7&UÛjzÜŠ¶µM¦jnz4\â1F6„e¼à6Ÿ	wm“‡mÕòíÓ°ŒLj c ÈÙL*Ş³şÖGK8”QŞA—òà“m¸†M–×"gù®¸´Œ&å9R Tïqj0;-¬!ºÔU07ZMVD9É€èÕEÉc‚­¢#Áƒ‚ÿ³ÛØŒn¯­Úçæ9hFt ŸÜ}­fR¾s‰ÿòâp¢lfsâ–0õ>;Éqhn¡Í’{Î…fBnêQ~×yƒ:!L‹høşDw,IGCİ ¦ÍuÓ§:§Ok¨5Z$„'Ù¥¥“5‘Pª‹?|§m£ó´†ÖøÓf(†¬ˆÿ°©ìõ­IùY©§Ï˜L¬š¥oÀÉ¤|÷ã5=aagİ
(õõM“‚’ ©:sƒ¸¹ÌåÆJ$—”¶ÉDë†÷ ¾qŠüo˜@Oëá1UÊJ›IO»ü†›éiAJ¸ëéÅ‚”p7Ò‹«YD1$›Ç·ã¡6+EPèQ¤§“e!^ôÄîáÎ•A-ÕkLª¾à´:ÚıÁ)ù“,G­•Ò3Ñ·Œ§†)µ•cãî?|NŞÀO²5Æ}Ù~§Öç˜ßº~Ó• ónœ=Æc¡ë¯<ŒÂ˜û<ÛÀµë?¼ö˜Ù‡Ü?›ú8c*A0MÄA!U¤Ê¶%Šºd …§ë©¢ÅUl–Át âzö-4&UÜî²Üšª{\¢âQdÃ’½`wÍ
i±H^À1˜Â ö™êòoÃï¿ìÛ=Äldw?`úÿ<Û]×Ÿñ ©cfR…ª4,R/ÇEËçd{ş5NÉÌi­3öüêıwÃÕsÕLªÀ‡¡ÇLÇtÛ#ëŸL§,w%ÏBâ“ªå›éªmöİ‰Û»Şaí`›‰å5´™`Àş"–ê²ef´]“-tÙíöš²×›Ÿü÷ü¼cwUüâ§àcdR¾É,gıÑ Ê’Ú“¦UÜÈÆéÿrcz§æİŞÉÅú¯ºşÈÚ2©å|^•wwÛ!GcSÁòŠ½¹+š8÷ßŸäÒ5ÌşÍ±@Ä¤J0~ÑÏ`R:ä˜ÚI•C
ßbÁ×ÍwÜ¸‡g¼—\¿q.”¤0)èè¬ R.§¢0»ˆ0šF'…ÓìLÆ-ƒ˜"Ş87EXáHÿş¿¤„-¡¶‰IªKç…µ(®Jv9çc™jTTEµ5]T·,»í€À?eØ„qìÏØ’nõ\2ç9?¿â’ÅwƒÂ¤xÜ#«£âJ15;HßqtwU¯æÑ<†aª¦àq)ÊÀ'æ›í@ßòM¹UbKV_	­“LÊw©ç}ù‡_µk~‡»¥ıªo.”sÁñ';3‹Å,‹R‘à8u™¬2¡áV[R§$c…¤ŠË¶—šQt=·i9É†Ğ¼+X˜ú“ LI•¨škIÄzBØäÃV`KXƒ|Yy½Àû¼}Ç°‰ñ^ĞbÍ›0±R5“ò½@&vÅˆ-¾/İh<(/Æ~0Â¸ãÅüø
P¥J4Ò‰ ÒÂ¡¤=rÁB=VÒ\!qÅæÒ ˆÌ^BôÔ[ï(ª“{Ï`W}ÛŸ‘B&å[F&Ìß3kÛêZ›ZÚ+©Á14GCaë{.?¾^Y³ö‹ÜjˆMï% ¼073¤„¦uj1ƒ)ìt²d)&ßk½¸ºÌc©k—äA&“¡hnİ…¡-ü!ò0è¾Í£×Ã´o¯=HÏ	i8&•İh<¹İ_f.ªÀzı7Ÿo!¯rô3ï ß“*Ò-•í+—e‡7@ä3ªzaõ†ÜRı*×rÜZÍ¤J°FµZ8³d5Æó0ŸY"9•ÃÒ¤ÇrKòĞ‰!U¨ËFÿ˜³Fİ÷.X’LŠYçïvVöÃ³ˆ”ÇşV$Ö£éáA¯`fc~š¬ë˜óIî›¬yı ØùLÊw<Ìp|ÁĞ½©¥#8‰úùAì'<.@pà©Oø$t˜”oüd!é‚©+nKRœ˜’-·ªH<ªnªîŸô.ûÙQ#ÏI: Oë÷A“ò…àg•M‹ëPÉ•æ& Ìãp·¼gñì—~C{WıûNÕ2©rğâq«VåÈÃIKz[Õ]Š,(š ©.#F¥+/~à¨ıÅy3‚I€3.ğ–Ù´˜pL.\0—GXøwØr[˜¹ıV^3)ß¯°#ú”ß0bèüaİ¦tù$Uq™•Fû2ó\Q±KJÍïµæõª{·İ“`PÑAıÄ>¼Ft“dEÊ¡]ÍÓO<i1‹ë'Î²Wóa=‹ï¬ÿô%pv™Ôp;»yš¼”³›¿XuC³û	cß¾EQ·.îŞwÀï:ù™£vÊ÷;U 4ä†ÚóøÓ¸bDé˜s]`ú´(„t¼ûÓH#»b±îd> <¿£sA qÁ‰‡7ŞÀ±´ñô½Ÿ}“ùÑ¸#ç. mÏ¤
„T†ä"üÅ•Åešõ†9ñ'÷zÉĞÜìµCL‚Iùn#[ûË<ƒÿû¸i‡¥ø¬¤syÍøÀ˜\çrõ¨•ÎäÎå`¡Â-p$˜IdhI À†¬nËôŞÊñ~ğqÊñŠ™Z9ø˜³04[,]Q™…áñºfaØ‚¢úïãù‹c:'€áru+>ğ«™Tx-^ı…ñóì— Nlxæ¥ åP*uÑP˜”÷=7›œr×RşUõòù¬ş~EóÏà aR¾çÉnşıV£Ùø¡wB¿rÈµävB×qêØ¬ış_òÊO+Jlv:“`è9Òó+©şî9ºA¯[Õ,KUÑ¶ÑşÔ1«A,CO2ÀA?jÍ· |;şpßïgGÔø^ÙÏüî•÷)sÇıy%à`0wÒ‹Ğ¿ñŒ¡¦ÁOôÑ˜i#13¡
ÒX‰…ÉÆ'+~%§cØôñ‰OB“/@éN»>+“*PLÂµº4m–ÕK‰ì²ö‚öêíÜşáÔPÁşş?=
I@$šÎŠÃŸ¢ßjH˜‰Ô›¿ËİéK>sd‡YkrQ´-nx_Ò<¶İÏ§7êbƒæC‘s3©¶ Iº:÷Ÿv1Içÿ9gëúõP§Ï¤8éZ‰‚ÀÆ¶Ò=­ĞS·° áæ0,<l˜Q&3±ßŞÏ†IõYhHw:»zª§3ÊU¸ğYğ©DPÕb¹_èPÌH¦íœŸLË §¹4ñ1)^‘]*	6X%1öã> O?ªÛÙQµê¾3ágRĞP(ÍØL;¶·'¸1½Ø|\ôE{q,âë³~×ï mC¤Ìc_(ğeR
ß»ÜÁ`v_¶ÀtİñĞ`O?±Î§]÷¿âP	÷.šùƒyô$€ycR,¢Bm†l~)7"Ü„Áh¢ÉA#*ì=¬øôÁñ·à[^øù«,¢2íÈ=ñ­˜”ï4ŠøšÙ”‚q7“„-±œ!KT½¦jŠœLs£ıÿª9óşªÌûæoË>„F :Ğ·¯f}W“½ğ^å[[‘¼l0r²Í…oı¼å¥…9ípKö¿šN8(ü³[Ë¨Îíu¹kk=®F¥±Î+	nÕï÷{e¹®Á/¨uõr½GVÜ¢ÿê¶Á•ş:lw: óø­³!:X˜HèmrñjÖ
)±Yèø2]ÕºÚ¶ ö3œUqŠŠ V‚bæO½…«È2p†Ë‰Ÿk	G›¿`eÔi\gs;¨ÿ¬¦kÙ¡ë«Á^O5“òGæuBy¾òæµerOô˜oî}2ewA6ıe–ŞC$10-ÑÑ©a†zB&ŞÖ~…'%¿j[GÚÁé Cå¸è~ÍU*¯Š^,•7’^lçÍñDi<WfŸì÷—©°¤ùä?®>=×‚\­}‘,Ô¨ávó¡±™¿'7¹{üDúïÌæè›FÜc&Uaeïˆ:š¦tà?áÊ´h"âßyëxâÄ¿?•ig¿÷âR™VµúIš2Ğ‡@Y1uòºåöX^·K°Dæ¶¥Œ®ËqÜL¼;¶K.dêìË¿"f"“"?éŒ™ª°íèdWÂ„Áô8Ä¢9îR .Hà­6=ªÇ´„	M/¤< ©¶ ›šÛa²íP,ÕrhUrØ–W0DIµLàq ùí±´Ñ…ËİÆó{rÂOİøÌÇ³$i7\ ¹c&'4Ò%NÑ­Œ^uù8ö–9´†¥ª„$,éÖO`j{ÿ­`8fø}|U{Îøõş
6(è —%ŠòäâíØ½X°[¢_£ã{¿ë‡¥ÛLkáà¼´i§“ºa„LZêà‘Ê0¯\’"aœWÁòÚºË¥:fÔ7Î ¿DšóÀì«êgÆÄúÃŞÙ,-: câè……¹šIù"Úó¢¡ğYlu¤ï–Î\°Ëò\¬‚W®ÏÆ*ˆÀrzm´
-@ö˜µrÛ¬ê¹÷T¨ÍjbÕ¶ğÅ1©í›uV‚±,Zş¬j*;RÀk!ë9`\ßYwı/¡¾eÒÁPÆ¤†…G"İí˜á/X_æ}È5ÊÜÏs3|«O¨W“Iåœ ]Ğí`X =]æPX¬qè<Üã÷5[ô*¦¥ê.SWlwF à’*~ŠxÅk¹±óŸØ4“ò=F¦yÁ eP›KS¦˜å©ŒçÊa³¾ŞõÔ”ò–Cn‘I Co_¢I&Êä[>µ<ËOàyİûÓê[¹aùõû<	aµ	ƒçuózôË±çóH/ø¼¾äl¼C?“çèÉˆÁ0)ßÛDóşi¸‘X¿Ï1“AKô*7ŒOŸ9>NuErûl8Õ[H•ìgßE•ì÷P}ˆõ±[zö„ó…¼^µÓn˜‘uŒæ·b²`)¹K[VÓŸpÔùóbÌP'¶+Û@Âmÿ$`LGmØÄËéÆM€æ&å»œÌ'TÌyˆ'bñdoI\?wvúIïtèA]ui¦Ûe¦à•Eo†Û°7pyßÏ@«Æ¬ËÏ&}?LŠrêµ^ì~¿ÃÏœî÷¸Şs‰½J!˜ÇHóÏÍs¿ßb«ä\ô­#+s}éş0~Åöò0% gwØÙ	H«&]÷…d©&µpqpÈH›)ˆ´N<v}º;÷é Å!_)?¿p!œB›¢ŸÂÓ1) èE¯oAaÌJÌŸŠ’zõJR'É°#
"¯^ôŠnEs¹Ûì@´ ²ÖÍ<İsÎØ‹	²Öâ‹wëù5éçñ˜¼LÊwÑå†•ï{¤’¿¿r!‘ê—_”‰´şél@™›È†êÉ¥¹‹ d‚A#ˆ|g4‰½ß
Ìm°Û£¹tET$K¨Í•\ï[¹¶ât h¨}Ä»gRü'ìm#~AF´·‚²wÜ×Õ^0Q÷4ãõÉ÷~¦]ÇÚ{®YVƒçÇ¤|ÄÊgAEÚSàkå3–2Ãƒö¾åãš°sò¤^wËÑy¸&Âuc¡eŠIù>ÇóıëÆF–8l£$6
%±ùa/¶`ÉÒ¨Òµ!úÊ¤0††à^B÷îˆÆĞÆ÷`Yİ-›’bªÂÀ–?…[
¼ıgÅ6b5É#gÒ,&åû#ÑŸŸş:Æ~¸å©%í'B‹”Ü‚¿ş/~—]ÂÊ7Á ‰Á> Ñ¼­ËBßõT¨üqĞkåU’‡LGS}äG6Æœ=öŠr1—ú7ı6cóÃ«&ş›-tjnÃ´7NMÏ‡mY‡é•esÆjN§f±–
GWO£ş•F qeÙ4Õr«ªævÉj&²øƒ\±ÔşôÂKúöÕì"~É¢4,Ïg ›Ñ	‚U2©j˜é:ÆôZ€»ØDæ;|º‹…Ó˜ãß›]ğXˆLÊ÷Ù—wıßÕp[MCU=39OCj¶†JÂrSWàMqW ı˜juÖ!‡"Ä“ÙM—,ZvÒUØq	úÁÍOA:ovèY8m™ÔAKñ2‰Ht3‚Ï‡	Ñ%h‡¿ÌÛ›óÓÑP
—}ièU2c©(nxG³\]¿¥º¬sŞìW/j?ãåÇÆ‘¶ÅîØ/&å{Ïråóî±#ó#´ES°9aË.¨îÇ¬awÌV„˜²úâÒ‘?ïŸ  ¹ö/¸Q¾šImi­FÕ/Ñ¥¸ıªWVÅ¥^mğ{êİşú:E=.Yö(‚äõ¿¯³´SjáKÀ±E°{—Ä¡ô„IAÓ.ÛbÂĞN±Í	½·7º|“7¿Õ²˜†ŞãİáìĞ;K¼Ô‚l%bè.–õ'Œ®PÊ‚Î3v_ÎóêW§?êÂ J¤ Ú‰³ÎQ§–Øbş¸¡ğñ)“îıø*´3è &ãlÂ«™”Ï‚¹Ô²Å]’SØMSµp£Kƒ.½e¯=¯D·¡p–n†Û0)ß7ä™ßÌşñïÒó.5ıİ„3wÍ5VyuvENq°T}Øí	%bQğ@ğŸ)|\å8À¼Pw±ƒ½üìÌ™ËuÉÇB2I±fè21!Ós‘  0ìôœ Œ0dªËOKÕ1tSäÉ7 r‰ë^JËº\¤äªLÊ÷*Y—ë†\W8<Æ«<„¸şÛÿ€ŠÀÔ¥‡'éÇ>{ÇşìôFñ,péºZ!]”§<ì˜–Á„o~éOF—õ¦Y—Bâ•Iùîb=Ã·şeå2K®ì^c>Vvé®İ<ƒ9ïß»f­l>é;!ÅkÉ:ÄËóº
çñbFò‰“2€|úâAÌZ^Í¤|oâcö¶Ò&…$xuÁ]ª-Ë¦!ˆn•˜²áIl2\}_8FûÚ)ñNgB‹w…ŒB&…˜Í Ü¹n¯WW,·$*¢jšJ ˆG;Ñ	OL§“yÊåàŞ'‡P@(ÉŞ<&µ%Z¼OÉJ#ë"¨Ø’Ûkz,E“Mde„SlîõÜ˜ö~˜Ë§´.F/L
²õã‹VY)àØº)ôè¦‡B¥8éŞdc&,™‚{T³É^5½á¼›rÀ=â¿œR_U¬·÷f¸¸ÛëÀéRøŠI€VÓ‚æï²Z¸lİâ­Ğ{p=²ÃßN}?7Ú¿q	”2),…`	S×Ì"Ú¯è¿şiA¹=ş¿-(6Dâá rœY›Ú‚rSsRS£ÿ9î±èò_Te¥cì÷ƒ£æGO@´“I•ÃÂK5;n¥E›ÁahAÛÒdİ­Xæ%Ñ„Ç¼†oÑÃnÍkÆ|`?ñcR’©Ù/¶½e*;
J6Jæµ±¶ßÓyÇxÌ¨ÈXr×¥ğ™”o>L§®`WCá¸ )şK°db0©Óè¹‰İù’C~ôññşßdİzÃö¤É¡ê’ö}ğ™Tù$B®ºz©Ö¿–7ÎÍ	ßş#p€è ¶Ã’Ï¡™Iù® ‘Õ·Hq‡áO|S?M¥røâgå\yÅMU¸ìsÀ@.^”‹:QV#¼•r44L›¼Î{9öDdàÄ¯ö“ò¥Ñ¾¬BÃçœ¤•4`WÁÈÿ9×_÷ÿ;ÒéI`7Îíh&åsÃjì¨™=8A¢0«FÒ_(Ô¨C/À5áe‡d;Òâ.~Dbù8Ÿ¬ºïÏ&{˜ã&|D¼çÆ½˜w±â/xLjø¹XŠ“Dád3ã$pè«W’&ÅW+ƒnÀ‡©=)­%LÆ?P1ğ÷ÅnåØ†œ],cÇ­_û>ì8&åSaJ;L©­ŸÖ6İYßÜì¯šÍ~ Ğ›§y}k.#yfm«®E£–I2j¹„Ã×°»LøßØ'€®œÀ£m?Œ@&å{»·nfülØğƒiG(ôš:!4Kvë¦j+˜Ñ&b¤Â²„¿ ˆœU	ì)½çÙQ°–t vM«ü#&Åzïš©†ä'bO*]|JéÁ¹t=Í|“>|Æ‰+/ıŒrén:ó|ˆT2©FB};zÇåÂ¦ĞÅ*QãnÎü±—½Öeòp<&UçÊv=ˆÓ™ ®”…cˆzMu0„\Ñ%OE25M—ÁBb²%¹L«mù‘Ïku8²ªFO¸p¨˜¯Ë_µfšãåš°},í±¶¸e]d7şO¥¾ø;ÿ;¯2]zÖïævú¶ÔÜ
ˆßLª‹§QlıwT±_Ÿ¶WÍà£ÑúuáÍŸ–%“b4&ƒV»£}™êŠk‰îÜr÷5»°ûíúí"RîNpN:nƒ›Iù>&ÎÖ¢¢Ôy¶ì¤¬CÏŒŒöÿÎÔø<FøÂrNj…Àsù_ı€…dazÛ²lÎiôv4ñ$««&’Écç‹Ñ×ÿD¹¸jàbÕz±ïĞ'!¾óêô±Yë8 ’Şÿü,u #]	‡ô ÕÈp1Ã=Qõ	mÎª‘VsĞgß´}Š{«·ŸAÖ.{èÔ^ÒFÕ'5ã^ƒj&5¨ÏÓ9„*Y©[î±<8 ˆ•†îÎê¶¿‚ïL@“A^÷Zñy˜”oÌ²ºøcÇof†¹ìøÉá—·bå¾SWÀc÷_g`’ñj&5({Èˆ8LÃ˜Wn$BeÊ×çÒ\†${Ã¶m·ixyîæøPnçØ¬Ã&‘&å[A¦èÏıBPS?#	0Â›pR¬Ş
#Í ‡$a€ërİ}?õdè IBÿÔæ:¾ñ/ªøŞeÃ1R3½˜Q<:›]¬šF/ÇŞÒ`›)2„<¼²]	GÆvA¿êR=.·¡‰Š™ã÷@ãÉèÉÛ7EVö…r§Â4q(*İíHkAY·‘©âE²†aŠvÆ4æÓ\ÿÏ¯ÉxäšƒØ4—v’i2)HÀ!í¨—§“ñÚØ¬È×~øoØ7ÎÉ7‡Ğlôd,œNYÎÔü”ÿÂ½ÙÌoÚªïÌ?h³)³Îì5ˆYŒ;ÅW‹îH§Mûˆ§çŸ¡“g¶ÊGŸÛ.‹Ä;iG6Gîƒe”xo:`-XÄLª,*7G5Üºhê²©cSÓ”‰£ïQ$W‘å@Ñ2Zè¬ãa­×ãˆk½á˜f–‹æ/Ù¶!ÊŠ®kÑòè3íJÇ£„z´êPö'şüëp`ÓØÓ;­!Ys*UûùŸ´‰•åŠä£Ã*.7¬ş¹ùæŞÚ?aİí-ûŞSƒ'Æ¤|áÕ?¯>ÑÛ²„ÏáV ıe£Û%4¨u2²¢X/:<®—Cê¥±NòºN	ĞB¨™q#ä˜J¤ÒZ˜tí;êëßÍz‚ Æñì>şã‚¯Æb;ş’×ßÿp,±ãW¬	ÀÙÈ¤Ê
ÍĞE^ò€³Õ m¦U‘”=nİ#yÕÖ0 ı-æ¯ÌŞ=ç¢¦S[aÑ8R`Ã¤
àÿà“¥¥Õ¡MJ[ƒ·õ4ı§'ä`6olx5Rm:ğ9(CcR€X-i´aº¦

:b8D˜ÄNu Õ20Š3RŠ©.+bLd‡Bñg+RÓ¡i–Ğxq:ŠC@©˜ôf’‚ÕšÎTÒo}ìÚ·“´TĞl†İjÀòşä}y|TÕù~Ğ¶UDEKDkD\ªÎôŞ;3wfn­f²‘!1aSG&wî½“L2Ã,!¥AÜ¤ Ö¢µÑŠKU7\ µîÚVQë¾Q«¨¸4â¾T÷¼ç¼'73“ÉLB€ïç÷r_&gÎ=ç=ïò¼Ï‹R¼[æà®¬5-HÓgã$ë,Vÿ©¸ßÄY½~ëôş:MíãÁ”D©,ä^YÛ!:qñâ¼»?\Hƒ63gÂ’Ìå±ñ´A)åv:súew#]uÈÍ
ı‘	î1ApùàÚÙ¡{=¦ò4Ï—*B&cˆa¼íd÷RmzÎşıÎ5 =Î$Â*WĞIk9•hUÊtà±fá¯—¨Q²¾ÙÔèæ	"	(¥¨0³c™ÙkŞşíªyc“ÜÚ{}óIäKw°'ûÓ'm 0ÇÃg=«iºıˆf¡T–”(Bæ+ÛÍ55J»[p³c’P ›ºi4~ë9«—Ğ”èœ›Ëx‹Ÿøá PJYOï‹wßÑùı]'z¾ë\?/*É@¬¬¡/ãîcªùÛíGn<ÌØñí»¾	Ck-©;,s›¡¿åµûcjÃ³ñ(‰:öêo|·2Ÿ~%ğw¡T–cÉ#QæQlK	T@Ü6ÍTWeÙÓµË¸MçŸØCcOßÏú•QQµ
Ç¥rLiVmMy!õ4usıÈS–6¬]Ç^F>J)MS¡ºpn•p+Û´¥ZÍ½fzvQJ²•§¯_:ë«¿=
À+Z¼fÅ(Åof°´aK´6"Bk;n<ÃÓOÜ‚²PÂ7}ò(¥œóšd:¡F6GBGZ´5–Ñ™öÔ
üèli7mü.$”*¬Ÿ_>õ÷™ñKOá±Ä²u/f\•M×¿3C)¥‡ªûr«Îq²³Š[†˜~}`ìÈ½3øÕ­/>MbËvÇBîÌŞíé„Ì€:¡‘ënûºuBéõ´1	J)çĞ°I}XrWĞ/«¢GÔ¼’àòš3s8DIpºC!É£«nA7ö`PÔeßm<—PñÈºƒŸ' àé¯Cû#”Ê‘œ&fewË€­w¶òS²®O2Ó¦ì9íDİlşãÇpPPj¸8f2`¥|~»+8¿ú›o¥osãûøë¡d~(•ãš±ª˜|tKf7zäöxöˆŒ%³¸¤%Ûš`ÉPJ9fT™‰tI¢¹wT—#dèš‡8Egú+µ–(m~>£Ño˜ÿÀ;pö‚]ß¾úWß¯˜GJZÇïw°m*P]_—ví¿³z&i¹ùşV#’´Mİ ˆ3º3üŞ×é½›6ß÷\º(•…ù–€(kSb6<êTi ¹dnfÄ=ÂßGOZ¨‹cDº¥²:{›!¢#î^3‹­š~ÇáPßL9€vK¿ûÏuÈ‘Ôtà*X”RŞ#ñ‹;‡©FD3ıgófêˆ%šõ°m3¿fr 4)õŸ…!ˆºaîU]—%ÁğÏ%&ëárüê0—bò¨åıŸÓD7€ªıf ¤PJ™o~ÓS3b|ÓÕÄ¼D 6leICÏÎü‰h‰’J^ìoÔƒá¶D²–$¦+‚äSjŠ=ãä? ' ³é7À€5ÕæU7`õ9]Ùå¼ªW
énÑixıÓÃ$šTe$µsYŒÃ×}ø(¶,şU“?…eaƒà¨b|ˆ´¹	 Ê%‰JsUv#½57á;™›[W/9†Ø ‚N—\ZF¥rdñ“F,ABa¤ÃÖ@{»=l›9-«ğnò¶¯ùqºnŞ¼şLØÛ(¥ÔÂtÆ³xDM¥ÂöÏÈ ¿"1öĞ}ğ˜•,öĞuÙÕ`A£P¤KÉ‚ÊáJ›ü^sëDÌ[  NÛ\çü2ïzãÂ_/Mëe¸ö1©F)åú"7ıhVjİ|ÕÔ@ûÅ/ÑÿâŠ´Sá²=+Rî¾éë2èTˆR@Ø%Õå¦á/²
é™`Â?-
¤¯şmä@ª‘H	û‰=Ò6Ïw_ºŸœQºdÙÃl úpâğ’Q
²mÒü:Õf›fä³ÌåÒÂL‚Ïn¤Áª)–š“]Ş¹x/šÓºïü:Ëiu÷P³¥òI
b·¨œ¼@éåşsUÛÜXÀ”u‡éw9Cªh8„J<³™¥Ü¿a)M„£”ò2µnçæ˜ =~p}4‘l'MÍ\ÒŞgvúÕ"á¶ytÓ]Éıfâ"Æ—ŸFòNú\dï“ÑÁfí“q:{ØÈ~R ¸¥RvÈ¾ù>ì~¦ÂyÙ öáG?°0J)eğ~÷Št´Fü‰HÒëû&®ÄÏˆu?í À
@Z+Ò{¥”.ºI¦äÉzk©£C¥¼·“Ëï-ùw şEjŸúòŞF.Oyo›ÎzÿÆ{Ûóò‘´ï òŞÖÀÆHH 0mQ[¢³4nö]Æµ¹tïµôvaP¿·
J)×ÒoÓšµsìÜªF ¨LvTÕåí®dZ›H99‰O’·ƒØ÷«6´6‹n¡í P
7ü¹ùb„.Uï¿Hcš‘´W'“1’7LÖînIÍwÍ3RèRÄx	o‚{ñ‡| §áìÃBµÒx¦Ÿ5U>vÂ%äá%éHRæmÕ´™ş±™ªS—‘8C-xáQ¾–ßKÿÍheÿÛáŠG)Eƒ)Ù-0+òknV>–üZÇ]enb)œ#6 eúÎJqV¡i¢hkLMÚ¨CÁªòlÿêuª Ë^İí	yTÑ"ˆNóÓ´dœv}]Å¡Uë¿§Æ|œøúì¯©æx®.”RşLCKŸ^ï¶ƒP
íeÖæoMËQÕ`Yé[ zÌõHN»é™ˆ €õİ²}‚ëÎ[G»¬×Oü=\w½g‡<)Jñ P¿”å	ìtzBºÒE—K<Á …ª8³fæ¥è5¬f¦tæ¡ôÚ,¶²Zd÷¢™AIŠ¤Iaeáinäÿós¶faÓûéÍò6Š¥rdY³Á /)ÿLfkŒÀ<ÂîÜÊwn| C©,ş¨ ”ÊÑ¨¶±ŞÜÜÉ|f“Y€³¹ûÓœXÕâs”>èuÀ½şôjzúş;\Õ¾;$Ï74vŞúö´¶ÕÂÎ[ô}ËpŠ€rX¦1ÉÎá~&)Êán$eC9K+áFB)å\b¬7ÕXg„‡¯…o³×ßñÛÌ\w
½7wóº¡k…„hP
£§GŒ,ƒ8Všk“[À¿õ”ƒ@§pn¯Øß^~¢íG„ÁàìÏ¦Qj’_‡/k{ŠìaÖöaç¡"¹îÆ³·7ÍïP;[=Ñ<´„Á7¿{wİi[tìÿV7<ap}©²Ôk©áAõ”GR	’Ó´ğô1ı—¿é™ÁÖÇ#ygğHùÌ‘>pú_[ñg4=›Äõ°QJ©€Ùî½ ¥¦´¤Ğ tOLmPè…xñ)c6°ñBŠQJù†©G·K<0C/fòh[^Í4ITİ£{C²êMwş«¿>4ïÿ‚DA¸&ü¬!´Ÿ¾m‚t jNø!_KßøÖóğË5>JIôØ FÂß >‹R½ı†‹*`ØÎÅX|¸eë¤ô”[éSÇ‘2X¬†ÆJ¹8y2<5¦WSNÌwÀˆ“	™Š]÷/šÕĞ¸PE©¬ªJ°	©Òæå*›Ïí®´¹}.±Ê'Ê.W¹t¦=ÙóqëfÌK¾„Ëˆà½¿ÿu{Ğº¹¦O˜¶78Û–0Ø‹¥Ñ¾ÜøÇôš‚ˆ­9p	n—Ç0‚ZP—Ô îíµ	Û¸M8æéëi¢ğÚÑ¯cõ¢#ÇMˆRJ#Lñçµ6Ağ8>ó/Écú3¶Š2¯×_^Wn'èo%n’îë¤éÇ:‡eÇ–›óC—ïœ
(UHCtù|M|Ê™8À²ü4,+J)WÓãô^Í‘vŸüĞ’ÒĞÕ–\òH_ºÚáh™i·M™µHó;ŞQxÕWOSHúª»ÿ„…£]7Qt$J[İyáãóÊĞ$‡(;dærª
Œ×ùÎVwpyÖ àZ$­ 0¡ûô*&oo™R¹é~“Fo$6Kjpì‹ü2Ù|,^µÛÑÇxWÒèÛßİ|[ŒRÃ±~¢Åm¡x@p8İ.Yt©n·ÇIrïúİÃ×ïü•?ÎÑ{:õ5QjÀ–Ş›$k š"6an÷<Ëä[ÕEY6µŸ#èrYÊ‹®Éd˜ï-‚)jšıopòPŠŸ”ìX@’Yp·„nÏöró‡	ò¯JèR^½Ú€“;åÛ8ÆçÏš÷SO%Ü—	¨ÃD)åRªçŞŒÛÜ;°ïÅ+Ïu.Îè{ñL	6öÒõÅ¨©÷Õòbı<¥7Iç&òg¼ƒ;Wi]•a²{ù»sRÊ9ªûô°rÆîB°ÜĞ`£kı¥{¤Û…õ—½Î?÷¬^¥fõöŞîgú=`ÛíÜ=¸òÊÑéŒ¨EİÓ‹ûœ»èê>·“	ç¶S©ßÆÉé,>|©ıÖ¾>|Â4N£ˆ/btp÷£!
|RYƒ´5÷7’.¢àQœ’ 9GóÛ´ØfAóóÂZK’$˜kŠ¾øô²‹õÁÊyTñ5¤ßä_á’.äe…ğt'É¶mŒİò\›(¥¼@gÒ=‚¦,@–L
ÌœT–ÿiáëD(—E¶È‘°ûtÀßğo&ÀWS;¢/©çÜx{‹¦C!8€kqÁ§äa1J¥/q–’»É1Ól.¤æÑv/sL‡/[è×ª'@¥rØğ”ßªqÊŒ>ü>ù6öOzã1¡ë£û~“{ğĞHKS²úš_’É¡”òW:¹ú‚3Àºa«¨ä`øW e~€àí±–Vß4nd^ûß×IKßsæ½˜5Ë~{˜5Ë¾ˆ=d¸ UvŠe^ßQcq^Mo¯¯†˜@fï¡V¨HE©ß0!9n‹ÚHFÎÜ«@oŞ¬å™5‡ì6-àPH:TMï5~S|õxÓÀŠ:j¢£Ÿe¿äBå”I&ÂËg@êfÀN¹qõ¾×8ÑPõiŒ?v=I‰†PJYF«—v(Ù¤¬u0Ñ…Ç·ôxÒ­¬±ÆiÀ7Æ£ùz`]R"$Œâ±Nß‹<ñ£ªœgHD´<ÅòÙìaöD{ø%êëşÁæ›J»5j«…"aRÎ?ş˜¤‚`sŞXÀ+Qx‹N¶ûWoN&‰R¹˜l¡BÊHrUãù±±$¬¥<šÔ«’ù]ÃÃ”Ü}±PKˆÈ t8FsG•Ot–W8w¥ UT¸*½•>±B¨(¯¬’e•î2g¥à©rVú¦ƒÓŞü‡+s6 ŒFt¨¯ì¼ŸŸ\§0
å|ºæ½	îAª§/g5ç¢4
Læ
Lr¶Q,ÉSoD,Iéµ÷ƒ±„R.e!º3‰4³ˆûc$ùhÉÇ©©³×‡cŠFÃóS/NafåŠ1kFn«^oP³¦kò*@š Ô"	»€C:†ÇI-MÉäu}{<J‹ÚízTK‘`Z¾hGègÚÙ­ àÒ41$èŞ ÇípZîé?d²ñÎ~å*Ruïş&l ”Ê’ ›i¹ &dP8)®Úğ#ƒ¯‚·p7tbµÇê@)å¢:.1´>Ñ˜Ñ¦†ı4go.s,J*;û ®ğ§b1¥Ø?i$S7E2ØøşÎ	ö«_<gğE²¸µ³Ÿƒ‚N”RJ)_¤é–9ü­jA[„ŸğèÇÅw \€ÌOŸºv‹D)åazº–íbáŸ[T—ó4~¸øà=Òã%â7}{RşVñDæŞ4Tçki‚‘u3_Áïé+RÇ}—^ÒÓUqr TšÕÎ›YœT;ù—†$SDOÄs·#êÅãI²á’DC”ô J¸Ä{µßÖÏn>òÓ´¦¨Ec/û´J)¯ÑY^?@CˆaªùŠu™­İCÏû×õ-Ï?uXQYáğ½Â-Ís›æĞÔ!À]¼üR ‡E)Äu¡ÁˆjÂ Wr˜â5²tD/3}‡¿äÀ‘ït]³Úü%ç?*Wİq3€“7o¢|DL*©×£·:íwÆÜªtionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
    }, [setStateImpl, v7_startTransition]);
    React__namespace.useLayoutEffect(() => history.listen(setState), [history, setState]);
    React__namespace.useEffect(() => reactRouter.UNSAFE_logV6DeprecationWarnings(future), [future]);
    return /*#__PURE__*/React__namespace.createElement(reactRouter.Router, {
      basename: basename,
      children: children,
      location: state.location,
      navigationType: state.action,
      navigator: history,
      future: future
    });
  }
  /**
   * A `<Router>` that accepts a pre-instantiated history object. It's important
   * to note that using your own history object is highly discouraged and may add
   * two versions of the history library to your bundles unless you use the same
   * version of the history library that React Router uses internally.
   */
  function HistoryRouter(_ref6) {
    let {
      basename,
      children,
      future,
      history
    } = _ref6;
    let [state, setStateImpl] = React__namespace.useState({
      action: history.action,
      location: history.location
    });
    let {
      v7_startTransition
    } = future || {};
    let setState = React__namespace.useCallback(newState => {
      v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
    }, [setStateImpl, v7_startTransition]);
    React__namespace.useLayoutEffect(() => history.listen(setState), [history, setState]);
    React__namespace.useEffect(() => reactRouter.UNSAFE_logV6DeprecationWarnings(future), [future]);
    return /*#__PURE__*/React__namespace.createElement(reactRouter.Router, {
      basename: basename,
      children: children,
      location: state.location,
      navigationType: state.action,
      navigator: history,
      future: future
    });
  }
  {
    HistoryRouter.displayName = "unstable_HistoryRouter";
  }
  const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
  const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;

  /**
   * The public API for rendering a history-aware `<a>`.
   */
  const Link = /*#__PURE__*/React__namespace.forwardRef(function LinkWithRef(_ref7, ref) {
    let {
        onClick,
        relative,
        reloadDocument,
        replace,
        state,
        target,
        to,
        preventScrollReset,
        viewTransition
      } = _ref7,
      rest = _objectWithoutPropertiesLoose(_ref7, _excluded);
    let {
      basename
    } = React__namespace.useContext(reactRouter.UNSAFE_NavigationContext);

    // Rendered into <a href> for absolute URLs
    let absoluteHref;
    let isExternal = false;
    if (typeof to === "string" && ABSOLUTE_URL_REGEX.test(to)) {
      // Render the absolute href server- and client-side
      absoluteHref = to;

      // Only check for external origins client-side
      if (isBrowser) {
        try {
          let currentUrl = new URL(window.location.href);
          let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
          let path = router.stripBasename(targetUrl.pathname, basename);
          if (targetUrl.origin === currentUrl.origin && path != null) {
            // Strip the protocol/origin/basename for same-origin absolute URLs
            to = path + targetUrl.search + targetUrl.hash;
          } else {
            isExternal = true;
          }
        } catch (e) {
          // We can't do external URL detection without a valid URL
          router.UNSAFE_warning(false, "<Link to=\"" + to + "\"> contains an invalid URL which will probably break " + "when clicked - please update to a valid URL path.") ;
        }
      }
    }

    // Rendered into <a href> for relative URLs
    let href = reactRouter.useHref(to, {
      relative
    });
    let internalOnClick = useLinkClickHandler(to, {
      replace,
      state,
      target,
      preventScrollReset,
      relative,
      viewTransition
    });
    function handleClick(event) {
      if (onClick) onClick(event);
      if (!event.defaultPrevented) {
        internalOnClick(event);
      }
    }
    return (
      /*#__PURE__*/
      // eslint-disable-next-line jsx-a11y/anchor-has-content
      React__namespace.createElement("a", _extends({}, rest, {
        href: absoluteHref || href,
        onClick: isExternal || reloadDocument ? onClick : handleClick,
        ref: ref,
        target: target
      }))
    );
  });
  {
    Link.displayName = "Link";
  }
  /**
   * A `<Link>` wrapper that knows if it's "active" or not.
   */
  const NavLink = /*#__PURE__*/React__namespace.forwardRef(function NavLinkWithRef(_ref8, ref) {
    let {
        "aria-current": ariaCurrentProp = "page",
        caseSensitive = false,
        className: classNameProp = "",
        end = false,
        style: styleProp,
        to,
        viewTransition,
        children
      } = _ref8,
      rest = _objectWithoutPropertiesLoose(_ref8, _excluded2);
    let path = reactRouter.useResolvedPath(to, {
      relative: rest.relative
    });
    let location = reactRouter.useLocation();
    let routerState = React__namespace.useContext(reactRouter.UNSAFE_DataRouterStateContext);
    let {
      navigator,
      basename
    } = React__namespace.useContext(reactRouter.UNSAFE_NavigationContext);
    let isTransitioning = routerState != null &&
    // Conditional usage is OK here because the usage of a data router is static
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useViewTransitionState(path) && viewTransition === true;
    let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;
    let locationPathname = location.pathname;
    let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
    if (!caseSensitive) {
      locationPathname = locationPathname.toLowerCase();
      nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
      toPathname = toPathname.toLowerCase();
    }
    if (nextLocationPathname && basename) {
      nextLocationPathname = router.stripBasename(nextLocationPathname, basename) || nextLocationPathname;
    }

    // If the `to` has a trailing slash, look at that exact spot.  Otherwise,
    // we're looking for a slash _after_ what's in `to`.  For example:
    //
    // <NavLink to="/users"> and <NavLink to="/users/">
    // both want to look for a / at index 6 to match URL `/users/matt`
    const endSlashPosition = toPathname !== "/" && toPathname.endsWith("/") ? toPathname.length - 1 : toPathname.length;
    let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === "/";
    let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
    let renderProps = {
      isActive,
      isPending,
      isTransitioning
    };
    let ariaCurrent = isActive ? ariaCurrentProp : undefined;
    let className;
    if (typeof classNameProp === "function") {
      className = classNameProp(renderProps);
    } else {
      // If the className prop is not a function, we use a default `active`
      // class for <NavLink />s that are active. In v5 `active` was the default
      // value for `activeClassName`, but we are removing that API and can still
      // use the old default behavior for a cleaner upgrade path and keep the
      // simple styling rules working as they currently do.
      className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null, isTransitioning ? "transitioning" : null].filter(Boolean).join(" ");
    }
    let style = typeof styleProp === "function" ? styleProp(renderProps) : styleProp;
    return /*#__PURE__*/React__namespace.createElement(Link, _extends({}, rest, {
      "aria-current": ariaCurrent,
      className: className,
      ref: ref,
      style: style,
      to: to,
      viewTransition: viewTransition
    }), typeof children === "function" ? children(renderProps) : children);
  });
  {
    NavLink.displayName = "NavLink";
  }

  /**
   * Form props shared by navigations and fetchers
   */

  /**
   * Form props available to fetchers
   */

  /**
   * Form props available to navigations
   */

  /**
   * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except
   * that the interaction with the server is with `fetch` instead of new document
   * requests, allowing components to add nicer UX to the page as the form is
   * submitted and returns with data.
   */
  const Form = /*#__PURE__*/React__namespace.forwardRef((_ref9, forwardedRef) => {
    let {
        fetcherKey,
        navigate,
        reloadDocument,
        replace,
        state,
        method = defaultMethod,
        action,
        onSubmit,
        relative,
        preventScrollReset,
        viewTransition
      } = _ref9,
      props = _objectWithoutPropertiesLoose(_ref9, _excluded3);
    let submit = useSubmit();
    let formAction = useFormAction(action, {
      relative
    });
    let formMethod = method.toLowerCase() === "get" ? "get" : "post";
    let submitHandler = event => {
      onSubmit && onSubmit(event);
      if (event.defaultPrevented) return;
      event.preventDefault();
      let submitter = event.nativeEvent.submitter;
      let submitMethod = (submitter == null ? void 0 : submitter.getAttribute("formmethod")) || method;
      submit(submitter || event.currentTarget, {
        fetcherKey,
        method: submitMethod,
        navigate,
        replace,
        state,
        relative,
        preventScrollReset,
        viewTransition
      });
    };
    return /*#__PURE__*/React__namespace.createElement("form", _extends({
      ref: forwardedRef,
      method: formMethod,
      action: formAction,
      onSubmit: reloadDocument ? onSubmit : submitHandler
    }, props));
  });
  {
    Form.displayName = "Form";
  }
  /**
   * This component will emulate the browser's scroll restoration on location
   * changes.
   */
  function ScrollRestoration(_ref10) {
    let {
      getKey,
      storageKey
    } = _ref10;
    useScrollRestoration({
      getKey,
      storageKey
    });
    return null;
  }
  {
    ScrollRestoration.displayName = "ScrollRestoration";
  }
  //#endregion

  ////////////////////////////////////////////////////////////////////////////////
  //#region Hooks
  ////////////////////////////////////////////////////////////////////////////////
  var DataRouterHook = /*#__PURE__*/function (DataRouterHook) {
    DataRouterHook["UseScrollRestoration"] = "useScrollRestoration";
    DataRouterHook["UseSubmit"] = "useSubmit";
    DataRouterHook["UseSubmitFetcher"] = "useSubmitFetcher";
    DataRouterHook["UseFetcher"] = "useFetcher";
    DataRouterHook["useViewTransitionState"] = "useViewTransitionState";
    return DataRouterHook;
  }(DataRouterHook || {});
  var DataRouterStateHook = /*#__PURE__*/function (DataRouterStateHook) {
    DataRouterStateHook["UseFetcher"] = "useFetcher";
    DataRouterStateHook["UseFetchers"] = "useFetchers";
    DataRouterStateHook["UseScrollRestoration"] = "useScrollRestoration";
    return DataRouterStateHook;
  }(DataRouterStateHook || {}); // Internal hooks
  function getDataRouterConsoleError(hookName) {
    return hookName + " must be used within a data router.  See https://reactrouter.com/v6/routers/picking-a-router.";
  }
  function useDataRouterContext(hookName) {
    let ctx = React__namespace.useContext(reactRouter.UNSAFE_DataRouterContext);
    !ctx ? router.UNSAFE_invariant(false, getDataRouterConsoleError(hookName))  : void 0;
    return ctx;
  }
  function useDataRouterState(hookName) {
    let state = React__namespace.useContext(reactRouter.UNSAFE_DataRouterStateContext);
    !state ? router.UNSAFE_invariant(false, getDataRouterConsoleError(hookName))  : void 0;
    return state;
  }

  // External hooks

  /**
   * Handles the click behavior for router `<Link>` components. This is useful if
   * you need to create custom `<Link>` components with the same click behavior we
   * use in our exported `<Link>`.
   */
  function useLinkClickHandler(to, _temp) {
    let {
      target,
      replace: replaceProp,
      state,
      preventScrollReset,
      relative,
      viewTransition
    } = _temp === void 0 ? {} : _temp;
    let navigate = reactRouter.useNavigate();
    let location = reactRouter.useLocation();
    let path = reactRouter.useResolvedPath(to, {
      relative
    });
    return React__namespace.useCallback(event => {
      if (shouldProcessLinkClick(event, target)) {
        event.preventDefault();

        // If the URL hasn't changed, a regular <a> will do a replace instead of
        // a push, so do the same here unless the replace prop is explicitly set
        let replace = replaceProp !== undefined ? replaceProp : reactRouter.createPath(location) === reactRouter.createPath(path);
        navigate(to, {
          replace,
          state,
          preventScrollReset,
          relative,
          viewTransition
        });
      }
    }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative, viewTransition]);
  }

  /**
   * A convenient wrapper for reading and writing search parameters via the
   * URLSearchParams interface.
   */
  function useSearchParams(defaultInit) {
    router.UNSAFE_warning(typeof URLSearchParams !== "undefined", "You cannot use the `useSearchParams` hook in a browser that does not " + "support the URLSearchParams API. If you need to support Internet " + "Explorer 11, we recommend you load a polyfill such as " + "https://github.com/ungap/url-search-params.") ;
    let defaultSearchParamsRef = React__namespace.useRef(createSearchParams(defaultInit));
    let hasSetSearchParamsRef = React__namespace.useRef(false);
    let location = reactRouter.useLocation();
    let searchParams = React__namespace.useMemo(() =>
    // Only merge in the defaults if we haven't yet called setSearchParams.
    // Once we call that we want those to take precedence, otherwise you can't
    // remove a param with setSearchParams({}) if it has an initial value
    getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current), [location.search]);
    let navigate = reactRouter.useNavigate();
    let setSearchParams = React__namespace.useCallback((nextInit, navigateOptions) => {
      const newSearchParams = createSearchParams(typeof nextInit === "function" ? nextInit(searchParams) : nextInit);
      hasSetSearchParamsRef.current = true;
      navigate("?" + newSearchParams, navigateOptions);
    }, [navigate, searchParams]);
    return [searchParams, setSearchParams];
  }

  /**
   * Submits a HTML `<form>` to the server without reloading the page.
   */

  /**
   * Submits a fetcher `<form>` to the server without reloading the page.
   */

  function validateClientSideSubmission() {
    if (typeof document === "undefined") {
      throw new Error("You are calling submit during the server render. " + "Try calling submit within a `useEffect` or callback instead.");
    }
  }
  let fetcherId = 0;
  let getUniqueFetcherId = () => "__" + String(++fetcherId) + "__";

  /**
   * Returns a function that may be used to programmatically submit a form (or
   * some arbitrary data) to the server.
   */
  function useSubmit() {
    let {
      router
    } = useDataRouterContext(DataRouterHook.UseSubmit);
    let {
      basename
    } = React__namespace.useContext(reactRouter.UNSAFE_NavigationContext);
    let currentRouteId = reactRouter.UNSAFE_useRouteId();
    return React__namespace.useCallback(function (target, options) {
      if (options === void 0) {
        options = {};
      }
      validateClientSideSubmission();
      let {
        action,
        method,
        encType,
        formData,
        body
      } = getFormSubmissionInfo(target, basename);
      if (options.navigate === false) {
        let key = options.fetcherKey || getUniqueFetcherId();
        router.fetch(key, currentRouteId, options.action || action, {
          preventScrollReset: options.preventScrollReset,
          formData,
          body,
          formMethod: options.method || method,
          formEncType: options.encType || encType,
          flushSync: options.flushSync
        });
      } else {
        router.navigate(options.action || action, {
          preventScrollReset: options.preventScrollReset,
          formData,
          body,
          formMethod: options.method || method,
          formEncType: options.encType || encType,
          replace: options.replace,
          state: options.state,
          fromRouteId: currentRouteId,
          flushSync: options.flushSync,
          viewTransition: options.viewTransition
        });
      }
    }, [router, basename, currentRouteId]);
  }

  // v7: Eventually we should deprecate this entirely in favor of using the
  // router method directly?
  function useFormAction(action, _temp2) {
    let {
      relative
    } = _temp2 === void 0 ? {} : _temp2;
    let {
      basename
    } = React__namespace.useContext(reactRouter.UNSAFE_NavigationContext);
    let routeContext = React__namespace.useContext(reactRouter.UNSAFE_RouteContext);
    !routeContext ? router.UNSAFE_invariant(false, "useFormAction must be used inside a RouteContext")  : void 0;
    let [match] = routeContext.matches.slice(-1);
    // Shallow clone path so we can modify it below, otherwise we modify the
    // object referenced by useMemo inside useResolvedPath
    let path = _extends({}, reactRouter.useResolvedPath(action ? action : ".", {
      relative
    }));

    // If no action was specified, browsers will persist current search params
    // when determining the path, so match that behavior
    // https://github.com/remix-run/remix/issues/927
    let location = reactRouter.useLocation();
    if (action == null) {
      // Safe to write to this directly here since if action was undefined, we
      // would have called useResolvedPath(".") which will never include a search
      path.search = location.search;

      // When grabbing search params from the URL, remove any included ?index param
      // since it might not apply to our contextual route.  We add it back based
      // on match.route.index below
      let params = new URLSearchParams(path.search);
      let indexValues = params.getAll("index");
      let hasNakedIndexParam = indexValues.some(v => v === "");
      if (hasNakedIndexParam) {
        params.delete("index");
        indexValues.filter(v => v).forEach(v => params.append("index", v));
        let qs = params.toString();
        path.search = qs ? "?" + qs : "";
      }
    }
    if ((!action || action === ".") && match.route.index) {
      path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
    }

    // If we're operating within a basename, prepend it to the pathname prior
    // to creating the form action.  If this is a root navigation, then just use
    // the raw basename which allows the basename to have full control over the
    // presence of a trailing slash on root actions
    if (basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : router.joinPaths([basename, path.pathname]);
    }
    return reactRouter.createPath(path);
  }
  // TODO: (v7) Change the useFetcher generic default from `any` to `unknown`
  /**
   * Interacts with route loaders and actions without causing a navigation. Great
   * for any interaction that stays on the same page.
   */
  function useFetcher(_temp3) {
    var _route$matches;
    let {
      key
    } = _temp3 === void 0 ? {} : _temp3;
    let {
      router: router$1
    } = useDataRouterContext(DataRouterHook.UseFetcher);
    let state = useDataRouterState(DataRouterStateHook.UseFetcher);
    let fetcherData = React__namespace.useContext(FetchersContext);
    let route = React__namespace.useContext(reactRouter.UNSAFE_RouteContext);
    let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;
    !fetcherData ? router.UNSAFE_invariant(false, "useFetcher must be used inside a FetchersContext")  : void 0;
    !route ? router.UNSAFE_invariant(false, "useFetcher must be used inside a RouteContext")  : void 0;
    !(routeId != null) ? router.UNSAFE_invariant(false, "useFetcher can only be used on routes that contain a unique \"id\"")  : void 0;

    // Fetcher key handling
    // OK to call conditionally to feature detect `useId`
    // eslint-disable-next-line react-hooks/rules-of-hooks
    let defaultKey = useIdImpl ? useIdImpl() : "";
    let [fetcherKey, setFetcherKey] = React__namespace.useState(key || defaultKey);
    if (key && key !== fetcherKey) {
      setFetcherKey(key);
    } else if (!fetcherKey) {
      // We will only fall through here when `useId` is not available
      setFetcherKey(getUniqueFetcherId());
    }

    // Registration/cleanup
    React__namespace.useEffect(() => {
      router$1.getFetcher(fetcherKey);
      return () => {
        // Tell the router we've unmounted - if v7_fetcherPersist is enabled this
        // will not delete immediately but instead queue up a delete after the
        // fetcher returns to an `idle` state
        router$1.deleteFetcher(fetcherKey);
      };
    }, [router$1, fetcherKey]);

    // Fetcher additions
    let load = React__namespace.useCallback((href, opts) => {
      !routeId ? router.UNSAFE_invariant(false, "No routeId available for fetcher.load()")  : void 0;
      router$1.fetch(fetcherKey, routeId, href, opts);
    }, [fetcherKey, routeId, router$1]);
    let submitImpl = useSubmit();
    let submit = React__namespace.useCallback((target, opts) => {
      submitImpl(target, _extends({}, opts, {
        navigate: false,
        fetcherKey
      }));
    }, [fetcherKey, submitImpl]);
    let FetcherForm = React__namespace.useMemo(() => {
      let FetcherForm = /*#__PURE__*/React__namespace.forwardRef((props, ref) => {
        return /*#__PURE__*/React__namespace.createElement(Form, _extends({}, props, {
          navigate: false,
          fetcherKey: fetcherKey,
          ref: ref
        }));
      });
      {
        FetcherForm.displayName = "fetcher.Form";
      }
      return FetcherForm;
    }, [fetcherKey]);

    // Exposed FetcherWithComponents
    let fetcher = state.fetchers.get(fetcherKey) || router.IDLE_FETCHER;
    let data = fetcherData.get(fetcherKey);
    let fetcherWithComponents = React__namespace.useMemo(() => _extends({
      Form: FetcherForm,
      submit,
      load
    }, fetcher, {
      data
    }), [FetcherForm, submit, load, fetcher, data]);
    return fetcherWithComponents;
  }

  /**
   * Provides all fetchers currently on the page. Useful for layouts and parent
   * routes that need to provide pending/optimistic UI regarding the fetch.
   */
  function useFetchers() {
    let state = useDataRouterState(DataRouterStateHook.UseFetchers);
    return Array.from(state.fetchers.entries()).map(_ref11 => {
      let [key, fetcher] = _ref11;
      return _extends({}, fetcher, {
        key
      });
    });
  }
  const SCROLL_RESTORATION_STORAGE_KEY = "react-router-scroll-positions";
  let savedScrollPositions = {};

  /**
   * When rendered inside a RouterProvider, will restore scroll positions on navigations
   */
  function useScrollRestoration(_temp4) {
    let {
      getKey,
      storageKey
    } = _temp4 === void 0 ? {} : _temp4;
    let {
      router: router$1
    } = useDataRouterContext(DataRouterHook.UseScrollRestoration);
    let {
      restoreScrollPosition,
      preventScrollReset
    } = useDataRouterState(DataRouterStateHook.UseScrollRestoration);
    let {
      basename
    } = React__namespace.useContext(reactRouter.UNSAFE_NavigationContext);
    let location = reactRouter.useLocation();
    let matches = reactRouter.useMatches();
    let navigation = reactRouter.useNavigation();

    // Trigger manual scroll restoration while we're active
    React__namespace.useEffect(() => {
      window.history.scrollRestoration = "manual";
      return () => {
        window.history.scrollRestoration = "auto";
      };
    }, []);

    // Save positions on pagehide
    usePageHide(React__namespace.useCallback(() => {
      if (navigation.state === "idle") {
        let key = (getKey ? getKey(location, matches) : null) || location.key;
        savedScrollPositions[key] = window.scrollY;
      }
      try {
        sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));
      } catch (error) {
        router.UNSAFE_warning(false, "Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (" + error + ").") ;
      }
      window.history.scrollRestoration = "auto";
    }, [storageKey, getKey, navigation.state, location, matches]));

    // Read in any saved scroll locations
    if (typeof document !== "undefined") {
      // eslint-disable-next-line react-hooks/rules-of-hooks
      React__namespace.useLayoutEffect(() => {
        try {
          let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);
          if (sessionPositions) {
            savedScrollPositions = JSON.parse(sessionPositions);
          }
        } catch (e) {
          // no-op, use default empty object
        }
      }, [storageKey]);

      // Enable scroll restoration in the router
      // eslint-disable-next-line react-hooks/rules-of-hooks
      React__namespace.useLayoutEffect(() => {
        let getKeyWithoutBasename = getKey && basename !== "/" ? (location, matches) => getKey( // Strip the basename to match useLocation()
        _extends({}, location, {
          pathname: router.stripBasename(location.pathname, basename) || location.pathname
        }), matches) : getKey;
        let disableScrollRestoration = router$1 == null ? void 0 : router$1.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKeyWithoutBasename);
        return () => disableScrollRestoration && disableScrollRestoration();
      }, [router$1, basename, getKey]);

      // Restore scrolling when state.restoreScrollPosition changes
      // eslint-disable-next-line react-hooks/rules-of-hooks
      React__namespace.useLayoutEffect(() => {
        // Explicit false means don't do anything (used for submissions)
        if (restoreScrollPosition === false) {
          return;
        }

        // been here before, scroll to it
        if (typeof restoreScrollPosition === "number") {
          window.scrollTo(0, restoreScrollPosition);
          return;
        }

        // try to scroll to the hash
        if (location.hash) {
          let el = document.getElementById(decodeURIComponent(location.hash.slice(1)));
          if (el) {
            el.scrollIntoView();
            return;
          }
        }

        // Don't reset if this navigation opted out
        if (preventScrollReset === true) {
          return;
        }

        // otherwise go to the top on new locations
        window.scrollTo(0, 0);
      }, [location, restoreScrollPosition, preventScrollReset]);
    }
  }

  /**
   * Setup a callback to be fired on the window's `beforeunload` event. This is
   * useful for saving some data to `window.localStorage` just before the page
   * refreshes.
   *
   * Note: The `callback` argument should be a function created with
   * `React.useCallback()`.
   */
  function useBeforeUnload(callback, options) {
    let {
      capture
    } = options || {};
    React__namespace.useEffect(() => {
      let opts = capture != null ? {
        capture
      } : undefined;
      window.addEventListener("beforeunload", callback, opts);
      return () => {
        window.removeEventListener("beforeunload", callback, opts);
      };
    }, [callback, capture]);
  }

  /**
   * Setup a callback to be fired on the window's `pagehide` event. This is
   * useful for saving some data to `window.localStorage` just before the page
   * refreshes.  This event is better supported than beforeunload across browsers.
   *
   * Note: The `callback` argument should be a function created with
   * `React.useCallback()`.
   */
  function usePageHide(callback, options) {
    let {
      capture
    } = options || {};
    React__namespace.useEffect(() => {
      let opts = capture != null ? {
        capture
      } : undefined;
      window.addEventListener("pagehide", callback, opts);
      return () => {
        window.removeEventListener("pagehide", callback, opts);
      };
    }, [callback, capture]);
  }

  /**
   * Wrapper around useBlocker to show a window.confirm prompt to users instead
   * of building a custom UI with useBlocker.
   *
   * Warning: This has *a lot of rough edges* and behaves very differently (and
   * very incorrectly in some cases) across browsers if user click addition
   * back/forward navigations while the confirm is open.  Use at your own risk.
   */
  function usePrompt(_ref12) {
    let {
      when,
      message
    } = _ref12;
    let blocker = reactRouter.useBlocker(when);
    React__namespace.useEffect(() => {
      if (blocker.state === "blocked") {
        let proceed = window.confirm(message);
        if (proceed) {
          // This timeout is needed to avoid a weird "race" on POP navigations
          // between the `window.history` revert navigation and the result of
          // `window.confirm`
          setTimeout(blocker.proceed, 0);
        } else {
          blocker.reset();
        }
      }
    }, [blocker, message]);
    React__namespace.useEffect(() => {
      if (blocker.state === "blocked" && !when) {
        blocker.reset();
      }
    }, [blocker, when]);
  }

  /**
   * Return a boolean indicating if there is an active view transition to the
   * given href.  You can use this value to render CSS classes or viewTransitionName
   * styles onto your elements
   *
   * @param href The destination href
   * @param [opts.relative] Relative routing type ("route" | "path")
   */
  function useViewTransitionState(to, opts) {
    if (opts === void 0) {
      opts = {};
    }
    let vtContext = React__namespace.useContext(ViewTransitionContext);
    !(vtContext != null) ? router.UNSAFE_invariant(false, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  " + "Did you accidentally import `RouterProvider` from `react-router`?")  : void 0;
    let {
      basename
    } = useDataRouterContext(DataRouterHook.useViewTransitionState);
    let path = reactRouter.useResolvedPath(to, {
      relative: opts.relative
    });
    if (!vtContext.isTransitioning) {
      return false;
    }
    let currentPath = router.stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;
    let nextPath = router.stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;

    // Transition is active if we're going to or coming from the indicated
    // destination.  This ensures that other PUSH navigations that reverse
    // an indicated transition apply.  I.e., on the list view you have:
    //
    //   <NavLink to="/details/1" viewTransition>
    //
    // If you click the breadcrumb back to the list view:
    //
    //   <NavLink to="/list" viewTransition>
    //
    // We should apply the transition because it's indicated as active going
    // from /list -> /details/1 and therefore should be active on the reverse
    // (even though this isn't strictly a POP reverse)
    return router.matchPath(path.pathname, nextPath) != null || router.matchPath(path.pathname, currentPath) != null;
  }

  //#endregion

  Object.defineProperty(exports, 'AbortedDeferredError', {
    enumerable: true,
    get: function () { return reactRouter.AbortedDeferredError; }
  });
  Object.defineProperty(exports, 'Await', {
    enumerable: true,
    get: function () { return reactRouter.Await; }
  });
  Object.defineProperty(exports, 'MemoryRouter', {
    enumerable: true,
    get: function () { return reactRouter.MemoryRouter; }
  });
  Object.defineProperty(exports, 'Navigate', {
    enumerable: true,
    get: function () { return reactRouter.Navigate; }
  });
  Object.defineProperty(exports, 'NavigationType', {
    enumerable: true,
    get: function () { return reactRouter.NavigationType; }
  });
  Object.defineProperty(exports, 'Outlet', {
    enumerable: true,
    get: function () { return reactRouter.Outlet; }
  });
  Object.defineProperty(exports, 'Route', {
    enumerable: true,
    get: function () { return reactRouter.Route; }
  });
  Object.defineProperty(exports, 'Router', {
    enumerable: true,
    get: function () { return reactRouter.Router; }
  });
  Object.defineProperty(exports, 'Routes', {
    enumerable: true,
    get: function () { return reactRouter.Routes; }
  });
  Object.defineProperty(exports, 'UNSAFE_DataRouterContext', {
    enumerable: true,
    get: function () { return reactRouter.UNSAFE_DataRouterContext; }
  });
  Object.defineProperty(exports, 'UNSAFE_DataRouterStateContext', {
    enumerable: true,
    get: function () { return reactRouter.UNSAFE_DataRouterStateContext; }
  });
  Object.defineProperty(exports, 'UNSAFE_LocationContext', {
    enumerable: true,
    get: function () { return reactRouter.UNSAFE_LocationContext; }
  });
  Object.defineProperty(exports, 'UNSAFE_NavigationContext', {
    enumerable: true,
    get: function () { return reactRouter.UNSAFE_NavigationContext; }
  });
  Object.defineProperty(exports, 'UNSAFE_RouteContext', {
    enumerable: true,
    get: function () { return reactRouter.UNSAFE_RouteContext; }
  });
  Object.defineProperty(exports, 'UNSAFE_useRouteId', {
    enumerable: true,
    get: function () { return reactRouter.UNSAFE_useRouteId; }
  });
  Object.defineProperty(exports, 'createMemoryRouter', {
    enumerable: true,
    get: function () { return reactRouter.createMemoryRouter; }
  });
  Object.defineProperty(exports, 'createPath', {
    enumerable: true,
    get: function () { return reactRouter.createPath; }
  });
  Object.defineProperty(exports, 'createRoutesFromChildren', {
    enumerable: true,
    get: function () { return reactRouter.createRoutesFromChildren; }
  });
  Object.defineProperty(exports, 'createRoutesFromElements', {
    enumerable: true,
    get: function () { return reactRouter.createRoutesFromElements; }
  });
  Object.defineProperty(exports, 'defer', {
    enumerable: true,
    get: function () { return reactRouter.defer; }
  });
  Object.defineProperty(exports, 'generatePath', {
    enumerable: true,
    get: function () { return reactRouter.generatePath; }
  });
  Object.defineProperty(exports, 'isRouteErrorResponse', {
    enumerable: true,
    get: function () { return reactRouter.isRouteErrorResponse; }
  });
  Object.defineProperty(exports, 'json', {
    enumerable: true,
    get: function () { return reactRouter.json; }
  });
  Object.defineProperty(exports, 'matchPath', {
    enumerable: true,
    get: function () { return reactRouter.matchPath; }
  });
  Object.defineProperty(exports, 'matchRoutes', {
    enumerable: true,
    get: function () { return reactRouter.matchRoutes; }
  });
  Object.defineProperty(exports, 'parsePath', {
    enumerable: true,
    get: function () { return reactRouter.parsePath; }
  });
  Object.defineProperty(exports, 'redirect', {
    enumerable: true,
    get: function () { return reactRouter.redirect; }
  });
  Object.defineProperty(exports, 'redirectDocument', {
    enumerable: true,
    get: function () { return reactRouter.redirectDocument; }
  });
  Object.defineProperty(exports, 'renderMatches', {
    enumerable: true,
    get: function () { return reactRouter.renderMatches; }
  });
  Object.defineProperty(exports, 'replace', {
    enumerable: true,
    get: function () { return reactRouter.replace; }
  });
  Object.defineProperty(exports, 'resolvePath', {
    enumerable: true,
    get: function () { return reactRouter.resolvePath; }
  });
  Object.defineProperty(exports, 'useActionData', {
    enumerable: true,
    get: function () { return reactRouter.useActionData; }
  });
  Object.defineProperty(exports, 'useAsyncError', {
    enumerable: true,
    get: function () { return reactRouter.useAsyncError; }
  });
  Object.defineProperty(exports, 'useAsyncValue', {
    enumerable: true,
    get: function () { return reactRouter.useAsyncValue; }
  });
  Object.defineProperty(exports, 'useBlocker', {
    enumerable: true,
    get: function () { return reactRouter.useBlocker; }
  });
  Object.defineProperty(exports, 'useHref', {
    enumerable: true,
    get: function () { return reactRouter.useHref; }
  });
  Object.defineProperty(exports, 'useInRouterContext', {
    enumerable: true,
    get: function () { return reactRouter.useInRouterContext; }
  });
  Object.defineProperty(exports, 'useLoaderData', {
    enumerable: true,
    get: function () { return reactRouter.useLoaderData; }
  });
  Object.defineProperty(exports, 'useLocation', {
    enumerable: true,
    get: function () { return reactRouter.useLocation; }
  });
  Object.defineProperty(exports, 'useMatch', {
    enumerable: true,
    get: function () { return reactRouter.useMatch; }
  });
  Object.defineProperty(exports, 'useMatches', {
    enumerable: true,
    get: function () { return reactRouter.useMatches; }
  });
  Object.defineProperty(exports, 'useNavigate', {
    enumerable: true,
    get: function () { return reactRouter.useNavigate; }
  });
  Object.defineProperty(exports, 'useNavigation', {
    enumerable: true,
    get: function () { return reactRouter.useNavigation; }
  });
  Object.defineProperty(exports, 'useNavigationType', {
    enumerable: true,
    get: function () { return reactRouter.useNavigationType; }
  });
  Object.defineProperty(exports, 'useOutlet', {
    enumerable: true,
    get: function () { return reactRouter.useOutlet; }
  });
  Object.defineProperty(exports, 'useOutletContext', {
    enumerable: true,
    get: function () { return reactRouter.useOutletContext; }
  });
  Object.defineProperty(exports, 'useParams', {
    enumerable: true,
    get: function () { return reactRouter.useParams; }
  });
  Object.defineProperty(exports, 'useResolvedPath', {
    enumerable: true,
    get: function () { return reactRouter.useResolvedPath; }
  });
  Object.defineProperty(exports, 'useRevalidator', {
    enumerable: true,
    get: function () { return reactRouter.useRevalidator; }
  });
  Object.defineProperty(exports, 'useRouteError', {
    enumerable: true,
    get: function () { return reactRouter.useRouteError; }
  });
  Object.defineProperty(exports, 'useRouteLoaderData', {
    enumerable: true,
    get: function () { return reactRouter.useRouteLoaderData; }
  });
  Object.defineProperty(exports, 'useRoutes', {
    enumerable: true,
    get: function () { return reactRouter.useRoutes; }
  });
  Object.defineProperty(exports, 'UNSAFE_ErrorResponseImpl', {
    enumerable: true,
    get: function () { return router.UNSAFE_ErrorResponseImpl; }
  });
  exports.BrowserRouter = BrowserRouter;
  exports.Form = Form;
  exports.HashRouter = HashRouter;
  exports.Link = Link;
  exports.NavLink = NavLink;
  exports.RouterProvider = RouterProvider;
  exports.ScrollRestoration = ScrollRestoration;
  exports.UNSAFE_FetchersContext = FetchersContext;
  exports.UNSAFE_ViewTransitionContext = ViewTransitionContext;
  exports.UNSAFE_useScrollRestoration = useScrollRestoration;
  exports.createBrowserRouter = createBrowserRouter;
  exports.createHashRouter = createHashRouter;
  exports.createSearchParams = createSearchParams;
  exports.unstable_HistoryRouter = HistoryRouter;
  exports.unstable_usePrompt = usePrompt;
  exports.useBeforeUnload = useBeforeUnload;
  exports.useFetcher = useFetcher;
  exports.useFetchers = useFetchers;
  exports.useFormAction = useFormAction;
  exports.useLinkClickHandler = useLinkClickHandler;
  exports.useSearchParams = useSearchParams;
  exports.useSubmit = useSubmit;
  exports.useViewTransitionState = useViewTransitionState;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=react-router-dom.development.js.map
