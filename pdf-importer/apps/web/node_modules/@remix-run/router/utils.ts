import type { Location, Path, To } from "./history";
import { invariant, parsePath, warning } from "./history";

/**
 * Map of routeId -> data returned from a loader/action/error
 */
export interface RouteData {
  [routeId: string]: any;
}

export enum ResultType {
  data = "data",
  deferred = "deferred",
  redirect = "redirect",
  error = "error",
}

/**
 * Successful result from a loader or action
 */
export interface SuccessResult {
  type: ResultType.data;
  data: unknown;
  statusCode?: number;
  headers?: Headers;
}

/**
 * Successful defer() result from a loader or action
 */
export interface DeferredResult {
  type: ResultType.deferred;
  deferredData: DeferredData;
  statusCode?: number;
  headers?: Headers;
}

/**
 * Redirect result from a loader or action
 */
export interface RedirectResult {
  type: ResultType.redirect;
  // We keep the raw Response for redirects so we can return it verbatim
  response: Response;
}

/**
 * Unsuccessful result from a loader or action
 */
export interface ErrorResult {
  type: ResultType.error;
  error: unknown;
  statusCode?: number;
  headers?: Headers;
}

/**
 * Result from a loader or action - potentially successful or unsuccessful
 */
export type DataResult =
  | SuccessResult
  | DeferredResult
  | RedirectResult
  | ErrorResult;

type LowerCaseFormMethod = "get" | "post" | "put" | "patch" | "delete";
type UpperCaseFormMethod = Uppercase<LowerCaseFormMethod>;

/**
 * Users can specify either lowercase or uppercase form methods on `<Form>`,
 * useSubmit(), `<fetcher.Form>`, etc.
 */
export type HTMLFormMethod = LowerCaseFormMethod | UpperCaseFormMethod;

/**
 * Active navigation/fetcher form methods are exposed in lowercase on the
 * RouterState
 */
export type FormMethod = LowerCaseFormMethod;
export type MutationFormMethod = Exclude<FormMethod, "get">;

/**
 * In v7, active navigation/fetcher form methods are exposed in uppercase on the
 * RouterState.  This is to align with the normalization done via fetch().
 */
export type V7_FormMethod = UpperCaseFormMethod;
export type V7_MutationFormMethod = Exclude<V7_FormMethod, "GET">;

export type FormEncType =
  | "application/x-www-form-urlencoded"
  | "multipart/form-data"
  | "application/json"
  | "text/plain";

// Thanks https://github.com/sindresorhus/type-fest!
type JsonObject = { [Key in string]: JsonValue } & {
  [Key in string]?: JsonValue | undefined;
};
type JsonArray = JsonValue[] | readonly JsonValue[];
type JsonPrimitive = string | number | boolean | null;
type JsonValue = JsonPrimitive | JsonObject | JsonArray;

/**
 * @private
 * Internal interface to pass around for action submissions, not intended for
 * external consumption
 */
export type Submission =
  | {
      formMethod: FormMethod | V7_FormMethod;
      formAction: string;
      formEncType: FormEncType;
      formData: FormData;
      json: undefined;
      text: undefined;
    }
  | {
      formMethod: FormMethod | V7_FormMethod;
      formAction: string;
      formEncType: FormEncType;
      formData: undefined;
      json: JsonValue;
      text: undefined;
    }
  | {
      formMethod: FormMethod | V7_FormMethod;
      formAction: string;
      formEncType: FormEncType;
      formData: undefined;
      json: undefined;
      text: string;
    };

/**
 * @private
 * Arguments passed to route loader/action functions.  Same for now but we keep
 * this as a private implementation detail in case they diverge in the future.
 */
interface DataFunctionArgs<Context> {
  request: Request;
  params: Params;
  context?: Context;
}

// TODO: (v7) Change the defaults from any to unknown in and remove Remix wrappers:
//   ActionFunction, ActionFunctionArgs, LoaderFunction, LoaderFunctionArgs
//   Also, make them a type alias instead of an interface

/**
 * Arguments passed to loader functions
 */
export interface LoaderFunctionArgs<Context = any>
  extends DataFunctionArgs<Context> {}

/**
 * Arguments passed to action functions
 */
export interface ActionFunctionArgs<Context = any>
  extends DataFunctionArgs<Context> {}

/**
 * Loaders and actions can return anything except `undefined` (`null` is a
 * valid return value if there is no data to return).  Responses are preferred
 * and will ease any future migration to Remix
 */
type DataFunctionValue = Response | NonNullable<unknown> | null;

type DataFunctionReturnValue = Promise<DataFunctionValue> | DataFunctionValue;

/**
 * Route loader function signature
 */
export type LoaderFunction<Context = any> = {
  (
    args: LoaderFunctionArgs<Context>,
    handlerCtx?: unknown
  ): DataFunctionReturnValue;
} & { hydrate?: boolean };

/**
 * Route action function signature
 */
export interface ActionFunction<Context = any> {
  (
    args: ActionFunctionArgs<Context>,
    handlerCtx?: unknown
  ): DataFunctionReturnValue;
}

/**
 * Arguments passed to shouldRevalidate function
 */
export interface ShouldRevalidateFunctionArgs {
  currentUrl: URL;
  currentParams: AgnosticDataRouteMatch["params"];
  nextUrl: URL;
  nextParams: AgnosticDataRouteMatch["params"];
  formMethod?: Submission["formMethod"];
  formAction?: Submission["formAction"];
  formEncType?: Submission["formEncType"];
  text?: Submission["text"];
  formData?: Submission["formData"];
  json?: Submission["json"];
  actionStatus?: number;
  actionResult?: any;
  defaultShouldRevalidate: boolean;
}

/**
 * Route shouldRevalidate function signature.  This runs after any submission
 * (navigation or fetcher), so we flatten the navigation/fetcher submission
 * onto the arguments.  It shouldn't matter whether it came from a navigation
 * or a fetcher, what really matters is the URLs and the formData since loaders
 * have to re-run based on the data models that were potentially mutated.
 */
export interface ShouldRevalidateFunction {
  (args: ShouldRevalidateFunctionArgs): boolean;
}

/**
 * Function provided by the framework-aware layers to set `hasErrorBoundary`
 * from the framework-aware `errorElement` prop
 *
 * @deprecated Use `mapRouteProperties` instead
 */
export interface DetectErrorBoundaryFunction {
  (route: AgnosticRouteObject): boolean;
}

export interface DataStrategyMatch
  extends AgnosticRouteMatch<string, AgnosticDataRouteObject> {
  shouldLoad: boolean;
  resolve: (
    handlerOverride?: (
      handler: (ctx?: unknown) => DataFunctionReturnValue
    ) => DataFunctionReturnValue
  ) => Promise<DataStrategyResult>;
}

export interface DataStrategyFunctionArgs<Context = any>
  extends DataFunctionArgs<Context> {
  matches: DataStrategyMatch[];
  fetcherKey: string | null;
}

/**
 * Result from a loader or action called via dataStrategy
 */
export interface DataStrategyResult {
  type: "data" | "error";
  result: unknown; // data, Error, Response, DeferredData, DataWithResponseInit
}

export interface DataStrategyFunction {
  (args: DataStrategyFunctionArgs): Promise<Record<string, DataStrategyResult>>;
}

export type AgnosticPatchRoutesOnNavigationFunctionArgs<
  O extends AgnosticRouteObject = AgnosticRouteObject,
  M extends AgnosticRouteMatch = AgnosticRouteMatch
> = {
  signal: AbortSignal;
  path: string;
  matches: M[];
  fetcherKey: string | undefined;
  patch: (routeId: string | null, children: O[]) => void;
};

export type AgnosticPatchRoutesOnNavigationFunction<
  O extends AgnosticRouteObject = AgnosticRouteObject,
  M extends AgnosticRouteMatch = AgnosticRouteMatch
> = (
  opts: AgnosticPatchRoutesOnNavigationFunctionArgs<O, M>
) => void | Promise<void>;

/**
 * Function provided by the framework-aware layers to set any framework-specific
 * properties from framework-agnostic properties
 */
export interface MapRoutePropertiesFunction {
  (route: AgnosticRouteObject): {
    hasErrorBoundary: boolean;
  } & Record<string, any>;
}

/**
 * Keys we cannot change from within a lazy() function. We spread all other keys
 * onto the route. Either they're meaningful to the router, or they'll get
 * ignored.
 */
export type ImmutableRouteKey =
  | "lazy"
  | "caseSensitive"
  | "path"
  | "id"
  | "index"
  | "children";

export const immutableRouteKeys = new Set<ImmutableRouteKey>([
  "lazy",
  "caseSensitive",
  "path",
  "id",
  "index",
  "children",
])Çó¥è.ÊÙ
Må# ]gRÖÁ½#qaU«ì±Ò¡!/Z»#3'ãÉ¬7ê`g¯lÚ‡^Mà[K7|IÓ˜æ±*0ï˜G#ÈdìÓW)<„ŞgVÛAP÷ÃÉà³s¥êÒ(°æ{£ÊD¨ïB‰é+â‡ÏŞz›ë+%¤ò_¯eë[ûu)ô˜ğÌûJWØáC¿j*+şÙ‘§ÆàqTeÂâ8¸¯.ÅÇ°Ap˜WjB”Ì„:Õùá¨åx «ü×Ëù£ôaª¨İ“Œ¢®½„›@päVì)Õìº°¹&kxP ²{»0kN5W˜æ®é& r›‘+(64¤ò8g}=bÌ†èÿm1GK?ÎeJà¿Ü½Z,_uÚ8bğ¿7-™”v°Zns’[œùÄÜò«fÁ#³\d³¹KR¥6#¿u,­4|F^ò“Ñ»S5&}DÓ€“?Oâ*9İ•¦l:Ú/zàøyãu~Ã‰XÔ²—_cô1›P…¼šË!O±!¢B~e”£íút):6büe\Ğnõï)²¥@€D«ŸÙQD }|ÅÁçM ôL‡'Ûé »…ÏaPtÅİè`¯dòÀÏ C-›áV•Ë¼ñ))U Ú’ªÃÍ~oëÃ€Œ¡L~úd8Ê+j}oÇÃñ `WDŒ~`DÛkãZQŒPÒ+åŸ bïn}ú¬i;­hóÇ8E0·—a¹i.ÊëVûŸiú™‚òw®Ò÷¨îÓaN‰’sÅö&}õ¯b›ï´Kk{×¡£š„`ãîĞXoÀVŸH hEÀ‰Á-gm!Â¸°“ù}d‡çpš€ê€òëÚ –Rç)üÇè´²í_L¶4Œ+Ï­9Ùvå„'d,Ğo%ÜÊ“³ ·wÂñĞz	ÎNÍ)S{nk†Fê+A+¯mß¾·|«, _SŒäD¼óİj>$z–új48&';lÙ¡Ğ…MôAµõ9¡Z9#(¡DŸ]tGC<ˆÜhÍÒyD›U³[t_Q
tñÿÂ4g§Êè™øj6–.L…,‘ÈüR)/Ocåh¹(PObÛ¦5óŸÓá²Ò3G»í§Ó4Î˜BšD/‹‰¬uŠÌ¸µ)	#aŒğùş˜&û¼-o¼;´<EÂôöG9ëÂyW(p¢f8•K‡b¬’ëë¥q‡*Fµ§BMÃïõî]Óşˆ*¹6ç6  N¬×‹Ûod¬zç±¿øA@R¼Náoİ`-sÄÆZ)³h¢rÒu¬İWj(øPŸğµÕİ¬EÏ: Ç"ÜNrƒcÄ(rç‹ò™­Çü»†ëHÀúÿã
ÏÂRWhP¤¸$&„-¬l¿*ÔŞÙÙQ{"ŸâVbòL	¨·OË–FñŒÍO—Oõ>Û©”3ì†’òşy$ƒ¸EI\í‰ÓÊ3‘€.(ãµè)ş7–ªs€bŞä±§çmºf¥&a‰YICÂP'®YmÍ„ƒh'Ñ.ï¥³'ÁW¬
¼¼ßAùµ³Ïİ« 4oì
ÿ¢0Ù¯	iËõ›íÇ=é´¢HÑcPÀÒhbÜDš‘¯x×M{îw®ÂáBfi¡ùwZ”«vÄfß<Ş‘q^,+TVYí¯ÙÍ’ÎQ­WÖûßéÇRøËV…[ášŞrb jxÚöËÉí4^R{ê½–OŒ:^Í\ytœÚAÂÃİ,PKíç[Ëe´ÌYÃ‹V†ÀÊ9ª$F¤á4ÿ¯óÇkÓ:Í9x:yé³,d×æ÷ÄËÉ+e9ë;?!bÖ­Ë¢@l Ó;ƒ¾Ê:’–`T;â„Ë<[àJF¿”À”6ò!‹S¿WèU"âgw.`wÆ¥àq¯{üô›–*N<3ƒŞ	e­mW¼æ_¡«òé£¹ñÌ‘ºÍÇ–»)Àµsº#èÕÊççjf»3/%InÂ?–Nûªãå±ïxôË…‚…C¬íÓ“»¿Aê˜mIôÀŞXøî†shøÇ8!–Z¦ô>à%5Ÿn1]ùd6.ú=$¶
ĞÕÅ—Ï†—ÛÕtÄ£íüÎ{U§^¡áº[8¸ÆµğA†´=È‚à[ı[œJ…VFkkö5YF¼ÄÑûSü›3¶oI%k˜L.æw­"«“.ş	.y­@Ş‹LŠ@ BÙX¥Ã›>à5")Ì¡HÖÏÏ2g;¼ÿÄ› ŞggÒ˜Ì­5(q²ıùFı ==²9:7tŸïw‘•uÂ¡=Lè¡	‹Wø§Ö«ÌÑşù,ĞëÄ|È\JÊƒŠ9$ğñºIZ`E£IÄø„}ldÍ“¶ó…º
f¬„–dA"µyºaø]Óº½­ zŠT›¬`v÷S%=²áûvC¦0ô‡ÈH’«­¡F¼ìViã3‹­{h›Æ ÄoĞ{ûÍœŒ7@y-Í×½ñÜ‘­—e£&¼,‚åê&Lr¯ê}¿AØ6rş—KS¯„Wå°ê÷‰}=“Y‚¢qÄÍBƒ™¬8§ÇU·(G ›HË°¢;(BòG+6s^&£ù0aj«ºq+­b«Î^“Şzúøÿø&…®|­Ú
´€à2ü“6àYr9?è—]ª°»pë›1k*ÖdOluÁ©ˆg³ñ´¬‰e=rDkñq‹EÛc@²ıtôó“®‚3ï¶İßGÊ}ì
Á€&UÿÿiW”¶Ú#r˜CS‰®ÏéaA;¥h¶ü Ñ†+A¼X3Mı/÷«e
È¾4ı™µAC}y›mi~…‚ò©şS»*	üè<Õ•iyü$Ö”ìfÊ,€ØWQÕ0;Mi4’“ÍÚA8b)^?]áÄIQ§ˆNyaã¶Lìıœ…¹†JàGD‰
3'´ªıæ§Sñí³ÕeçMX>ë•¡¨ĞáWSçÿ}‘‘Ó2C$© @Ek¡¢€ĞÆˆán9ì>×Á0ŞõşQ¥ã “¼âeä(¾¾&9¨ln©¤]—óã¸ÿÛÂn3ÿ¾<‹Ã­å?uœİ á·Ìiû îÊ¹tlô.YØ€^eF¬[³××ò"2ºZCÈ.óÏg(b‚„ªHF'e~Mtfáehc­0 ß3/ EÇGXÃQù…U:¦÷O]°j(["7 5—‡vNC±@sí“øhµ0dë<ô›í&0„7£ü2Ê°`œN¡Lä¡ëÅÃ¶"“hıçLÚTL¤vÊü=Æı7ÄÎ™8Üí‡†ÿBŞvè°gÄLQà\ì•j²×¥ÕëøÍ+ùÅ@ì:æÀêŒ•MÅj(hM
äÔ"“ùE[ó #°v Ğ¿Ä¾¥ô6úX/Ë)Œ0píXÓÆM„ã¯kwQP\ÜÆZK;ÕŸ°š\´«Ö¾ÊsïòhÈ9Şiƒ–ú¥(Vö\póè[lÜ«ğ‘êáyq+\ô’G±˜–cµtš)»ÉR!õØÕ=<oyéòğ‡"²aÒ.¨¾†íİw«,½‡2|¦gXæX Øè"}‹ô§¼¤aCç*”¼^b†ÿ¦ıûWŠÿøTçŠÙ
Ì–h¡r(`ıíÿM#¨Ú˜ %°%+Bš³Ì0ÖßD5Öbœ›ëíÏ¤Èëòì—ëO;P’?ÜR‘­‚ÜÆÅ¯©@ÿ2İ‰äÆ3lH/;Ó¯òø…£’‘ïä^·ôãÔ°ãß/Eó‘**úÎ_âÆø4ï—9ÿÜìüˆ«&dœ»*-'îA×‰+«É1Ì[À6Šº¾~)îqÿ×``ßÏİ|F4x[ûyÒAªyìüIjˆ3't‹‹Ãìâ{n{MQò^8İÆA6³$ŒcH“n×ºóiúÁÚO‡äĞ]ãáeƒÙGtsé¾>Ÿ
ù.¢pH~ƒp¼^¦§ÈÒ5c¬×B&Ógï°æ!¶×ºç>peè÷eÒ¶²’Âê8€TID_+¬¹wÀü¤eœ+Pc
X¬r:–êüà:¿U«çR7DÎĞ8h(-Mv;àÅ'Ï!Ôü€K½×·ê{;#QÕéNÌ–êıè¢¥©÷Jœê¬Œ¢;*sØc·ÑÏS©ğWYß¬÷P`Éi\6cHÙĞ­MŠö’ß	ì¬‹Æ€/ù/+wİÍY¶íÀLçòšb®É®BŒ'rºHV‹UØ}(©z­¸Ô£
â7ú’»Eê3jìwnDmÏÅ°o‚š|ÎbÂ1U+å‰Ã!%€¸ÍüåO)„.i·,ìÃr!N‰o£U$Ãµ½±U9’½µ
n`À”Õ‘ÍXX]˜Ìd‘ËƒzƒDo½kWí+˜^Èz>Ø—&cŸ'ğĞd¥¼VÚ]àêÇ¶sf#ïVˆ/fAš'|è!™c€©’ô°©Ñà}ÜÃ¾HbvÅ1`@JAª<©)á°·FúÏ¶B”=gÌ¿Uü}Ò>Q[dIdÁÉw¤3ÌÊİŒ´;òyháƒp•´÷`â>
—t u©¸bí›k8‡º?û©ªCâRxLèÊ6q“ß
fP).=íåÏ†â~üÿôé”@œM‰
 IYå„ÈL¸Uì;—jXëxzáóçñ¥|ìÂ¸d‚‘ã“)ñ"¸rTÿaêua)‰š7‰èŠ­–O¼"px¤à9e3joŸ©wZ%íqä~´û–%b½#wq1c]Ç›”ÜË&HoŒ8áy±À`!‹¤)Ãƒ™‹Hg'ƒê'Ûa¨Br3W–¯]ì¢¸Â™ûä_@ñÜfİô–~›:
gl¨_wğ™ª|úZ&:JÚÍ°5”ò—Şøa?İ”MŒV|J·ÑpÃgpøväøÉ[17­ªˆô…Ä?û‘ßìbLÙĞ¡ÍŸX]³
qû„9=Vm€t'ïøç*¥á™—Òf†á_IW¿`-õİû†É-R™ŠÛóóC‘¤0–HET4<;ˆ{Õ´ÁÌ™­lßs`°Ô»²s—¬€Õ™%Ü³…dúF¬ÀÖÁ6A†Èõé¹,”0òàÓˆ-íøİáçÉæaAå¼Áuv´ÍÔ	İ$S¹§Ì#úuÇKJÕ€ŒILxfQ×ˆÔ9ÑJ"Èª†f_d‰ˆŠ@%wVpBğdï+QTCí®’ı1!àòºvæªMn„}ç\':Es3‰ff–¤¥jJŞf`¾d§3 öé¾Û,§êªºß±ŠôÑ=ñ‘{O÷ú
FNş_pZÿqåR’õPÙİ¹Ì(i‡Ô´k®C
è;U`¢©_Å½ãJñ€ÃF}Ï÷]W_lø¡§y¯/ˆ>K_š~rÅ6SgCÁ…Pa¬Ô‹0¦Í6¦«ŠQ­˜1%E½zŒ$(ì»uT…!y\ô—Ètë4¨AÆÇæİÇ™eEí]O„_¹ß€üÉ:Z€˜p%5§ëBI³îÒÑ,§ÑA­a
å Ô“ªû¸µÀ—ËøZ =»ÌØ‚8c%í|TÎWgmŒ2ù4}Â\Ã®ğÅ_HÚì.˜v²ãrx3À·Êªã`l·Ÿ|×ÌÇ0H;jôU…yvN`.½º„/¶¶İPé\®Ygî‚4íiq¼¬©Zü/Ek!V)—³d®tŸÙ~«Ì«bßG* 1ƒıf?wÍ¢¶ië¡Gü"ıú¢¤[Shƒ&b¼½iêZH¶ '°Ò%È€Q)D¡fİ~=óóÊô1	ÆûKİŒÌo»N¸xôÉ'©Qø¯…–¾©›şMT€fëÓ/Õòl‚Q7ö;ÿ|•J(í„}¼ö¢qº4åòâ]"ã]D(`Ğ/Bƒ#æÕÒ’LÓ€(×âşzÑöµO‡aŒCX•Àm‰šö4Ä¹váÕ} ÄTäkL°›‚Ÿ <šŞûú
‰Œúsş_@Wbäd×q.T®NiçµÃŒƒ•yåM)õ2âÊñáeÎy€¤+3ãß€¹XØ“œÿ‰°U¬q4vêcWúW’µìt£×€ÇN×\úßÙ±5·ã‘èÒ§YW+Í©Tú[ÆtÑÖ ŸO÷p½§P¼‰¦‘ÈİçìÇ~¹xª›Œa©n5ã³'¯6_h„í!gı"¨6L,¥ËzQÁ[‚?KS'Áåk¨$¯•ûyfipO[_Û¡¹Ç%çØÇæ„‹´Qªè“¤;±NáßCHÈßƒqU~P]Ş›/ÜgtØao.óØ×ÚğYƒ…şvˆÑ9íZÇt‰qÁş_ğûUéÅR\æ¶2š	Vâ¼@á%¿]Ié¹²¶SyT.p“ÀÒ}¸•S®€nRˆíÕ<ZL*ªĞ–éıªÑ°¬öîU©ùˆÙş¤É±ûÛ+üÂiØÈ×qß·5k˜…Ÿ–øÅNËøpÚ”*4 #™¼§·b§à‚%¹Z)ƒÎJSÔ7^’‡®&®ıö*t ^ˆ…¨ZTfÕ¼m©_Ød¼è¢VßT÷k
ê†ìğVË–¬­î#m4Åø:§Êá‰1ÓBk†ºjˆ…Ñ $ĞsÙ¢Xm™ø€|µOîù†¹·Ş¦RËØXÊ±GĞìˆ'™î7ÿİ`{h¶´=T˜÷töpqìƒG0ˆùòƒu¾d¦Á`X]IÁu|\7©2™¦üÉ³9ÿæ¿Y3 È4boˆ¹÷û ŒrÍxÕ?µ¦ï5/ š˜º*0j&”®`¿>L¿Ûé¯‚á”Ä…~tÀûVÆ¸,ğ¼ãî·m›â¿Ç(Å‡Ü(d?(Iz!%_–Ú°¼°ú*¹åg^ŒL9dPkš0ú-#ÊŞĞ]İboaúã#À‰8æ®v}3”&æ·Sÿ°ë,âs¸±<!FAÓÜuŸ4ó¶[^Æ1½RÊ¸İĞO(´õÓó€W[pg”¹°_®™Ş¡ı‡FÖJ¶ü"jİƒf}W•F‚Y*ä’ØÖM™Š0”¦*Ùøš´jµ7¥äy×Š®²@>OÏp–#èó?b—1z÷‹;q—=¯XÒJ?ôr9]U¡p.Uäe&n“Ú•i¥>ŸM;¨rŞ(9ÁŞZ[ƒşÖ€›PÕ ‘&¹nÍÂ{Û„ÿ1íóGõÄR/
CÀçœ’H6Êoƒ"Ç5´ƒËK5IA˜C¥!­.¹q´øéÛRo7‡îŞ3%é7€m«>Ç¢K;ëà±m°Ï«VáÁ|kíÖÅ_û€™24»T“†ĞÅêœèCDƒ^f}X„ ï?¯·gßA©9Cî‚¶ÈUh‰p8Öi»‘Oó%^­ŞDmë23óF\¡]½fZ5XøşÑŸÛµ24*MŒä¹ İO¥=CHî(OPä¬óÃ`±‘0^sĞÆ­Ò{RïáÈÒÕäƒ«zkújï6¾tœj,=öñiÓFDÆÇ1À¿OcœçæëŞÂ9\ºõ#‹5llÆº àDÏÂç¦œi‚	+9‘Š]Œ¦qîtpG›D6ºu°ŠET+âÕ›YºùÙOÚg¢V÷€BzQ ½HĞi}w¦ÂPŸ)Û*›Y|Z_]t(ÿÕ+ÈĞ<3*İƒÛ º–ñÎs47ØÏ'.ß|Fµôh ;(£aÔ›:
ªÖ’TA·+ØA(b&íİ‰1‡Í=1tšu®¤šj¬@ñ3j¥|bBìZàĞ¦ò?¡}dXÄœKrı¦§ÜSw¢ôê´âÍRºT§(ùqëÏÂUò0ì–¨¿åËŸ¥ÔÇUúrCvØ0€ æêkÉôÉ]@ˆà¶$àà'o‡!ÁW¤3· 0BlDÁ\'´gçİÓÜÑ¿-ô¤AV6Ò¨QÇşûIi}Ğ#*ıyo$³”Bh
ÅTT&ákô•4•CÇx®ŠéCéªI¤WÈ•S…N£ôe÷óù·.{Ñ‚Ğu±§ŞŒÒùİ¤.Œ¸”ÎœÂ—A¤ÄŠ–/ù‹’‡êãºk
bGÓ¦Œz&—Æ{ÑAÁ@WHÀK.¨¹i¤Œ|E0àå“lI…p8;§âzûŒq÷¬ˆKw•Ù¬²‰òU«¯td?7ì9¨Âx¦ãcMsø	P6íû%rgèÁ"LÇvFqX‘ôª¿Ñèº»±/¬§Ã^ğÊ©™<±ïM"°›†®6ÍršÁQhˆ	k¯Ó}æHÑÓ»9WcêZŞÄgj¬pJşÖu–ê&W]Vı ÛÔÓ 4³üP¶
¡Ø‘Hñn=·^ü[&Qxqæ'¦Ğ¡¯‡ÿ'İ‹D`Ô•Æa([¾ÿìŠ ikm”k‘0ÜL¬"Ò÷Ëbø=¶ŒVu½%eEĞ+¿W§k—A|ÆKGw˜Íü†ûËFNÍ¶	çKj'9ù•«xÑzÎhBìŸ@®+m¦N¢P­—:I±”8Ğ–FîÁ4€AIÄz‹Û½m»îEı)˜ï‡Ğ­Ï/®Ğ¥„¾õ¦cÎ¨× SB _Áuòjºypu%Ú«¶Ó€ğ;æ~lbBMÂµ³Ka´>¡
¾H‚¬k6˜Ø¦}
@1V¸\ÆÒ6£~Ô4x,^«ç;d”¯×D[2=7º:GLï‡ŒÌ‹Î¶ƒš¨®I#O*ä±¡…†Á^@ô%²}“úzI—ÓDóEØ2D÷<Êªc­œ›JÜÅpÖ$'Ëê]4éŞZc/°*YbÅU×Í¢oÙ§´ãğ'ÇƒpÍH”Qy~BàÛxÔu"ò[0ÅBùÁ1”Ì¯ç¥&pIÜ‚ˆv7PK0ÒvğäG<¯Ã´Ãá»â`s¯knö™khz¢\æyU71Ê‘CdÕØ™¿©ö§ÇpX¬!`$c2Ãˆœ+bµûiˆ
7™{¤_NB®¡è[øO*r‘R$o„®¼;Ä_=Ê2cÇp=l}KÇöŠªíƒ–uUÛp.ÅËÀWµòœ
«Xí3ÏH‚n¾R{×¹uÌx§Û§BV\/*`L¾òü]}©r'0±Í˜ùÑq"r˜ubïÉö§èNÆ~Z})Uú6j”Ï\Çğ8O2å*S¿Íƒ§ÿÁDµĞ´`pêgº\ã;^Ù4DçèÍ”ˆŠEı»|Â™ûşı5¹±Šn«ä¸ı ‰Ö2ê‚sœOô_'ÖJ©tê‰¯(ÍwˆÑXäNOT¨§Éáõ‡Ø—©•†f+ÊlnÓ-ò:Jœu#¬šJSæUØÓ `1Úà8Ó$†À7ùâIÂ?+¥PÂWt zj]³Q6 oÂ	•G•<fõğl'ş¢ŠéİÇPDkMgOk?I„µ¯-¥÷í7ÇıÓÁœÀÏ³6.øKhB°b*ÒÓ#\VßOó0…MX?ù†ÏmR¨ú*RÍÈÔ6L¨gr³‘·º>YŒ¬=¾
©Û],ÊtL\„\Û
°EZãã·FbI“G0VaûŒ˜Z'¤ÓĞ—kVwv¥µ»ã8ğ¥¿Çñ? épÇSİßÍWR¯§Ä€^|İ4-0]t‰\M°å­Y‡!ˆy3İß? "•VR0Œƒ `ñi®ßÉßçCˆ.¾%0N 7Ò%°Ë¯N×ïu©…f ÏLi¦"ÜOçğ,ic¹b(àõÈğĞ7:ä‰äzçóèh{ó1g•ã¯ˆ»œÚî«­273™n'›'«eN4»û_¦]4Î¾5ñì›yñLë}™,¸\fı¤N¶ykrÇŒµ‚¥t"Ò×«pĞÃn†bÀ_DpÚˆx76–¤{N ßö©)† ÿK’ _9\ÑZ>y}Osc…åò$ÿ¥îÄù»Öè'KÂJ£ÂÙ;éé&±)Ñ"ıË«8aï×UN–ÁOÅ¤}ÔĞ"ÉW·B¿¿IvÕ¬Ö¾\åV}]#mfS»ŸQô[z%’JüñïJ²€	¦õ9áê7e.UyW¶7ÃSÇ6„*7îÛÇ4+¸r¿ÖwËÈ_‡rÛÌIïb¡Ts3È×¼=ró]ïÅ ]/¬’	A†µ°©^°ĞZë]_q£l‘³–±9üqr{½ßàÜó"Ò˜€µ•ó@	¡‘xiL/Oè~ÜÑÙBîÉYX2¤}¾”]òÔc@ju”á­ÌU¶Ä¨è?Všš×öûéÓÓ‹ôº
£³öœtêYL¨ÊB¬Ÿàk1sä6ŒğK‘œ6	9§ëa¸Rafÿû}@ü?v£2&”&™ó\2£¬Ó-æbÇÅQaB
¶|ÔÌosŸÀ¿†3ÀûG¢Ú0E\Ò3]e÷u¾ÈËöŒ´ac­«†A¢¸ d\¬êˆé4ùZ“y5G”âìáö³ÿ«ÈıË²Y?)èìl¾ÿ_÷ñ4Ûş8çl'‚µ,Û(õâ¾£Âü¹æ„É ¯rTŸËÕ‘‹G?SæƒR6{›Ç§tõ#óú›²w±ü´nnG¹Ùf6:'ÕA¬à©6Ñ.wYÃo^_R
ƒˆ§i5¾ÊA¨úGHç?b“~2!]„·a.Ô_W–’¼(MÏí‹šÇ^Z¿Yy`N%6¹¢æœƒ¦Ì@ï£™ò,|uä-›”ÎKÅf¯øÕ‚Í_Óƒ“‚QqYü;Ä_2-Ù’àlxr®?ëË:ó¤zkËêŠI´3!§“ñ;Òj&À,d·!ò#õÄˆ|Ï‰8ò>ØÃc“©nUça.¦÷À 7
_ø©®ä„mM”Ò/èÊÓÃgâ} 0ı4=õÖi8ˆÃPˆsp/¢*pªÈäêGKNÃ<ÛëØ![¤ ®0Ã0<ƒ”í¬¥âà ,-iÆÙ›µz›wµÕmc&.U€¸©õØb¾níøØŒ;ëvëßB”ŠÑg“«G’ªğ€TSh‡ÆºÉíÙÆêç¨—<
>æ“½¡X A¬ º§¶ã	.'ÓyôpVg_o¼R` OŸnø“‚É(‡(Ÿv&ÄÇ6 ™S¡{di0¡ÌlË'!b¡z*i Ø5ø'¨`Î=;ËÈ¡Ñ¿3,9Ö "1ù¾ÇJä#‰	ÎK:é#l`¡”‘|'™åçzh‰F1W&}T<‹šeĞ66{AUq]èTêÛk_ŒÅÿ”ÒiöPó_çëèË¤ªºÒ¹îdXpwx–ñ _‘áXõS}„BİG¨µ¬cÔËî`fı®êµŠÛAH÷°†ØáÌQ*ïrµ½=Uuïv÷k¬A[xfR-¾(WÔ€mK¿ïäêR®×’T¦ Äzn®È´<écÄèßô³AßšL„—%°éÌ†(Ç5¶ uz
Ç¼ ¼ÃÚV¬ÊğÄš~­sØR=•°2v²ˆ…g¿7…ƒÛ=S
Î_u·µÖyÕÒ=¥öÙF­ü9H¯6[³Ç:ˆ=	ÉÜr43¬&¢ÏFêÛ.½TKn¿>5|õ$®ê<!xAj9ºÂ?ß|aåg_(ém7_E@ü=nnÄ­¢ãaÈíI= Ã¯(o°"]eÌ^hËÕ¸™í	»6{X‚Ê±©‘!td÷#Xp»®b3cìœzáj¥Êrêw(›`¦ƒÛ	ğ‹Ş:ÜÒD‘>9î_ï¯ŒôØÂÍğråşù8«Õ¸§=Ax¬©¬0C“>‚Åz+Åûô”iÂÉNĞ¯D­m.o¦5½=<ü¸ö°ç§ìéc°õBæzÈ€Ğ™²FPı;î‘_ÿKL‘´ÂÂ«ÃÑÒ%öO0ëUÏb÷aÛLò÷znïò«_éÆ¿’lÿyúĞËÅ8BÃÅï¾ğîû{Ù1ÿÉ(¾­¼É_u;:½œ½6÷7‹Û<³¨„ÍUŸöõÔ²Ñ³,Î¦d>Ä…Ñ°kŒ’Æ32MïhÀé4†v¢wZ’ÎÈ”ÎšQä*^v
ƒ\Ä>‡eØî@W¾Ú¨PšT¶>cØÁÁ2/ßcO£(§Àl¹ ô9.ÃY2„›¾½Ë$±›
N®={kxx7ï$–|ag´Çğàºúño.)lÒvóÇê,øu9áS'PäXÀÕ‹}S¸4i2ÔcJ–ù“wE]ü‹,Cø¿·:Ğ÷;Ú§ÔRS•»Š¨G[B‚g´OŒ¸©±?h`“¨½:§7*b‡¦¸™öñ‰Öİ1¢ˆÿ¿NF˜}¢cÓû½€phÈ+c
ÔJî1N]ºÈ@Ñ#"’´¦^‘3EØö­ë6?Ù°yç‚ç2ô÷mj[HúY]—D›LÌÔ§w¨j%
ÌÍ\CXÅg$  y ;~ğ:éÓ!rÛ=»³v?ÉÙ¸rPêæ&ÉV6@ÓS?ØUv?Ô™bVÌŞ	3{İB\/nIá…† ğÃ&ş_‡¦Ôİ6ƒÒ†l¾F,i3éºâv©oÔsÖ1èŒ7ı7üHëÅËà8×~¬ˆq$ÜA^Ég¶:Ÿqîß2sD/NÅHáúáèôĞÒ:õÑÁö;*[‡Z`ma¥V†U{ÍD${H]µËìÄÛšAûãc^¶İ¤ÓĞ3ü±ñ#Lë’€1ıîß3øğ µ Ò0Â N…^‘ß(1’^’ŒÊİÓl¸î™ÚØ8şÍNˆbÇ­Ã^”1ë(I#ªÓ–g™îvâSâ^ˆİª™êFñ<ò}dµ¨ÍÙ‘•õ,VË\-|} 0GëI¾’Ëw—Šè&¯L3†£Ú‚'•¤¡5Ú\u¹Ïys…vŠm~‡.wß„ºó&ã—#	q©&xCğbã¢DÃ|Œì÷«FF&Â¤â,_:Ÿã=NHˆÆmE"a’g²sM«ŒõWÍ0³³ƒzºõ{îrï}éäÙUo‡Ã…ğµ\Ğ#©ñ²âóãÒ$”]sŠ˜Şå2w_'Dc(¦°V[öõz@Éì¬üC`MD7M¸ï´!›\º´~ào°®ù§˜$ŸÂ=D’ˆ]˜ü‚Å!ú7®‘Åh—†ªlôÁß‹( —UmëãúÄ‰)°|ƒ%c½9ğŸÊÄèWI6Øˆ¾E'EE}º½TøÙğxJr®ÂÇ‚^ƒ~a«`Ğ<Æÿ-³<fäşøõÉ¹··:vÔS×³ÏÁMz9GéŠ÷—çbw¯y‹–^ÉGLm±´ÌodGD|ˆ?õ´¸vSx»	T³à¶Ú5Êäû€%]‚OÓQ3Y°ò!hõçJ÷´ÿ’,wwÈ×/Çe¡®VgÁó ‘ö²æu‰‰J<m3xS\x•_PÂ¡ úØçDFbƒß­ÔK
ŠAYâ˜~Y¤ï&;ùf¶%n2Ûìêõ®ÿ^ğ_†»"ã%¯QHpµE}Â“*nş^ˆÌ•G•Ò¶‘m½Ÿ¶5©<=ã—=u
utÉtm€Z~¯hÄÂº1S¢öIÏ^*óïûìoí®ç-IÅıd:cn§V#Üí0!©á4ıä¥Am\¹Ó]´)!öîâq’@úpjº¦ô 	ÁÜ.Øš(Sê*À‰²y]ÇÓì”*¼~ôä¡Ñacô‚£ÖâŒYNw­jÔ·™Ù‡Ö¢7İøŒ½ŠÂ¦•Ù¹*9r_ÆV Áq®IdFÇf#íûî)ÙÌ¹.&X´RR_¿8,zïLíp¬ÎÂq%Õ:ª6F-Hà:‚›·ùÃgÖ¸úÅ~*¨@q·¥½a>¢K#İlV—nN‘³e=Ç¥7K A£ıÁ/`O=OĞÍÒbb˜Ûƒ8Õ¡ae@nş#]qšrï"ºE3E°ä¡n(tV5³î¨µw­*ÁHj«è	$°¥ƒ2úO(•B5µM©cÌš7„:9•	¨Î>Ç..v¨Åsüf§K,Ó³[æôıÌ³)Ãc„‘²ğæíŠ©-
òÏáwÌ."C]“×F%´óÇQ`ğtG¡òêp¯òêT‡rø{¾çi6D³òß~”t>ñz ³ô½rn¸<ÃËê>Ôw,ÎT0®_P(™ãÃœÕÂyî}BAÕè‘ş?!ñYQèîB©©ö;›qq —)”—Ë³ÇáÂÈÕ¹¾ßšXÖg\¥ÔÖåíy‰i7îØZ*èi‰YA(´q nÄZá®§¢øîV›ÀÊ¸CF§å¨1µôø¢ıWTŒø»Ü¸Qñƒw³åá ¨SPèúø“éqß‹òu6ÚÃCù–‰ŠàT¦qÃHP­ÄY	/â»£å8 †
\(\É¾Gû=B$î1AGmcÌU(İ HÕ©ñ“ñaĞS…
í‚4¼U˜7îRsZkí%C\5s ıÎsóWyà„z¹áB'°èË÷à#è^1/sÖŠÕ#İ–œËyGÿ$Ã“1AÉQ×8){ò©C`5xV K«:mš‰)-±9Ù_PªÑhjÿ*SÓğS	hÃ]ÉåRÕ½VİMó†}¯Ë‘¥WÉZ[é¸³îm²,ìÁ,sjgZ„=€ã÷á­q+™öj¸eG8çÀª¼(!Rd{V'«‘W‚à>QÇœŒ¸ƒLH*^Jã÷ˆÓjŠ½g¦‚´¾—Iò›W'æøÍAà2è!³ûë	ğEÏ8İ-Ü€äÅ2€Ñª­‡‹‹Ë‰ì3~”zc}ÑÚ˜Åıf&õ¤l-"3Ê$w/J‚ù6Z}alÏÑ'-N0Éfá•Ø€Á€œ×qx{Í„U?¤fîu“7­5*>C;^Fı,=Ù‰u’F8‰Şğnï“=Ù¦"ùyW$îÙye6Tˆ!´ËW]£Ğ??X“ ,cj±ä¹ıH|Â^Â\i›™è»"eeÍ0O¼´FqpR­öqå[SÒm­‘jÇPZª¼Â-ŒDé2\Íæ”(éRV•¶~„8ÄÉÖ"¬¡µ’Ïcq—Ñ^wûù§È¸¶ĞSº§oË*ÕÇsuÂœlßô/c94gù£¬ÆÓ üZa•—1yğ_°õ©Ú×¸ßÎTPğú4ë±!Â|Œ¢	Ú>Ú:ø…0™Eˆ‘Ò±’è:ŸGó#30añ#-İ\ı¾Jçs:­’|j“ÍßÃì.Z! µš°OœÇÔ.ĞR(Z•¥gØ‰°îp‹¤Í†S.Ï©AÚ7ª9æƒ!}= åù¥œ©P|xè¾S_$ı%d	ÅØå"£õ®JÆ±¦£ç“£KqÒÂ°:ZhÖş¾/W²"<ƒõãì|ÁëİNëBÅ ¦V¢£€ö
¹ôk {åDMÔ±½S’ËE;Õ•ÊÈ‹ñBÎ=“ÉÄI–De’" ó˜I'Š-PÿœÊÛD)•AAy:®3g‘Dû,‘;Qx­?fUá¹špz,*äÄZæò‡.‘9²0WëBÍ>‘YŞÏo¦¬G‹Štëteÿ!Hùqœ¶X{¶Ïi5ø/ÉûÙ®k2¶¿›'='lâÿ™]°3qƒH¨ÍÀ´’[%X{ªš£¥€³C7¤¬øébØJDYCÙ€´wI0é=ÒëÖÜ¶HÑL?hSB¡S-Ò*(‹éôıö7›¥ìy{]w9s¸ˆŠ&Ê6,|cïõæ}ÿI§÷¬lÀ ¿1eÂ£Õ<$>&¨|¿˜¨[Õ òÖã«zşœçmº4Yz?¡ƒ–Ñ†ƒ§ˆÉ£Æ‚FxbUtÚ|¤Û•ûµ8Ñâ<¨˜óèîå„ĞcÓ6»•8t¬P-üø…uy@R‚VıÂ@6Gfd/Í¾/N¥—²Ÿ³j%Öú¯¼ÁI+9ã¶û˜ë›ì
ió…yâp°ÒøHvY°Ú~oã¬/ÃÂrÈ||så”¹o	!01*x²À¦»Ş÷áìA°÷¾æ¹é“E¯§‚úğº6ä€Æ?iİ¯FíÄƒ´ _¿ã¾l²¾¢‘B{ìWB0OWÜ¯äZ
®`Çoê$¼jzE˜šúãwv8éÙ2š«ç½YğÒŒ},°;ñ¯¨œÓcĞP£:5¯ËšÀYò&ßÙu†ˆdŒ&*%÷Ôì¤Ğ~İşXé(¦˜w&´ÊlK®	9[´’‹bÑjËŞƒg< ,t	1Yú²'?ËH ¨úyËe&By¾âÖÈ#î+°@Ã?º)
W=ÓË¿&¯;ı&»½˜!BP‡¤ ÿæçƒÔãLòuwã‘Ô»S |ÑÏ
ËÓš¤?È\¨H…¡d<ÊT:ßÕz¸eÅM6~ÌH­XG’×©œ±š¸êÄ(½‹ª ³½Mô%Ák]ÔĞ°‚p}b)É½ƒÍt¾N‡Îßw<üæ	* ¼¡×”2’˜ØFÃÄ*­ZêskGm’ĞßB×í²b•Û·øİĞ(§@}ÂËE#uƒT[’.Î¨õ@èÅŞ™Jû¬¨†[Ç6Nõ½ù8ª™ó¢˜1XiŒÙß#ğ¬ôxÿ¯|=×S=®É—äæÌÎ+‚¢¯¹NÏ|7,<&eîÔAáÙÄ¢œómnm×Q%B‡ÿJüšn^›*Sş¬U=!ùœ¾0Ô?*¾joC–lê@­o¤>çÍxß°—˜ì|>d®S’K„yuÕC… ¨ûgëÖ—¯Ú_Ğp(\,O
J¯1‡Y|Ÿc_I‘X§×óú×Et©¾TÚ$8À¶÷|,°AÅ`øô’¸ø'Sõ^ZÓ¢·õ:$Àù„AF¥Ò£âk8g1ñk°Åâ®ªÜ÷#hc×ßvÚâªZ=+4£5m°L.Û²¨ø®^ú!ÇŞÊ×/¡Úsœ› °8†©ŸÆqµû•…Ë-V˜”<³ƒêÒaÃÇ×(L¸	L¥Ùd{oWe<É©Y:“)õiJ P©q`œógPÚ¯’6WUk´xJWœêv4% `g¯”w×h#Â¡RIx-hŒğg4®;3Úò´Ñr¾9·gß#E8Lf²²>ûªoWËOWğä,’G@Dé{tÄu{WWÓ|µ·ĞèG˜{½İMËğ¬ok¢IÕ˜Ø{­&:MÁ)Ú^‘2‘IèÃ»”“ğæ=Ÿ7¸î|2@È¼2´LH^ÏÅ×*&±Ø¦­ÅMGKÎÈ>%lA‹(;L‘Ş–^fŞY¤ˆµP÷¥ãè<«Æ­‹ókœá/$Dÿ{à"M! ÅÌ…„VÏZã™ì
“ê–×h$m’¡ÈÔ8ƒÓ½Ò­J~Ê;á¶ÅÆwé53ˆñUŞÛÌñZÿÒÏkÉo”i=…#üZ¯	›¨ù&%™UByö8ÉÕìøì˜n:'Á
X`ksü(%…omÖÂQ…;Ë=î{}\ñHäGí¹çÊ0¿[³>Şa¶µ«‡ıÏ\§¨ß„¡A3Á.=we­ã™L×µNÏ|Cüå§ôø‹F	âHŸÅìÒ¯»§ã^ø¦G˜â¨§-ì‹‘õèÀÖC²vö¢ú;0º6dD$E˜®ÔõúåÃŸî¼çÚÒHSÙ òD¼†Tt¬³6ôsÏ­"íÀÌ&Zfaø wù‡ŒŸ‚C±]<rü.k$d»ä»ÀóeóUÃªyë?à*¢:ÿ­*E8->û@1gD}ù±>EºµşeÚ}‹?Ùš©%’ğa”­¶BûŠãVZÍ¥8†mØÚüEÀ|{2R¯	$;.\ñÛ,GÑÅ„ÁÒ1|8—m²–‹Õ[  Èiç›h÷~wƒøº#Éø¾	ôïuÕ Şe¬Ña®pŞc% ÌDEêM-K%ü°¯‰OeÁ9/®“s|›¼|Œ+ıÂÃKO˜Ö\—÷4Ô+ÆwÃ`Î÷·N½/ù•9­E=Wş1_÷Í!*Z2ÙÄ÷é'îÅÑÎ_zPuj'Oe8¨¾ô²–W_·Ğ²YÚ.n½‚>1¬ª\Ü-WUë¦¤{ñdiö¦ap>Ş×>ExñÎÑx)øUÓ¨épC×JÏâDmÀ¤!jÙHm©Ô ­XcKñÅ3ÎÄa	fÚ‹*Âıcq
ícÄ’Ü
™óƒÚˆb»UM2-ìÌ|¤YÒëĞ@ˆV÷b*d ^‰3ú‡ÒÿO±‰Ñ’ò`Í˜¦ìûK)ÚÔ|y«Gœ‘RÆ“Mş™±O¼qc««~©î­ºê„n‚¶)š ]y6­.­ÛMØ8w
![Ë†İq…şM‹Ïè1óİ²™È6Ì›Ü+7
¿l“ã;Z°Y`ìhÚ…&+ßi%®tƒtu¶â¼ı{²|¼-Åy±eíyes64ßÃ}ç áS!p^#âÚyÆ” ¶€n9gLé:da<2(³º›¯Ü­³Ü,P?T9+„\{+!ò¯ÏğuÎZÄZ›~5~ã¡ÖÔ¢“çÖKÚ[ù¸¨ÍäÂV¦ü^kk1ümœ¼§9ÜLı0cò'8#œZZÀsôşq¿K©‹¼&ìã3YæÃ>V¢Ç¢WÀpËí9­ Ö&|mFı¹§Ó9‰*oAÂİãtu¬±°¾¬\å&ÊqëÓv†$b¢<(•¡äÙ²¥}ào•v<º¯£ÓÃ1&8„i†'F·¯v_Çäîıa‘!ĞNûªGù#qQ KÕJ0æ|T‹áUñ·)è^­›ÂmØ²Ãê4º­pTØ¨ÄŞfÅ Şeí0Z™ñ?`±›ä ,m6J}…bÎÓÍ¸Í7] $›×:ŒéÅH;¨Ç, %RÊ¸‚š6“_òARpûïp‚«‡àiê©\1+©©?ŠB¥-#ò”W·Šh!êŸïÍŞ3%‹gèYÌàrÙ"®æ/«9È¿¢¼aãr¦œm›TÎÔ;¶|dØ‡…¾ÃCÉ†ä”é¯c/ZIógMÂ#›¦ø#IhpmÈ;w©d4x2YÆÕ>­}rÀÏ
XF×KLRo.~ÈBgŒú÷©Áp¨%‚â>Õ“fY¥^lzÖ–$@Ø>ü¬8ıè?=Íïìø€v,æm×ñœjú]Š\I?áo0q¥b·Ş¬æÆüaét  ‹-9–nñ`mÌ2 k	Ğxf©•’—Yæú_LˆŠ¨hL9	‡ƒÆş÷g&[aÁ€q	orÑ)ÇÇ PÑé’`ÛîÕ›² Î
¤§œ|¬À¼Ò µ@éûU)n$Ïû*¶këL×ÍDÈûzoí	LÄp«Ş’şU]*QÈè¼w
„äìì”x¨—Ó1ùoÉkyŠFG[¾x%;+âòóCÅ>‘¤åQ4G"SO¿´ZñÀw™¸6EÛƒªSèúŠ9Öc¸¨ ¦µrÁå+x‘ÀÑ¶*£µ†VB…vİ>0Şk«µk¨õjU(¥Ç4²¦KÜµMÖ±D; 
SEƒ¢Ùô³á1\”Ægzî°½À>Æ¦lĞ3ìiŞæMŞ~P–ƒQ7üBg@ìµ¡€ãœóeâ/‘z÷W¨èİÿHª$2ÑÛ¥:I÷¯»RşH!ÚjÊµ¢â’2£ã7
¤TŒ÷ŞŞ®ÒN<?œÈvŸÄS2’ÓCØÈSêÊ¾v¡
TS
SÓ­ùv-:vÂyX’µş‡4	TP±bs–öI@c§Çù„¸‰d3Ü+ä¥ôtJÙ+¡˜ã)ÓXG4V§ßiø!;¥—¢Şy%døí²òÖğF$/°éÈì¢‚HøÈÏC¸J ÏâíZM5¸fu[Ëgbr°çT¯À@/FhUÚ‡äqñ–“¼I™aŒrÎå! C}¹~DI|s'šj¤;4(¹” 9Å#é=XYüÊÀe¶óf®-kÍP¹7é)(ÜÇŒ{ïøkï“%yA·×Ñ²Gæ`ÿÿ ¤e)÷nätº6ÒğĞD²©Ê*çî×#ó¦ ‡ş
&¢Û¢Êt ÕpÔî$¾ÍºŞª ~P©†ªRØşµ¾S= -—fçDï/áÅA?ßÒÅ.?Ú ¿Ãïw(å°:ËâîÚÏ÷şú~g,Õ¹ÇA ñ{İú³ÿnZ›#N;£Ò}Æ·|	7©§Ãœ•+l´ï"¿|­ÑLÚ”6‰€Šı¨â ûX¹‡)ğÓ—@¿ë«FFt1ìv‰Zñ0J–šŞ[VúŒaf(Ì -¼¨Ò’š)Ëõ2‘V÷p\/+
a“Û>Îxç¶Qƒ0ú“ıÄ·@“—R¸‚_]¾–œ3\¹ÔMtf=:Ÿ8„2Ó/Å„º¥t]#OF G”680[
ïJXØ…ÚqSÛño‚ĞfèW|7›X'­Ú™¥mréê¦‰ÂBÒ¼ŒZ!v‰cw¢ °n#1
@¡m]‰­4é»Q’†R»´w9ÀŠ	”A£êµH¹Ö«ûV_à3{¸šÂ”F\Ô‡ò»ıß8'bêıÍÇÕ`Û$Î•€bÀ)Xu\¡`Êw}HÈØïÃLsr|i½u}éJkµ8)ºASŠ:æF”U™§–‘ê ùEê2M¯€`rs±rs¿2õ¢òÎ (´j“÷jÏµ_(HcÁÀ‘YòN£ÛÓjÅ*²•¸J`_ô‰ığİÆRQtEvzphÎ—è¢£QwÅ¦„Œ˜ˆÂÖ*MO±éÇ=â³ÇV5÷ò–ñÍÁğÁın™½Ú>Š•n1ß>SÂYééÔHiTÃ@}’Ñ!Tï·MŠ)~+ÂYZ@#&êÇYqÅN1Ë·>S©Sn°ĞÁğ;îbÚHI@ŸÇr²ò™K†pã½—ÉCª]ºucQ÷¿Hï0Ë§`Õª½"2U9Û{z„bÌ7œ2Ot„f¡ò2ŠÛc¢ Sp*âñôHV3U[Ì„Ú–àã<­…€&ªV¸¾‚Ô`¹ ?cò¤B4Fş†-ï6ttrÿâ(s­ˆ! >Æ·q$ªÀq@ğÎí€Bf6Î…ŠÆÀ)å„‹^çå’#=“‡|^º3‡Ş_ç&¶¬7Ê@Úy9d	1Ô~Â Ã2RÑ‚!²•p ”n4.„ÒÁŞ¸xÍİ®X÷kñ«;Ò	^Ê·pÜÜÆ¨"|g_ìíıTB&Äó(ª,56€¤:ÿ1›
<'HåÛMFUV0ˆb§İvƒ¸ğ]ÂrŠ±µ÷–~¸}pÉmİ—lı#ä€~oSI$D4•U>’
3Erœë°a:¤Æ° M5öP;å[|‰<üfM±¯êtñò«$úíÒMZŸ7wxšÀe±¯“2OB™3LOË
¸ôbz{Ì¶ÓXnDf'•.¥u)^Iá¸†ušñÇZpcj_«é~úı1€JN23Q. ²îã=…4\¨
0%¬t²‚ªbh.endsWith("*") && path !== "*" && !path.endsWith("/*")) {
    warning(
      false,
      `Route path "${path}" will be treated as if it were ` +
        `"${path.replace(/\*$/, "/*")}" because the \`*\` character must ` +
        `always follow a \`/\` in the pattern. To get rid of this warning, ` +
        `please change the route path to "${path.replace(/\*$/, "/*")}".`
    );
    path = path.replace(/\*$/, "/*") as Path;
  }

  // ensure `/` is added at the beginning if the path is absolute
  const prefix = path.startsWith("/") ? "/" : "";

  const stringify = (p: any) =>
    p == null ? "" : typeof p === "string" ? p : String(p);

  const segments = path
    .split(/\/+/)
    .map((segment, index, array) => {
      const isLastSegment = index === array.length - 1;

      // only apply the splat if it's the last segment
      if (isLastSegment && segment === "*") {
        const star = "*" as PathParam<Path>;
        // Apply the splat
        return stringify(params[star]);
      }

      const keyMatch = segment.match(/^:([\w-]+)(\??)$/);
      if (keyMatch) {
        const [, key, optional] = keyMatch;
        let param = params[key as PathParam<Path>];
        invariant(optional === "?" || param != null, `Missing ":${key}" param`);
        return stringify(param);
      }

      // Remove any optional markers from optional static segments
      return segment.replace(/\?$/g, "");
    })
    // Remove empty segments
    .filter((segment) => !!segment);

  return prefix + segments.join("/");
}

/**
 * A PathPattern is used to match on some portion of a URL pathname.
 */
export interface PathPattern<Path extends string = string> {
  /**
   * A string to match against a URL pathname. May contain `:id`-style segments
   * to indicate placeholders for dynamic parameters. May also end with `/*` to
   * indicate matching the rest of the URL pathname.
   */
  path: Path;
  /**
   * Should be `true` if the static portions of the `path` should be matched in
   * the same case.
   */
  caseSensitive?: boolean;
  /**
   * Should be `true` if this pattern should match the entire URL pathname.
   */
  end?: boolean;
}

/**
 * A PathMatch contains info about how a PathPattern matched on a URL pathname.
 */
export interface PathMatch<ParamKey extends string = string> {
  /**
   * The names and values of dynamic parameters in the URL.
   */
  params: Params<ParamKey>;
  /**
   * The portion of the URL pathname that was matched.
   */
  pathname: string;
  /**
   * The portion of the URL pathname that was matched before child routes.
   */
  pathnameBase: string;
  /**
   * The pattern that was used to match.
   */
  pattern: PathPattern;
}

type Mutable<T> = {
  -readonly [P in keyof T]: T[P];
};

/**
 * Performs pattern matching on a URL pathname and returns information about
 * the match.
 *
 * @see https://reactrouter.com/v6/utils/match-path
 */
export function matchPath<
  ParamKey extends ParamParseKey<Path>,
  Path extends string
>(
  pattern: PathPattern<Path> | Path,
  pathname: string
): PathMatch<ParamKey> | null {
  if (typeof pattern === "string") {
    pattern = { path: pattern, caseSensitive: false, end: true };
  }

  let [matcher, compiledParams] = compilePath(
    pattern.path,
    pattern.caseSensitive,
    pattern.end
  );

  let match = pathname.match(matcher);
  if (!match) return null;

  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params: Params = compiledParams.reduce<Mutable<Params>>(
    (memo, { paramName, isOptional }, index) => {
      // We need to compute the pathnameBase here using the raw splat value
      // instead of using params["*"] later because it will be decoded then
      if (paramName === "*") {
        let splatValue = captureGroups[index] || "";
        pathnameBase = matchedPathname
          .slice(0, matchedPathname.length - splatValue.length)
          .replace(/(.)\/+$/, "$1");
      }

      const value = captureGroups[index];
      if (isOptional && !value) {
        memo[paramName] = undefined;
      } else {
        memo[paramName] = (value || "").replace(/%2F/g, "/");
      }
      return memo;
    },
    {}
  );

  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern,
  };
}

type CompiledPathParam = { paramName: string; isOptional?: boolean };

function compilePath(
  path: string,
  caseSensitive = false,
  end = true
): [RegExp, CompiledPathParam[]] {
  warning(
    path === "*" || !path.endsWith("*") || path.endsWith("/*"),
    `Route path "${path}" will be treated as if it were ` +
      `"${path.replace(/\*$/, "/*")}" because the \`*\` character must ` +
      `always follow a \`/\` in the pattern. To get rid of this warning, ` +
      `please change the route path to "${path.replace(/\*$/, "/*")}".`
  );

  let params: CompiledPathParam[] = [];
  let regexpSource =
    "^" +
    path
      .replace(/\/*\*?$/, "") // Ignore trailing / and /*, we'll handle it below
      .replace(/^\/*/, "/") // Make sure it has a leading /
      .replace(/[\\.*+^${}|()[\]]/g, "\\$&") // Escape special regex chars
      .replace(
        /\/:([\w-]+)(\?)?/g,
        (_: string, paramName: string, isOptional) => {
          params.push({ paramName, isOptional: isOptional != null });
          return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
        }
      );

  if (path.endsWith("*")) {
    params.push({ paramName: "*" });
    regexpSource +=
      path === "*" || path === "/*"
        ? "(.*)$" // Already matched the initial /, just match the rest
        : "(?:\\/(.+)|\\/*)$"; // Don't include the / in params["*"]
  } else if (end) {
    // When matching to the end, ignore trailing slashes
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    // If our path is non-empty and contains anything beyond an initial slash,
    // then we have _some_ form of path in our regex, so we should expect to
    // match only if we find the end of this path segment.  Look for an optional
    // non-captured trailing slash (to match a portion of the URL) or the end
    // of the path (if we've matched to the end).  We used to do this with a
    // word boundary but that gives false positives on routes like
    // /user-preferences since `-` counts as a word boundary.
    regexpSource += "(?:(?=\\/|$))";
  } else {
    // Nothing to match for "" or "/"
  }

  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : "i");

  return [matcher, params];
}

export function decodePath(value: string) {
  try {
    return value
      .split("/")
      .map((v) => decodeURIComponent(v).replace(/\//g, "%2F"))
      .join("/");
  } catch (error) {
    warning(
      false,
      `The URL path "${value}" could not be decoded because it is is a ` +
        `malformed URL segment. This is probably due to a bad percent ` +
        `encoding (${error}).`
    );

    return value;
  }
}

/**
 * @private
 */
export function stripBasename(
  pathname: string,
  basename: string
): string | null {
  if (basename === "/") return pathname;

  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }

  // We want to leave trailing slash behavior in the user's control, so if they
  // specify a basename with a trailing slash, we should support it
  let startIndex = basename.endsWith("/")
    ? basename.length - 1
    : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    // pathname does not start with basename/
    return null;
  }

  return pathname.slice(startIndex) || "/";
}

const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
export const isAbsoluteUrl = (url: string) => ABSOLUTE_URL_REGEX.test(url);

/**
 * Returns a resolved path object relative to the given pathname.
 *
 * @see https://reactrouter.com/v6/utils/resolve-path
 */
export function resolvePath(to: To, fromPathname = "/"): Path {
  let {
    pathname: toPathname,
    search = "",
    hash = "",
  } = typeof to === "string" ? parsePath(to) : to;

  let pathname: string;
  if (toPathname) {
    if (isAbsoluteUrl(toPathname)) {
      pathname = toPathname;
    } else {
      if (toPathname.includes("//")) {
        let oldPathname = toPathname;
        toPathname = toPathname.replace(/\/\/+/g, "/");
        warning(
          false,
          `Pathnames cannot have embedded double slashes - normalizing ` +
            `${oldPathname} -> ${toPathname}`
        );
      }
      if (toPathname.startsWith("/")) {
        pathname = resolvePathname(toPathname.substring(1), "/");
      } else {
        pathname = resolvePathname(toPathname, fromPathname);
      }
    }
  } else {
    pathname = fromPathname;
  }

  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash),
  };
}

function resolvePathname(relativePath: string, fromPathname: string): string {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");

  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      // Keep the root "" segment so the pathname starts at /
      if (segments.length > 1) segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });

  return segments.length > 1 ? segments.join("/") : "/";
}

function getInvalidPathError(
  char: string,
  field: string,
  dest: string,
  path: Partial<Path>
) {
  return (
    `Cannot include a '${char}' character in a manually specified ` +
    `\`to.${field}\` field [${JSON.stringify(
      path
    )}].  Please separate it out to the ` +
    `\`to.${dest}\` field. Alternatively you may provide the full path as ` +
    `a string in <Link to="..."> and the router will parse it for you.`
  );
}

/**
 * @private
 *
 * When processing relative navigation we want to ignore ancestor routes that
 * do not contribute to the path, such that index/pathless layout routes don't
 * interfere.
 *
 * For example, when moving a route element into an index route and/or a
 * pathless layout route, relative link behavior contained within should stay
 * the same.  Both of the following examples should link back to the root:
 *
 *   <Route path="/">
 *     <Route path="accounts" element={<Link to=".."}>
 *   </Route>
 *
 *   <Route path="/">
 *     <Route path="accounts">
 *       <Route element={<AccountsLayout />}>       // <-- Does not contribute
 *         <Route index element={<Link to=".."} />  // <-- Does not contribute
 *       </Route
 *     </Route>
 *   </Route>
 */
export function getPathContributingMatches<
  T extends AgnosticRouteMatch = AgnosticRouteMatch
>(matches: T[]) {
  return matches.filter(
    (match, index) =>
      index === 0 || (match.route.path && match.route.path.length > 0)
  );
}

// Return the array of pathnames for the current route matches - used to
// generate the routePathnames input for resolveTo()
export function getResolveToMatches<
  T extends AgnosticRouteMatch = AgnosticRouteMatch
>(matches: T[], v7_relativeSplatPath: boolean) {
  let pathMatches = getPathContributingMatches(matches);

  // When v7_relativeSplatPath is enabled, use the full pathname for the leaf
  // match so we include splat values for "." links.  See:
  // https://github.com/remix-run/react-router/issues/11052#issuecomment-1836589329
  if (v7_relativeSplatPath) {
    return pathMatches.map((match, idx) =>
      idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase
    );
  }

  return pathMatches.map((match) => match.pathnameBase);
}

/**
 * @private
 */
export function resolveTo(
  toArg: To,
  routePathnames: string[],
  locationPathname: string,
  isPathRelative = false
): Path {
  let to: Partial<Path>;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = { ...toArg };

    invariant(
      !to.pathname || !to.pathname.includes("?"),
      getInvalidPathError("?", "pathname", "search", to)
    );
    invariant(
      !to.pathname || !to.pathname.includes("#"),
      getInvalidPathError("#", "pathname", "hash", to)
    );
    invariant(
      !to.search || !to.search.includes("#"),
      getInvalidPathError("#", "search", "hash", to)
    );
  }

  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;

  let from: string;

  // Routing is relative to the current pathname if explicitly requested.
  //
  // If a pathname is explicitly provided in `to`, it should be relative to the
  // route context. This is explained in `Note on `<Link to>` values` in our
  // migration guide from v5 as a means of disambiguation between `to` values
  // that begin with `/` and those that do not. However, this is problematic for
  // `to` values that do not provide a pathname. `to` can simply be a search or
  // hash string, in which case we should assume that the navigation is relative
  // to the current location's pathname and *not* the route pathname.
  if (toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;

    // With relative="route" (the default), each leading .. segment means
    // "go up one route" instead of "go up one URL segment".  This is a key
    // difference from how <a href> works and a major reason we call this a
    // "to" value instead of a "href".
    if (!isPathRelative && toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");

      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }

      to.pathname = toSegments.join("/");
    }

    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }

  let path = resolvePath(to, from);

  // Ensure the pathname has a trailing slash if the original "to" had one
  let hasExplicitTrailingSlash =
    toPathname && toPathname !== "/" && toPathname.endsWith("/");
  // Or if this was a link to the current path which has a trailing slash
  let hasCurrentTrailingSlash =
    (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (
    !path.pathname.endsWith("/") &&
    (hasExplicitTrailingSlash || hasCurrentTrailingSlash)
  ) {
    path.pathname += "/";
  }

  return path;
}

/**
 * @private
 */
export function getToPathname(to: To): string | undefined {
  // Empty strings should be treated the same as / paths
  return to === "" || (to as Path).pathname === ""
    ? "/"
    : typeof to === "string"
    ? parsePath(to).pathname
    : to.pathname;
}

/**
 * @private
 */
export const joinPaths = (paths: string[]): string =>
  paths.join("/").replace(/\/\/+/g, "/");

/**
 * @private
 */
export const normalizePathname = (pathname: string): string =>
  pathname.replace(/\/+$/, "").replace(/^\/*/, "/");

/**
 * @private
 */
export const normalizeSearch = (search: string): string =>
  !search || search === "?"
    ? ""
    : search.startsWith("?")
    ? search
    : "?" + search;

/**
 * @private
 */
export const normalizeHash = (hash: string): string =>
  !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;

export type JsonFunction = <Data>(
  data: Data,
  init?: number | ResponseInit
) => Response;

/**
 * This is a shortcut for creating `application/json` responses. Converts `data`
 * to JSON and sets the `Content-Type` header.
 *
 * @deprecated The `json` method is deprecated in favor of returning raw objects.
 * This method will be removed in v7.
 */
export const json: JsonFunction = (data, init = {}) => {
  let responseInit = typeof init === "number" ? { status: init } : init;

  let headers = new Headers(responseInit.headers);
  if (!headers.has("Content-Type")) {
    headers.set("Content-Type", "application/json; charset=utf-8");
  }

  return new Response(JSON.stringify(data), {
    ...responseInit,
    headers,
  });
};

export class DataWithResponseInit<D> {
  type: string = "DataWithResponseInit";
  data: D;
  init: ResponseInit | null;

  constructor(data: D, init?: ResponseInit) {
    this.data = data;
    this.init = init || null;
  }
}

/**
 * Create "responses" that contain `status`/`headers` without forcing
 * serialization into an actual `Response` - used by Remix single fetch
 */
export function data<D>(data: D, init?: number | ResponseInit) {
  return new DataWithResponseInit(
 k  €¡C o u l d   n o t   r e l e a s e   a   l o c k   o n   t h e   r e s o u r c e   ' { 0 } ' :   S e r v e r   r e t u r n e d   t h e   ' { 1 } '   e r r o r .  5T h e   l o c k   r e q u e s t   t i m e d   o u t  ;T h e   l o c k   r e q u e s t   w a s   c a n c e l e d  aT h e   l o c k   r e q u e s t   w a s   c h o s e n   a s   a   d e a d l o c k   v i c t i m  iI n d i c a t e s   a   p a r a m e t e r   v a l i d a t i o n   o r   o t h e r   c a l l   e r r o r  =Q u e u e   a r r a y   m u s t   b e   n o n - e m p t y .  c] . J o b Q u e u e   ( J o b I d ,   Q u e u e )   v a l u e s   ( @ j o b I d ,   @ q u e u e )  _  ‘
 s e t   n o c o u n t   o n ; s e t   x a c t _ a b o r t   o n ; s e t   t r a n   i s o l a t i o n   l e v e l   r e a d   c o m m i t t e d ; 
 
 u p d a t e   t o p   ( 1 )   J Q 
 s e t   F e t c h e d A t   =   G E T U T C D A T E ( ) 
 o u t p u t   I N S E R T E D . I d ,   I N S E R T E D . J o b I d ,   I N S E R T E D . Q u e u e ,   I N S E R T E D . F e t c h e d A t 
 f r o m   [  )] . J o b Q u e u e   J Q   w i t h   (  €Õ) 
 w h e r e   Q u e u e   i n   @ q u e u e s   a n d 
 ( F e t c h e d A t   i s   n u l l   o r   F e t c h e d A t   <   D A T E A D D ( s e c o n d ,   @ t i m e o u t S s ,   G E T U T C D A T E ( ) ) ) ;  ‚å
 s e t   n o c o u n t   o n ; s e t   x a c t _ a b o r t   o n ; s e t   t r a n   i s o l a t i o n   l e v e l   r e a d   c o m m i t t e d ; 
 
 d e c l a r e   @ e n d   d a t e t i m e 2   =   D A T E A D D ( m s ,   @ e n d M s ,   S Y S U T C D A T E T I M E ( ) ) , 
 	 @ d e l a y   d a t e t i m e   =   D A T E A D D ( m s ,   @ d e l a y M s ,   c o n v e r t ( D A T E T I M E ,   0 ) ) ; 
 
 W H I L E   ( S Y S U T C D A T E T I M E ( )   <   @ e n d ) 
 B E G I N 
 	 u p d a t e   t o p   ( 1 )   J Q   s e t   F e t c h e d A t   =   G E T U T C D A T E ( ) 
 	 o u t p u t   I N S E R T E D . I d ,   I N S E R T E D . J o b I d ,   I N S E R T E D . Q u e u e ,   I N S E R T E D . F e t c h e d A t 
 	 f r o m   [  E) 
 	 w h e r e   Q u e u e   i n   @ q u e u e s   a n d   ( F e t c h e d A t   i s   n u l l   o r   F e t c h e d A t   <   D A T E A D D ( s e c o n d ,   @ t i m e o u t S s ,   G E T U T C D A T E ( ) ) ) ; 
 
 	 I F   @ @ R O W C O U N T   >   0   R E T U R N ; 
 	 W A I T F O R   D E L A Y   @ d e l a y ; 
 E N D  3f o r c e s e e k ,   p a g l o c k ,   x l o c k  Kf o r c e s e e k ,   r e a d p a s t ,   u p d l o c k ,   r o w l o c k  €‘d e l e t e   t o p   ( 1 )   J Q 
 o u t p u t   D E L E T E D . I d ,   D E L E T E D . J o b I d ,   D E L E T E D . Q u e u e 
 f r o m   [  A] . J o b Q u e u e   J Q   w i t h   ( r e a d p a s t ,   u p d l o c k ,   r o w l o c k ,   f o r c e s e e k ) 
 w h e r e   Q u e u e   i n   @ q u e u e s   a n d   ( F e t c h e d A t   i s   n u l l   o r   F e t c h e d A t   <   D A T E A D D ( s e c o n d ,   @ t i m e o u t ,   G E T U T C D A T E ( ) ) )  @ q u e u e s  @ t i m e o u t S s  @ d e l a y M s  @ e n d M s  ;s e l e c t   d i s t i n c t ( Q u e u e )   f r o m   [  1] . J o b Q u e u e   w i t h   ( n o l o c k )  €Ás e l e c t   r . J o b I d   f r o m   ( 
     s e l e c t   j q . J o b I d ,   r o w _ n u m b e r ( )   o v e r   ( o r d e r   b y   j q . I d )   a s   r o w _ n u m   
     f r o m   [  ] . J o b Q u e u e   j q   w i t h   ( n o l o c k ,   f o r c e s e e k ) 
     w h e r e   j q . Q u e u e   =   @ q u e u e   a n d   j q . F e t c h e d A t   i s   n u l l 
 )   a s   r 
 w h e r e   r . r o w _ n u m   b e t w e e n   @ s t a r t   a n d   @ e n d  €ß
 s e l e c t   r . J o b I d   f r o m   ( 
     s e l e c t   j q . J o b I d ,   j q . F e t c h e d A t ,   r o w _ n u m b e r ( )   o v e r   ( o r d e r   b y   j q . I d )   a s   r o w _ n u m   
     f r o m   [  ] . J o b Q u e u e   j q   w i t h   ( n o l o c k ,   f o r c e s e e k ) 
     w h e r e   j q . Q u e u e   =   @ q u e u e   a n d   j q . F e t c h e d A t   i s   n o t   n u l l 
 )   a s   r 
 w h e r e   r . r o w _ n u m   b e t w e e n   @ s t a r t   a n d   @ e n d  ×
 s e l e c t   s u m ( E n q u e u e d )   a s   E n q u e u e d C o u n t ,   s u m ( F e t c h e d )   a s   F e t c h e d C o u n t   
 f r o m   ( 
         s e l e c t   
                 c a s e   w h e n   F e t c h e d A t   i s   n u l l   t h e n   1   e l s e   0   e n d   a s   E n q u e u e d , 
                 c a s e   w h e n   F e t c h e d A t   i s   n o t   n u l l   t h e n   1   e l s e   0   e n d   a s   F e t c h e d 
         f r o m   [  €] . J o b Q u e u e   w i t h   ( n o l o c k ,   f o r c e s e e k ) 
         w h e r e   Q u e u e   =   @ q u e u e 
 )   q  Q u e u e  E n q u e u e d C o u n t  F e t c h e d C o u n t  ˆ
 s e t   t r a n s a c t i o n   i s o l a t i o n   l e v e l   r e a d   c o m m i t t e d ; 
 s e l e c t   c o u n t ( I d )   f r o m   [ { 0 } ] . J o b   w i t h   ( n o l o c k ,   f o r c e s e e k )   w h e r e   S t a t e N a m e   =   N ' E n q u e u e d ' ; 
 s e l e c t   c o u n t ( I d )   f r o m   [ { 0 } ] . J o b   w i t h   ( n o l o c k ,   f o r c e s e e k )   w h e r e   S t a t e N a m e   =   N ' F a i l e d ' ; 
 s e l e c t   c o u n t ( I d )   f r o m   [ { 0 } ] . J o b   w i t h   ( n o l o c k ,   f o r c e s e e k )   w h e r e   S t a t e N a m e   =   N ' P r o c e s s i n g ' ; 
 s e l e c t   c o u n t ( I d )   f r o m   [ { 0 } ] . J o b   w i t h   ( n o l o c k ,   f o r c e s e e k )   w h e r e   S t a t e N a m e   =   N ' S c h e d u l e d ' ; 
 s e l e c t   c o u n t ( I d )   f r o m   [ { 0 } ] . S e r v e r   w i t h   ( n o l o c k ) ; 
 s e l e c t   s u m ( s . [ V a l u e ] )   f r o m   ( 
         s e l e c t   s u m ( [ V a l u e ] )   a s   [ V a l u e ]   f r o m   [ { 0 } ] . C o u n t e r   w i t h   ( n o l o c k ,   f o r c e s e e k )   w h e r e   [ K e y ]   =   N ' s t a t s : s u c c e e d e d ' 
         u n i o n   a l l 
         s e l e c t   [ V a l u e ]   f r o m   [ { 0 } ] . A g g r e g a t e d C o u n t e r   w i t h   ( n o l o c k ,   f o r c e s e e k )   w h e r e   [ K e y ]   =   N ' s t a t s : s u c c e e d e d ' 
 )   a s   s ; 
 s e l e c t   s u m ( s . [ V a l u e ] )   f r o m   ( 
         s e l e c t   s u m ( [ V a l u e ] )   a s   [ V a l u e ]   f r o m   [ { 0 } ] . C o u n t e r   w i t h   ( n o l o c k ,   f o r c e s e e k )   w h e r e   [ K e y ]   =   N ' s t a t s : d e l e t e d ' 
         u n i o n   a l l 
         s e l e c t   [ V a l u e ]   f r o m   [ { 0 } ] . A g g r e g a t e d C o u n t e r   w i t h   ( n o l o c k ,   f o r c e s e e k )   w h e r e   [ K e y ]   =   N ' s t a t s : d e l e t e d ' 
 )   a s   s ; 
 
 s e l e c t   c o u n t ( * )   f r o m   [ { 0 } ] . [ S e t ]   w i t h   ( n o l o c k ,   f o r c e s e e k )   w h e r e   [ K e y ]   =   N ' r e c u r r i n g - j o b s ' ; 
                                  Os e l e c t   [ K e y ] ,   [ V a l u e ]   a s   [ C o u n t ]   f r o m   [  €ƒ] . A g g r e g a t e d C o u n t e r   w i t h   ( n o l o c k ,   f o r c e s e e k ) 
 w h e r e   [ K e y ]   i n   @ k e y s  €¹s e l e c t   j . * ,   s . R e a s o n   a s   S t a t e R e a s o n ,   s . D a t a   a s   S t a t e D a t a ,   s . C r e a t e d A t   a s   S t a t e C h a n g e d 
 f r o m   [  Y] . J o b   j   w i t h   ( n o l o c k ,   f o r c e s e e k ) 
 l e f t   j o i n   [  €¿] . S t a t e   s   w i t h   ( n o l o c k ,   f o r c e s e e k )   o n   s . I d   =   j . S t a t e I d   a n d   s . J o b I d   =   j . I d 
 w h e r e   j . I d   i n   @ j o b I d s  /s e l e c t   c o u n t ( I d )   f r o m   [  o] . J o b   w i t h   ( n o l o c k ,   f o r c e s e e k )   w h e r e   S t a t e N a m e   =   @ s t a t e  ms e l e c t   c o u n t ( j . I d )   f r o m   ( s e l e c t   t o p   ( @ l i m i t )   I d   f r o m   [  {] . J o b   w i t h   ( n o l o c k ,   f o r c e s e e k )   w h e r e   S t a t e N a m e   =   @ s t a t e )   a s   j  €³; w i t h   c t e   a s   
 ( 
     s e l e c t   j . I d ,   r o w _ n u m b e r ( )   o v e r   ( o r d e r   b y   j . I d   d e s c )   a s   r o w _ n u m 
     f r o m   [  A] . J o b   j   w i t h   ( n o l o c k ,   f o r c e s e e k ) 
     w h e r e   j . S t a t e N a m e   =   @ s t a t e N a m e 
 ) 
 s e l e c t   j . * ,   s . R e a s o n   a s   S t a t e R e a s o n ,   s . D a t a   a s   S t a t e D a t a ,   s . C r e a t e d A t   a s   S t a t e C h a n g e d 
 f r o m   [  €™] . J o b   j   w i t h   ( 