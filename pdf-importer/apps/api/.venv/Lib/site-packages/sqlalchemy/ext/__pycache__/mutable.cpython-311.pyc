ions]);
	 *
	 * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
	 * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
	 * ```
	 * @param {String|Array} str The string to test.
	 * @param {String|Array} patterns One or more glob patterns to use for matching.
	 * @param {Object} [options] See available [options](#options).
	 * @return {Boolean} Returns true if any patterns match `str`
	 * @api public
	 */

	picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);

	/**
	 * Parse a glob pattern to create the source string for a regular
	 * expression.
	 *
	 * ```js
	 * const picomatch = require('picomatch');
	 * const result = picomatch.parse(pattern[, options]);
	 * ```
	 * @param {String} `pattern`
	 * @param {Object} `options`
	 * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
	 * @api public
	 */

	picomatch.parse = (pattern, options) => {
	  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));
	  return parse(pattern, { ...options, fastpaths: false });
	};

	/**
	 * Scan a glob pattern to separate the pattern into segments.
	 *
	 * ```js
	 * const picomatch = require('picomatch');
	 * // picomatch.scan(input[, options]);
	 *
	 * const result = picomatch.scan('!./foo/*.js');
	 * console.log(result);
	 * { prefix: '!./',
	 *   input: '!./foo/*.js',
	 *   start: 3,
	 *   base: 'foo',
	 *   glob: '*.js',
	 *   isBrace: false,
	 *   isBracket: false,
	 *   isGlob: true,
	 *   isExtglob: false,
	 *   isGlobstar: false,
	 *   negated: true }
	 * ```
	 * @param {String} `input` Glob pattern to scan.
	 * @param {Object} `options`
	 * @return {Object} Returns an object with
	 * @api public
	 */

	picomatch.scan = (input, options) => scan(input, options);

	/**
	 * Compile a regular expression from the `state` object returned by the
	 * [parse()](#parse) method.
	 *
	 * @param {Object} `state`
	 * @param {Object} `options`
	 * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.
	 * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.
	 * @return {RegExp}
	 * @api public
	 */

	picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
	  if (returnOutput === true) {
	    return state.output;
	  }

	  const opts = options || {};
	  const prepend = opts.contains ? '' : '^';
	  const append = opts.contains ? '' : '$';

	  let source = `${prepend}(?:${state.output})${append}`;
	  if (state && state.negated === true) {
	    source = `^(?!${source}).*$`;
	  }

	  const regex = picomatch.toRegex(source, options);
	  if (returnState === true) {
	    regex.state = state;
	  }

	  return regex;
	};

	/**
	 * Create a regular expression from a parsed glob pattern.
	 *
	 * ```js
	 * const picomatch = require('picomatch');
	 * const state = picomatch.parse('*.js');
	 * // picomatch.compileRe(state[, options]);
	 *
	 * console.log(picomatch.compileRe(state));
	 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
	 * ```
	 * @param {String} `state` The object returned from the `.parse` method.
	 * @param {Object} `options`
	 * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.
	 * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.
	 * @return {RegExp} Returns a regex created from the given pattern.
	 * @api public
	 */

	picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
	  if (!input || typeof input !== 'string') {
	    throw new TypeError('Expected a non-empty string');
	  }

	  let parsed = { negated: false, fastpaths: true };

	  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {
	    parsed.output = parse.fastpaths(input, options);
	  }

	  if (!parsed.output) {
	    parsed = parse(input, options);
	  }

	  return picomatch.compileRe(parsed, options, returnOutput, returnState);
	};

	/**
	 * Create a regular expression from the given regex source string.
	 *
	 * ```js
	 * const picomatch = require('picomatch');
	 * // picomatch.toRegex(source[, options]);
	 *
	 * const { output } = picomatch.parse('*.js');
	 * console.log(picomatch.toRegex(output));
	 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
	 * ```
	 * @param {String} `source` Regular expression source string.
	 * @param {Object} `options`
	 * @return {RegExp}
	 * @api public
	 */

	picomatch.toRegex = (source, options) => {
	  try {
	    const opts = options || {};
	    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
	  } catch (err) {
	    if (options && options.debug === true) throw err;
	    return /$^/;
	  }
	};

	/**
	 * Picomatch constants.
	 * @return {Object}
	 */

	picomatch.constants = constants;

	/**
	 * Expose "picomatch"
	 */

	picomatch_1$1 = picomatch;
	return picomatch_1$1;
}

var picomatch_1;
var hasRequiredPicomatch;

function requirePicomatch () {
	if (hasRequiredPicomatch) return picomatch_1;
	hasRequiredPicomatch = 1;

	const pico = /*@__PURE__*/ requirePicomatch$1();
	const utils = /*@__PURE__*/ requireUtils();

	function picomatch(glob, options, returnState = false) {
	  // default to os.platform()
	  if (options && (options.windows === null || options.windows === undefined)) {
	    // don't mutate the original options object
	    options = { ...options, windows: utils.isWindows() };
	  }

	  return pico(glob, options, returnState);
	}

	Object.assign(picomatch, pico);
	picomatch_1 = picomatch;
	return picomatch_1;
}

var picomatchExports = /*@__PURE__*/ requirePicomatch();
const picomatch = /*@__PURE__*/getDefaultExportFromCjs(picomatchExports);

const extractors = {
    ArrayPattern(names, param) {
        for (const element of param.elements) {
            if (element)
                extractors[element.type](names, element);
        }
    },
    AssignmentPattern(names, param) {
        extractors[param.left.type](names, param.left);
    },
    Identifier(names, param) {
        names.push(param.name);
    },
    MemberExpression() { },
    ObjectPattern(names, param) {
        for (const prop of param.properties) {
            // @ts-ignore Typescript reports that this is not a valid type
            if (prop.type === 'RestElement') {
                extractors.RestElement(names, prop);
            }
            else {
                extractors[prop.value.type](names, prop.value);
            }
        }
    },
    RestElement(names, param) {
        extractors[param.argument.type](names, param.argument);
    }
};
const extractAssignedNames = function extractAssignedNames(param) {
    const names = [];
    extractors[param.type](names, param);
    return names;
};

// Helper since Typescript can't detect readonly arrays with Array.isArray
function isArray(arg) {
    return Array.isArray(arg);
}
function ensureArray$1(thing) {
    if (isArray(thing))
        return thing;
    if (thing == null)
        return [];
    return [thing];
}

const normalizePathRegExp = new RegExp(`\\${win32.sep}`, 'g');
const normalizePath = function normalizePath(filename) {
    return filename.replace(normalizePathRegExp, posix.sep);
};

function getMatcherString$1(id, resolutionBase) {
    if (resolutionBase === false || isAbsolute(id) || id.startsWith('**')) {
        return normalizePath(id);
    }
    // resolve('') is valid and will default to process.cwd()
    const basePath = normalizePath(resolve(resolutionBase || ''))
        // escape all possible (posix + win) path characters that might interfere with regex
        .replace(/[-^$*+?.()|[\]{}]/g, '\\$&');
    // Note that we use posix.join because:
    // 1. the basePath has been normalized to use /
    // 2. the incoming glob (id) matcher, also uses /
    // otherwise Node will force backslash (\) on windows
    return posix.join(basePath, normalizePath(id));
}
const createFilter$1 = function createFilter(include, exclude, options) {
    const resolutionBase = options && options.resolve;
    const getMatcher = (id) => id instanceof RegExp
        ? id
        : {
            test: (what) => {
                // this refactor is a tad overly verbose but makes for easy debugging
                const pattern = getMatcherString$1(id, resolutionBase);
                const fn = picomatch(pattern, { dot: true });
                const result = fn(what);
                return result;
            }
        };
    const includeMatchers = ensureArray$1(include).map(getMatcher);
    const excludeMatchers = ensureArray$1(exclude).map(getMatcher);
    if (!includeMatchers.length && !excludeMatchers.length)
        return (id) => typeof id === 'string' && !id.includes('\0');
    return function result(id) {
        if (typeof id !== 'string')
            return false;
        if (id.includes('\0'))
            return false;
        const pathId = normalizePath(id);
        for (let i = 0; i < excludeMatchers.length; ++i) {
            const matcher = excludeMatchers[i];
            if (matcher instanceof RegExp) {
                matcher.lastIndex = 0;
            }
            if (matcher.test(pathId))
                return false;
        }
        for (let i = 0; i < includeMatchers.length; ++i) {
            const matcher = includeMatchers[i];
            if (matcher instanceof RegExp) {
                matcher.lastIndex = 0;
            }
            if (matcher.test(pathId))
                return true;
        }
        return !includeMatchers.length;
    };
};

const reservedWords = 'break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public';
const builtins = 'arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl';
const forbiddenIdentifiers = new Set(`${reservedWords} ${builtins}`.split(' '));
forbiddenIdentifiers.add('');

class ArrayPattern extends NodeBase {
    addExportedVariables(variables, exportNamesByVariable) {
        for (const element of this.elements) {
            element?.addExportedVariables(variables, exportNamesByVariable);
        }
    }
    declare(kind, destructuredInitPath, init) {
        const variables = [];
        const includedPatternPath = getIncludedPatternPath(destructuredInitPath);
        for (const element of this.elements) {
            if (element !== null) {
                variables.push(...element.declare(kind, includedPatternPath, init));
            }
        }
        return variables;
    }
    deoptimizeAssignment(destructuredInitPath, init) {
        const includedPatternPath = getIncludedPatternPath(destructuredInitPath);
        for (const element of this.elements) {
            element?.deoptimizeAssignment(includedPatternPath, init);
        }
    }
    // Patterns can only be deoptimized at the empty path at the moment
    deoptimizePath() {
        for (const element of this.elements) {
            element?.deoptimizePath(EMPTY_PATH);
        }
    }
    hasEffectsWhenDestructuring(context, destructuredInitPath, init) {
        const includedPatternPath = getIncludedPatternPath(destructuredInitPath);
        for (const element of this.elements) {
            if (element?.hasEffectsWhenDestructuring(context, includedPatternPath, init)) {
                return true;
            }
        }
        return false;
    }
    // Patterns are only checked at the empty path at the moment
    hasEffectsOnInteractionAtPath(_path, interaction, context) {
        for (const element of this.elements) {
            if (element?.hasEffectsOnInteractionAtPath(EMPTY_PATH, interaction, context))
                return true;
        }
        return false;
    }
    includeDestructuredIfNecessary(context, destructuredInitPath, init) {
        let included = false;
        const includedPatternPath = getIncludedPatternPath(destructuredInitPath);
        for (const element of [...this.elements].reverse()) {
            if (element) {
                if (included && !element.included) {
                    element.includeNode(context);
                }
                included =
                    element.includeDestructuredIfNecessary(context, includedPatternPath, init) || included;
            }
        }
        if (!this.included && included) {
            this.includeNode(context);
        }
        return this.included;
    }
    render(code, options) {
        let removedStart = this.start + 1;
        for (const element of this.elements) {
            if (!element)
                continue;
            if (element.included) {
                element.render(code, options);
                removedStart = element.end;
            }
            else {
                code.remove(removedStart, this.end - 1);
                break;
            }
        }
    }
    markDeclarationReached() {
        for (const element of this.elements) {
            element?.markDeclarationReached();
        }
    }
}
ArrayPattern.prototype.includeNode = onlyIncludeSelf;
const getIncludedPatternPath = (destructuredInitPath) => destructuredInitPath.at(-1) === UnknownKey
    ? destructuredInitPath
    : [...destructuredInitPath, UnknownInteger];

class ArrowFunctionExpression extends FunctionBase {
    constructor() {
        super(...arguments);
        this.objectEntity = null;
    }
    get expression() {
        return isFlagSet(this.flags, 8388608 /* Flag.expression */);
    }
    set expression(value) {
        this.flags = setFlag(this.flags, 8388608 /* Flag.expression */, value);
    }
    createScope(parentScope) {
        this.scope = new ReturnValueScope(parentScope, false);
    }
    hasEffects() {
        return false;
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        if (this.annotationNoSideEffects &&
            path.length === 0 &&
            interaction.type === INTERACTION_CALLED) {
            return false;
        }
        if (super.hasEffectsOnInteractionAtPath(path, interaction, context)) {
            return true;
        }
        if (interaction.type === INTERACTION_CALLED) {
            const { ignore, brokenFlow } = context;
            context.ignore = {
                breaks: false,
                continues: false,
                labels: new Set(),
                returnYield: true,
                this: false
            };
            if (this.body.hasEffects(context))
                return true;
            context.ignore = ignore;
            context.brokenFlow = brokenFlow;
        }
        return false;
    }
    onlyFunctionCallUsed() {
        const isIIFE = this.parent.type === CallExpression$1 &&
            this.parent.callee === this;
        return isIIFE || super.onlyFunctionCallUsed();
    }
    include(context, includeChildrenRecursively) {
        super.include(context, includeChildrenRecursively);
        for (const parameter of this.params) {
            if (!(parameter instanceof Identifier)) {
                parameter.include(context, includeChildrenRecursively);
            }
        }
    }
    includeNode(context) {
        this.included = true;
        this.body.includePath(UNKNOWN_PATH, context);
        for (const parameter of this.params) {
            if (!(parameter instanceof Identifier)) {
                parameter.includePath(UNKNOWN_PATH, context);
            }
        }
    }
    getObjectEntity() {
        if (this.objectEntity !== null) {
            return this.objectEntity;
        }
        return (this.objectEntity = new ObjectEntity([], OBJECT_PROTOTYPE));
    }
}

class ObjectPattern extends NodeBase {
    addExportedVariables(variables, exportNamesByVariable) {
        for (const property of this.properties) {
            if (property.type === Property$1) {
                property.value.addExportedVariables(variables, exportNamesByVariable);
            }
            else {
                property.argument.addExportedVariables(variables, exportNamesByVariable);
            }
        }
    }
    declare(kind, destructuredInitPath, init) {
        const variables = [];
        for (const property of this.properties) {
            variables.push(...property.declare(kind, destructuredInitPath, init));
        }
        return variables;
    }
    deoptimizeAssignment(destructuredInitPath, init) {
        for (const property of this.properties) {
            property.deoptimizeAssignment(destructuredInitPath, init);
        }
    }
    deoptimizePath(path) {
        if (path.length === 0) {
            for (const property of this.properties) {
                property.deoptimizePath(path);
            }
        }
    }
    hasEffectsOnInteractionAtPath(
    // At the moment, this is only triggered for assignment left-hand sides,
    // where the path is empty
    _path, interaction, context) {
        for (const property of this.properties) {
            if (property.hasEffectsOnInteractionAtPath(EMPTY_PATH, interaction, context))
                return true;
        }
        return false;
    }
    hasEffectsWhenDestructuring(context, destructuredInitPath, init) {
        for (const property of this.properties) {
            if (property.hasEffectsWhenDestructuring(context, destructuredInitPath, init))
                return true;
        }
        return false;
    }
    includeDestructuredIfNecessary(context, destructuredInitPath, init) {
        if (!this.properties.length)
            return this.included;
        const lastProperty = this.properties.at(-1);
        let included = lastProperty.includeDestructuredIfNecessary(context, destructuredInitPath, init);
        const lastPropertyIsRestElement = lastProperty.type === RestElement$1;
        for (const property of this.properties.slice(0, -1)) {
            if (lastPropertyIsRestElement && included && !property.included) {
                property.includeNode(context);
            }
            included =
                property.includeDestructuredIfNecessary(context, destructuredInitPath, init) || included;
        }
        if (!this.included && included) {
            this.includeNode(context);
        }
        return this.included;
    }
    markDeclarationReached() {
        for (const property of this.properties) {
            property.markDeclarationReached();
        }
    }
    render(code, options) {
        if (this.properties.length > 0) {
            const separatedNodes = getCommaSeparatedNodesWithBoundaries(this.properties, code, this.start + 1, this.end - 1);
            let lastSeparatorPos = null;
            for (const { node, separator, start, end } of separatedNodes) {
                if (!node.included) {
                    treeshakeNode(node, code, start, end);
                    continue;
                }
                lastSeparatorPos = separator;
                node.render(code, options);
            }
            if (lastSeparatorPos) {
                code.remove(lastSeparatorPos, this.end - 1);
            }
        }
    }
}
ObjectPattern.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
ObjectPattern.prototype.applyDeoptimizations = doNotDeoptimize;

class AssignmentExpression extends NodeBase {
    constructor() {
        super(...arguments);
        this.isConstReassignment = false;
    }
    hasEffects(context) {
        const { deoptimized, isConstReassignment, left, operator, right } = this;
        if (!deoptimized)
            this.applyDeoptimizations();
        // MemberExpressions do not access the property before assignments if the
        // operator is '='.
        return (isConstReassignment ||
            right.hasEffects(context) ||
            left.hasEffectsAsAssignmentTarget(context, operator !== '=') ||
            this.left.hasEffectsWhenDestructuring?.(context, EMPTY_PATH, right));
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        return ((interaction.type === INTERACTION_ASSIGNED && this.left.included) ||
            this.right.hasEffectsOnInteractionAtPath(path, interaction, context));
    }
    include(context, includeChildrenRecursively) {
        const { deoptimized, isConstReassignment, left, right, operator } = this;
        if (!deoptimized)
            this.applyDeoptimizations();
        if (!this.included)
            this.includeNode(context);
        const hasEffectsContext = createHasEffectsContext();
        if (includeChildrenRecursively ||
            isConstReassignment ||
            operator !== '=' ||
            left.included ||
            left.hasEffectsAsAssignmentTarget(hasEffectsContext, false) ||
            left.hasEffectsWhenDestructuring?.(hasEffectsContext, EMPTY_PATH, right)) {
            left.includeAsAssignmentTarget(context, includeChildrenRecursively, operator !== '=');
        }
        right.include(context, includeChildrenRecursively);
    }
    includeNode(context) {
        this.included = true;
        if (!this.deoptimized)
            this.applyDeoptimizations();
        this.right.includePath(UNKNOWN_PATH, context);
    }
    initialise() {
        super.initialise();
        if (this.left instanceof Identifier) {
            const variable = this.scope.variables.get(this.left.name);
            if (variable?.kind === 'const') {
                this.isConstReassignment = true;
                this.scope.context.log(LOGLEVEL_WARN, logConstVariableReassignError(), this.left.start);
            }
        }
        this.left.setAssignedValue(this.right);
    }
    render(code, options, { preventASI, renderedParentType, renderedSurroundingElement } = BLANK) {
        const { left, right, start, end, parent } = this;
        if (left.included) {
            left.render(code, options);
            right.render(code, options);
        }
        else {
            const inclusionStart = findNonWhiteSpace(code.original, findFirstOccurrenceOutsideComment(code.original, '=', left.end) + 1);
            code.remove(start, inclusionStart);
            if (preventASI) {
                removeLineBreaks(code, inclusionStart, right.start);
            }
            right.render(code, options, {
                renderedParentType: renderedParentType || parent.type,
                renderedSurroundingElement: renderedSurroundingElement || parent.type
            });
        }
        if (options.format === 'system') {
            if (left instanceof Identifier) {
                const variable = left.variable;
                const exportNames = options.exportNamesByVariable.get(variable);
                if (exportNames) {
                    if (exportNames.length === 1) {
                        renderSystemExportExpression(variable, start, end, code, options);
                    }
                    else {
                        renderSystemExportSequenceAfterExpression(variable, start, end, parent.type !== ExpressionStatement$1, code, options);
                    }
                    return;
                }
            }
            else {
                const systemPatternExports = [];
                left.addExportedVariables(systemPatternExports, options.exportNamesByVariable);
                if (systemPatternExports.length > 0) {
                    renderSystemExportFunction(systemPatternExports, start, end, renderedSurroundingElement === ExpressionStatement$1, code, options);
                    return;
                }
            }
        }
        if (left.included &&
            left instanceof ObjectPattern &&
            (renderedSurroundingElement === ExpressionStatement$1 ||
                renderedSurroundingElement === ArrowFunctionExpression$1)) {
            code.appendRight(start, '(');
            code.prependLeft(end, ')');
        }
    }
    applyDeoptimizations() {
        this.deoptimized = true;
        this.left.deoptimizeAssignment(EMPTY_PATH, this.right);
        this.scope.context.requestTreeshakingPass();
    }
}

class AssignmentPattern extends NodeBase {
    addExportedVariables(variables, exportNamesByVariable) {
        this.left.addExportedVariables(variables, exportNamesByVariable);
    }
    declare(kind, destructuredInitPath, init) {
        return this.left.declare(kind, destructuredInitPath, init);
    }
    deoptimizeAssignment(destructuredInitPath, init) {
        this.left.deoptimizeAssignment(destructuredInitPath, init);
    }
    deoptimizePath(path) {
        if (path.length === 0) {
            this.left.deoptimizePath(path);
        }
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        return (path.length > 0 || this.left.hasEffectsOnInteractionAtPath(EMPTY_PATH, interaction, context));
    }
    hasEffectsWhenDestructuring(context, destructuredInitPath, init) {
        return this.left.hasEffectsWhenDestructuring(context, destructuredInitPath, init);
    }
    includeDestructuredIfNecessary(context, destructuredInitPath, init) {
        let included = this.left.includeDestructuredIfNecessary(context, destructuredInitPath, init) ||
            this.included;
        if ((included ||= this.right.shouldBeIncluded(context))) {
            this.right.include(context, false);
            if (!this.left.included) {
                this.left.includeNode(context);
                // Unfortunately, we need to include the left side again now, so that
                // any declared variables are properly included.
                this.left.includeDestructuredIfNecessary(context, destructuredInitPath, init);
            }
        }
        if (!this.included && included) {
            this.includeNode(context);
        }
        return this.included;
    }
    includeNode(context) {
        this.included = true;
        if (!this.deoptimized)
            this.applyDeoptimizations();
        this.right.includePath(UNKNOWN_PATH, context);
    }
    markDeclarationReached() {
        this.left.markDeclarationReached();
    }
    render(code, options, { isShorthandProperty } = BLANK) {
        this.left.render(code, options, { isShorthandProperty });
        this.right.render(code, options);
    }
    applyDeoptimizations() {
        this.deoptimized = true;
        this.left.deoptimizePath(EMPTY_PATH);
        this.right.deoptimizePath(UNKNOWN_PATH);
        this.scope.context.requestTreeshakingPass();
    }
}

class AwaitExpression extends NodeBase {
    deoptimizePath(path) {
        this.argument.deoptimizePath(path);
    }
    hasEffects() {
        if (!this.deoptimized)
            this.applyDeoptimizations();
        return true;
    }
    initialise() {
        super.initialise();
        let parent = this.parent;
        do {
            if (parent instanceof FunctionNode || parent instanceof ArrowFunctionExpression)
                return;
        } while ((parent = parent.parent));
        this.scope.context.usesTopLevelAwait = true;
    }
    include(context, includeChildrenRecursively) {
        if (!this.included)
            this.includeNode(context);
        this.argument.include(context, includeChildrenRecursively);
    }
    includeNode(context) {
        this.included = true;
        if (!this.deoptimized)
            this.applyDeoptimizations();
        // Thenables need to be included
        this.argument.includePath(THEN_PATH, context);
    }
    includePath(path, context) {
        if (!this.deoptimized)
            this.applyDeoptimizations();
        if (!this.included)
            this.includeNode(context);
        this.argument.includePath(path, context);
    }
}
const THEN_PATH = ['then'];

function getRenderedLiteralValue(value) {
    if (value === undefined) {
        return 'void 0';
    }
    if (typeof value === 'boolean') {
        return String(value);
    }
    if (typeof value === 'string') {
        return JSON.stringify(value);
    }
    if (typeof value === 'number') {
        return getSimplifiedNumber(value);
    }
    return UnknownValue;
}
function getSimplifiedNumber(value) {
    if (Object.is(-0, value)) {
        return '-0';
    }
    const exp = value.toExponential();
    const [base, exponent] = exp.split('e');
    const floatLength = base.split('.')[1]?.length || 0;
    const finalizedExp = `${base.replace('.', '')}e${parseInt(exponent) - floatLength}`;
    const stringifiedValue = String(value).replace('+', '');
    return finalizedExp.length < stringifiedValue.length ? finalizedExp : stringifiedValue;
}

const binaryOperators = {
    '!=': (left, right) => left != right,
    '!==': (left, right) => left !== right,
    '%': (left, right) => left % right,
    '&': (left, right) => left & right,
    '*': (left, right) => left * right,
    // At the moment, "**" will be transpiled to Math.pow
    '**': (left, right) => left ** right,
    '+': (left, right) => left + right,
    '-': (left, right) => left - right,
    '/': (left, right) => left / right,
    '<': (left, right) => left < right,
    '<<': (left, right) => left << right,
    '<=': (left, right) => left <= right,
    '==': (left, right) => left == right,
    '===': (left, right) => left === right,
    '>': (left, right) => left > right,
    '>=': (left, right) => left >= right,
    '>>': (left, right) => left >> right,
    '>>>': (left, right) => left >>> right,
    '^': (left, right) => left ^ right,
    '|': (left, right) => left | right
    // We use the fallback for cases where we return something unknown
    // in: () => UnknownValue,
    // instanceof: () => UnknownValue,
};
const UNASSIGNED$1 = Symbol('Unassigned');
class BinaryExpression extends NodeBase {
    constructor() {
        super(...arguments);
        this.renderedLiteralValue = UNASSIGNED$1;
    }
    deoptimizeCache() {
        this.renderedLiteralValue = UnknownValue;
    }
    getLiteralValueAtPath(path, recursionTracker, origin) {
        if (path.length > 0)
            return UnknownValue;
        const leftValue = this.left.getLiteralValueAtPath(EMPTY_PATH, recursionTracker, origin);
        if (typeof leftValue === 'symbol')
            return UnknownValue;
        // Optimize `'export' in namespace`
        if (this.operator === 'in' && this.right.variable instanceof NamespaceVariable) {
            const [variable] = this.right.variable.context.traceExport(String(leftValue));
            if (variable instanceof ExternalVariable)
                return UnknownValue;
            if (variable instanceof SyntheticNamedExportVariable)
                return UnknownValue;
            return !!variable;
        }
        const rightValue = this.right.getLiteralValueAtPath(EMPTY_PATH, recursionTracker, origin);
        if (typeof rightValue === 'symbol')
            return UnknownValue;
        const operatorFunction = binaryOperators[this.operator];
        if (!operatorFunction)
            return UnknownValue;
        return operatorFunction(leftValue, rightValue);
    }
    getRenderedLiteralValue() {
        // Only optimize `'export' in ns`
        if (this.operator !== 'in' || !(this.right.variable instanceof NamespaceVariable)) {
            return UnknownValue;
        }
        if (this.renderedLiteralValue !== UNASSIGNED$1)
            return this.renderedLiteralValue;
        return (this.renderedLiteralValue = getRenderedLiteralValue(this.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this)));
    }
    hasEffects(context) {
        // support some implicit type coercion runtime errors
        if (this.operator === '+' &&
            this.parent instanceof ExpressionStatement &&
            this.left.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this) === '') {
            return true;
        }
        return super.hasEffects(context);
    }
    hasEffectsOnInteractionAtPath(path, { type }) {
        return type !== INTERACTION_ACCESSED || path.length > 1;
    }
    include(context, includeChildrenRecursively, options) {
        if (!this.included)
            this.includeNode(context);
        if (typeof this.getRenderedLiteralValue() === 'symbol') {
            this.left.include(context, includeChildrenRecursively, options);
            this.right.include(context, includeChildrenRecursively, options);
            // `instanceof` will attempt to call RHS's `Symbol.hasInstance` if it exists.
            if (this.operator === 'instanceof')
                this.right.includePath(INSTANCEOF_PATH, context);
        }
    }
    includeNode(context) {
        this.included = true;
        if (this.operator === 'in' && typeof this.getRenderedLiteralValue() === 'symbol') {
            this.right.includePath(UNKNOWN_PATH, context);
        }
    }
    removeAnnotations(code) {
        this.left.removeAnnotations(code);
    }
    render(code, options, { renderedSurroundingElement } = BLANK) {
        const renderedLiteralValue = this.getRenderedLiteralValue();
        if (typeof renderedLiteralValue !== 'symbol') {
            code.overwrite(this.start, this.end, renderedLiteralValue);
        }
        else {
            this.left.render(code, options, { renderedSurroundingElement });
            this.right.render(code, options);
        }
    }
}
BinaryExpression.prototype.applyDeoptimizations = doNotDeoptimize;

class BreakStatement extends NodeBase {
    hasEffects(context) {
        if (this.label) {
            if (!context.ignore.labels.has(this.label.name))
                return true;
            context.includedLabels.add(this.label.name);
        }
        else {
            if (!context.ignore.breaks)
                return true;
            context.hasBreak = true;
        }
        context.brokenFlow = true;
        return false;
    }
    include(context, includeChildrenRecursively) {
        this.included = true;
        if (this.label) {
            this.label.include(context, includeChildrenRecursively);
            context.includedLabels.add(this.label.name);
        }
        else {
            context.hasBreak = true;
        }
        context.brokenFlow = true;
    }
}
BreakStatement.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
BreakStatement.prototype.applyDeoptimizations = doNotDeoptimize;

function renderCallArguments(code, options, node) {
    if (node.arguments.length > 0) {
        if (node.arguments[node.arguments.length - 1].included) {
            for (const argument of node.arguments) {
                argument.render(code, options);
            }
        }
        else {
            let lastIncludedIndex = node.arguments.length - 2;
            while (lastIncludedIndex >= 0 && !node.arguments[lastIncludedIndex].included) {
                lastIncludedIndex--;
            }
            if (lastIncludedIndex >= 0) {
                for (let index = 0; index <= lastIncludedIndex; index++) {
                    node.arguments[index].render(code, options);
                }
                code.remove(findFirstOccurrenceOutsideComment(code.original, ',', node.arguments[lastIncludedIndex].end), node.end - 1);
            }
            else {
                code.remove(findFirstOccurrenceOutsideComment(code.original, '(', node.callee.end) + 1, node.end - 1);
            }
        }
    }
}

class CallExpressionBase extends NodeBase {
    constructor() {
        super(...arguments);
        this.returnExpression = null;
        this.deoptimizableDependentExpressions = [];
        this.expressionsToBeDeoptimized = new Set();
    }
    deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker) {
        const { args } = interaction;
        const [returnExpression, isPure] = this.getReturnExpression(recursionTracker);
        if (isPure)
            return;
        const deoptimizedExpressions = args.filter(expression => !!expression && expression !== UNKNOWN_EXPRESSION);
        if (deoptimizedExpressions.length === 0)
            return;
        if (returnExpression === UNKNOWN_EXPRESSION) {
            for (const expression of deoptimizedExpressions) {
                expression.deoptimizePath(UNKNOWN_PATH);
            }
        }
        else {
            recursionTracker.withTrackedEntityAtPath(path, returnExpression, () => {
                for (const expression of deoptimizedExpressions) {
                    this.expressionsToBeDeoptimized.add(expression);
                }
                returnExpression.deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker);
            }, null);
        }
    }
    deoptimizeCache() {
        if (this.returnExpression?.[0] !== UNKNOWN_EXPRESSION) {
            this.returnExpression = UNKNOWN_RETURN_EXPRESSION;
            const { deoptimizableDependentExpressions, expressionsToBeDeoptimized } = this;
            this.expressionsToBeDeoptimized = EMPTY_SET;
            this.deoptimizableDependentExpressions = EMPTY_ARRAY;
            for (const expression of deoptimizableDependentExpressions) {
                expression.deoptimizeCache();
            }
            for (const expression of expressionsToBeDeoptimized) {
                expression.deoptimizePath(UNKNOWN_PATH);
            }
        }
    }
    deoptimizePath(path) {
        if (path.length === 0 ||
            this.scope.context.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(path, this)) {
            return;
        }
        const [returnExpression] = this.getReturnExpression();
        if (returnExpression !== UNKNOWN_EXPRESSION) {
            returnExpression.deoptimizePath(path);
        }
    }
    getLiteralValueAtPath(path, recursionTracker, origin) {
        const [returnExpression] = this.getReturnExpression(recursionTracker);
        if (returnExpression === UNKNOWN_EXPRESSION) {
            return UnknownValue;
        }
        return recursionTracker.withTrackedEntityAtPath(path, returnExpression, () => {
            this.deoptimizableDependentExpressions.push(origin);
            return returnExpression.getLiteralValueAtPath(path, recursionTracker, origin);
        }, UnknownValue);
    }
    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
        const returnExpression = this.getReturnExpression(recursionTracker);
        if (returnExpression[0] === UNKNOWN_EXPRESSION) {
            return returnExpression;
        }
        return recursionTracker.withTrackedEntityAtPath(path, returnExpression, () => {
            this.deoptimizableDependentExpressions.push(origin);
            const [expression, isPure] = returnExpression[0].getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
            return [expression, isPure || returnExpression[1]];
        }, UNKNOWN_RETURN_EXPRESSION);
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        const { type } = interaction;
        if (type === INTERACTION_CALLED) {
            const { args, withNew } = interaction;
            if ((withNew ? context.instantiated : context.called).trackEntityAtPathAndGetIfTracked(path, args, this)) {
                return false;
            }
        }
        else if ((type === INTERACTION_ASSIGNED
            ? context.assigned
            : context.accessed).trackEntityAtPathAndGetIfTracked(path, this)) {
            return false;
        }
        const [returnExpression, isPure] = this.getReturnExpression();
        return ((type === INTERACTION_ASSIGNED || !isPure) &&
            returnExpression.hasEffectsOnInteractionAtPath(path, interaction, context));
    }
}

class CallExpression extends CallExpressionBase {
    get hasCheckedForWarnings() {
        return isFlagSet(this.flags, 134217728 /* Flag.checkedForWarnings */);
    }
    set hasCheckedForWarnings(value) {
        this.flags = setFlag(this.flags, 134217728 /* Flag.checkedForWarnings */, value);
    }
    get optional() {
        return isFlagSet(this.flags, 128 /* Flag.optional */);
    }
    set optional(value) {
        this.flags = setFlag(this.flags, 128 /* Flag.optional */, value);
    }
    bind() {
        super.bind();
        this.interaction = {
            args: [
                this.callee instanceof MemberExpression && !this.callee.variable
                    ? this.callee.object
                    : null,
                ...this.arguments
            ],
            type: INTERACTION_CALLED,
            withNew: false
        };
    }
    getLiteralValueAtPathAsChainElement(path, recursionTracker, origin) {
        return getChainElementLiteralValueAtPath(this, this.callee, path, recursionTracker, origin);
    }
    hasEffects(context) {
        if (!this.deoptimized)
            this.applyDeoptimizations();
        for (const argument of this.arguments) {
            if (argument.hasEffects(context))
                return true;
        }
        if (this.annotationPure) {
            return false;
        }
        return (this.callee.hasEffects(context) ||
            this.callee.hasEffectsOnInteractionAtPath(EMPTY_PATH, this.interaction, context));
    }
    hasEffectsAsChainElement(context) {
        const calleeHasEffects = 'hasEffectsAsChainElement' in this.callee
            ? this.callee.hasEffectsAsChainElement(context)
            : this.callee.hasEffects(context);
        if (calleeHasEffects === IS_SKIPPED_CHAIN)
            return IS_SKIPPED_CHAIN;
        if (this.optional &&
            this.callee.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this) == null) {
            return (!this.annotationPure && calleeHasEffects) || IS_SKIPPED_CHAIN;
        }
        // We only apply deoptimizations lazily once we know we are not skipping
        if (!this.deoptimized)
            this.applyDeoptimizations();
        for (const argument of this.arguments) {
            if (argument.hasEffects(context))
                return true;
        }
        return (!this.annotationPure &&
            (calleeHasEffects ||
                this.callee.hasEffectsOnInteractionAtPath(EMPTY_PATH, this.interaction, context)));
    }
    include(context, includeChildrenRecursively) {
        if (!this.included)
            this.includeNode(context);
        if (includeChildrenRecursively) {
            super.include(context, true);
            if (includeChildrenRecursively === INCLUDE_PARAMETERS &&
                this.callee instanceof Identifier &&
                this.callee.variable) {
                this.callee.variable.markCalledFromTryStatement();
            }
        }
        else {
            this.callee.include(context, false);
            this.callee.includeCallArguments(this.interaction, context);
        }
    }
    includeNode(_context) {
        this.included = true;
        if (!this.deoptimized)
            this.applyDeoptimizations();
    }
    initialise() {
        super.initialise();
        if (this.annotations &&
            this.scope.context.options.treeshake.annotations) {
            this.annotationPure = this.annotations.some(comment => comment.type === 'pure');
        }
    }
    render(code, options, { renderedSurroundingElement } = BLANK) {
        this.callee.render(code, options, {
            isCalleeOfRenderedParent: true,
            renderedSurroundingElement
        });
        renderCallArguments(code, options, this);
        if (this.callee instanceof Identifier && !this.hasCheckedForWarnings) {
            this.hasCheckedForWarnings = true;
            const variable = this.scope.findVariable(this.callee.name);
            if (variable.isNamespace) {
                this.scope.context.log(LOGLEVEL_WARN, logCannotCallNamespace(this.callee.name), this.start);
            }
            if (this.callee.name === 'eval') {
                this.scope.context.log(LOGLEVEL_WARN, logEval(this.scope.context.module.id), this.start);
            }
        }
    }
    applyDeoptimizations() {
        this.deoptimized = true;
        this.callee.deoptimizeArgumentsOnInteractionAtPath(this.interaction, EMPTY_PATH, SHARED_RECURSION_TRACKER);
        this.scope.context.requestTreeshakingPass();
    }
    getReturnExpression(recursionTracker = SHARED_RECURSION_TRACKER) {
        if (this.returnExpression === null) {
            this.returnExpression = UNKNOWN_RETURN_EXPRESSION;
            return (this.returnExpression = this.callee.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, this.interaction, recursionTracker, this));
        }
        return this.returnExpression;
    }
}

class CatchClause extends NodeBase {
    createScope(parentScope) {
        this.scope = new ParameterScope(parentScope, true);
    }
    parseNode(esTreeNode) {
        const { body, param, type } = esTreeNode;
        this.type = type;
        if (param) {
            this.param = new (this.scope.context.getNodeConstructor(param.type))(this, this.scope).parseNode(param);
            this.param.declare('parameter', EMPTY_PATH, UNKNOWN_EXPRESSION);
        }
        this.body = new BlockStatement(this, this.scope.bodyScope).parseNode(body);
        return super.parseNode(esTreeNode);
    }
}
CatchClause.prototype.preventChildBlockScope = true;
CatchClause.prototype.includeNode = onlyIncludeSelf;

class ChainExpression extends NodeBase {
    // deoptimizations are not relevant as we are not caching values
    deoptimizeCache() { }
    getLiteralValueAtPath(path, recursionTracker, origin) {
        const literalValue = this.expression.getLiteralValueAtPathAsChainElement(path, recursionTracker, origin);
        return literalValue === IS_SKIPPED_CHAIN ? undefined : literalValue;
    }
    hasEffects(context) {
        return this.expression.hasEffectsAsChainElement(context) === true;
    }
    includePath(path, context) {
        this.included = true;
        this.expression.includePath(path, context);
    }
    removeAnnotations(code) {
        this.expression.removeAnnotations(code);
    }
}
ChainExpression.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
ChainExpression.prototype.applyDeoptimizations = doNotDeoptimize;

class ClassBodyScope extends ChildScope {
    constructor(parent, classNode) {
        const { context } = parent;
        super(parent, context);
        this.variables.set('this', (this.thisVariable = new LocalVariable('this', null, classNode, EMPTY_PATH, context, 'other')));
        this.instanceScope = new ChildScope(this, context);
        this.instanceScope.variables.set('this', new ThisVariable(context));
    }
    findLexicalBoundary() {
        return this;
    }
}

class ClassBody extends NodeBase {
    createScope(parentScope) {
        this.scope = new ClassBodyScope(parentScope, this.parent);
    }
    include(context, includeChildrenRecursively) {
        this.included = true;
        this.scope.context.includeVariableInModule(this.scope.thisVariable, UNKNOWN_PATH, context);
        for (const definition of this.body) {
            definition.include(context, includeChildrenRecursively);
        }
    }
    parseNode(esTreeNode) {
        const body = (this.body = new Array(esTreeNode.body.length));
        let index = 0;
        for (const definition of esTreeNode.body) {
            body[index++] = new (this.scope.context.getNodeConstructor(definition.type))(this, definition.static ? this.scope : this.scope.instanceScope).parseNode(definition);
        }
        return super.parseNode(esTreeNode);
    }
}
ClassBody.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
ClassBody.prototype.applyDeoptimizations = doNotDeoptimize;

class ClassExpression extends ClassNode {
    render(code, options, { renderedSurroundingElement } = BLANK) {
        super.render(code, options);
        if (renderedSurroundingElement === ExpressionStatement$1) {
            code.appendRight(this.start, '(');
            code.prependLeft(this.end, ')');
        }
    }
}

function tryCastLiteralValueToBoolean(literalValue) {
    if (typeof literalValue === 'symbol') {
        if (literalValue === UnknownFalsyValue) {
            return false;
        }
        if (literalValue === UnknownTruthyValue) {
            return true;
        }
        return UnknownValue;
    }
    return !!literalValue;
}

class MultiExpression extends ExpressionEntity {
    constructor(expressions) {
        super();
        this.expressions = expressions;
    }
    deoptimizePath(path) {
        for (const expression of this.expressions) {
            expression.deoptimizePath(path);
        }
    }
    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
        return [
            new MultiExpression(this.expressions.map(expression => expression.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin)[0])),
            false
        ];
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        for (const expression of this.expressions) {
            if (expression.hasEffectsOnInteractionAtPath(path, interaction, context))
                return true;
        }
        return false;
    }
}

class ConditionalExpression extends NodeBase {
    constructor() {
        super(...arguments);
        this.expressionsToBeDeoptimized = [];
        this.usedBranch = null;
    }
    get isBranchResolutionAnalysed() {
        return isFlagSet(this.flags, 65536 /* Flag.isBranchResolutionAnalysed */);
    }
    set isBranchResolutionAnalysed(value) {
        this.flags = setFlag(this.flags, 65536 /* Flag.isBranchResolutionAnalysed */, value);
    }
    get hasDeoptimizedCache() {
        return isFlagSet(this.flags, 33554432 /* Flag.hasDeoptimizedCache */);
    }
    set hasDeoptimizedCache(value) {
        this.flags = setFlag(this.flags, 33554432 /* Flag.hasDeoptimizedCache */, value);
    }
    deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker) {
        this.consequent.deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker);
        this.alternate.deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker);
    }
    deoptimizeCache() {
        if (this.hasDeoptimizedCache)
            return;
        this.hasDeoptimizedCache = true;
        if (this.usedBranch !== null) {
            const unusedBranch = this.usedBranch === this.consequent ? this.alternate : this.consequent;
            this.usedBranch = null;
            unusedBranch.deoptimizePath(UNKNOWN_PATH);
            if (this.included) {
                unusedBranch.includePath(UNKNOWN_PATH, createInclusionContext());
            }
            const { expressionsToBeDeoptimize