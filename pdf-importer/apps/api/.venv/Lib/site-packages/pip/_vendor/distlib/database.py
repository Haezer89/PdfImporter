# -*- coding: utf-8 -*-
#
# Copyright (C) 2012-2017 The Python Software Foundation.
# See LICENSE.txt and CONTRIBUTORS.txt.
#
"""PEP 376 implementation."""

from __future__ import unicode_literals

import base64
import codecs
import contextlib
import hashlib
import logging
import os
import posixpath
import sys
import zipimport

from . import DistlibException, resources
from .compat import StringIO
from .version import get_scheme, UnsupportedVersionError
from .metadata import (Metadata, METADATA_FILENAME, WHEEL_METADATA_FILENAME,
                       LEGACY_METADATA_FILENAME)
from .util import (parse_requirement, cached_property, parse_name_and_version,
                   read_exports, write_exports, CSVReader, CSVWriter)


__all__ = ['Distribution', 'BaseInstalledDistribution',
           'InstalledDistribution', 'EggInfoDistribution',
           'DistributionPath']


logger = logging.getLogger(__name__)

EXPORTS_FILENAME = 'pydist-exports.json'
COMMANDS_FILENAME = 'pydist-commands.json'

DIST_FILES = ('INSTALLER', METADATA_FILENAME, 'RECORD', 'REQUESTED',
              'RESOURCES', EXPORTS_FILENAME, 'SHARED')

DISTINFO_EXT = '.dist-info'


class _Cache(object):
    """
    A simple cache mapping names and .dist-info paths to distributions
    """
    def __init__(self):
        """
        Initialise an instance. There is normally one for each DistributionPath.
        """
        self.name = {}
        self.path = {}
        self.generated = False

    def clear(self):
        """
        Clear the cache, setting it to its initial state.
        """
        self.name.clear()
        self.path.clear()
        self.generated = False

    def add(self, dist):
        """
        Add a distribution to the cache.
        :param dist: The distribution to add.
        """
        if dist.path not in self.path:
            self.path[dist.path] = dist
            self.name.setdefault(dist.key, []).append(dist)


class DistributionPath(object):
    """
    Represents a set of distributions installed on a path (typically sys.path).
    """
    def __init__(self, path=None, include_egg=False):
        """
        Create an instance from a path, optionally including legacy (distutils/
        setuptools/distribute) distributions.
        :param path: The path to use, as a list of directories. If not specified,
                     sys.path is used.
        :param include_egg: If True, this instance will look for and return legacy
                            distributions as well as those based on PEP 376.
        """
        if path is None:
            path = sys.path
        self.path = path
        self._include_dist = True
        self._include_egg = include_egg

        self._cache = _Cache()
        self._cache_egg = _Cache()
        self._cache_enabled = True
        self._scheme = get_scheme('default')

    def _get_cache_enabled(self):
        return self._cache_enabled

    def _set_cache_enabled(self, value):
        self._cache_enabled = value

    cache_enabled = property(_get_cache_enabled, _set_cache_enabled)

    def clear_cache(self):
        """
        Clears the internal cache.
        """
        self._cache.clear()
        self._cache_egg.clear()


    def _yield_distributions(self):
        """
        Yield .dist-info and/or .egg(-info) distributions.
        """
        # We need to check if we've seen some resources already, because on
        # some Linux systems (e.g. some Debian/Ubuntu variants) there are
        # symlinks which alias other files in the environment.
        seen = set()
        for path in self.path:
            finder = resources.finder_for_path(path)
            if finder is None:
                continue
            r = finder.find('')
            if not r or not r.is_container:
                continue
            rset = sorted(r.resources)
            for entry in rset:
                r = finder.find(entry)
                if not r or r.path in seen:
                    continue
                try:
                    if self._include_dist and entry.endswith(DISTINFO_EXT):
   AL;
        const brace = braces[braces.length - 1];
        prev.type = 'dots';
        prev.output += value;
        prev.value += value;
        brace.dots = true;
        continue;
      }

      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {
        push({ type: 'text', value, output: DOT_LITERAL });
        continue;
      }

      push({ type: 'dot', value, output: DOT_LITERAL });
      continue;
    }

    /**
     * Question marks
     */

    if (value === '?') {
      const isGroup = prev && prev.value === '(';
      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('qmark', value);
        continue;
      }

      if (prev && prev.type === 'paren') {
        const next = peek();
        let output = value;

        if (next === '<' && !utils.supportsLookbehinds()) {
          throw new Error('Node.js v10 or higher is required for regex lookbehinds');
        }

        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\w+>)/.test(remaining()))) {
          output = `\\${value}`;
        }

        push({ type: 'text', value, output });
        continue;
      }

      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {
        push({ type: 'qmark', value, output: QMARK_NO_DOT });
        continue;
      }

      push({ type: 'qmark', value, output: QMARK });
      continue;
    }

    /**
     * Exclamation
     */

    if (value === '!') {
      if (opts.noextglob !== true && peek() === '(') {
        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
          extglobOpen('negate', value);
          continue;
        }
      }

      if (opts.nonegate !== true && state.index === 0) {
        negate();
        continue;
      }
    }

    /**
     * Plus
     */

    if (value === '+') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('plus', value);
        continue;
      }

      if ((prev && prev.value === '(') || opts.regex === false) {
        push({ type: 'plus', value, output: PLUS_LITERAL });
        continue;
      }

      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {
        push({ type: 'plus', value });
        continue;
      }

      push({ type: 'plus', value: PLUS_LITERAL });
      continue;
    }

    /**
     * Plain text
     */

    if (value === '@') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        push({ type: 'at', extglob: true, value, output: '' });
        continue;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Plain text
     */

    if (value !== '*') {
      if (value === '$' || value === '^') {
        value = `\\${value}`;
      }

      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
      if (match) {
        value += match[0];
        state.index += match[0].length;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Stars
     */

    if (prev && (prev.type === 'globstar' || prev.star === true)) {
      prev.type = 'star';
      prev.star = true;
      prev.value += value;
      prev.output = star;
      state.backtrack = true;
      state.globstar = true;
      consume(value);
      continue;
    }

    let rest = remaining();
    if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
      extglobOpen('star', value);
      continue;
    }

    if (prev.type === 'star') {
      if (opts.noglobstar === true) {
        consume(value);
        continue;
      }

      const prior = prev.prev;
      const before = prior.prev;
      const isStart = prior.type === 'slash' || prior.type === 'bos';
      const afterStar = before && (before.type === 'star' || before.type === 'globstar');

      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {
        push({ type: 'star', value, output: '' });
        continue;
      }

      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');
      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');
      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {
        push({ type: 'star', value, output: '' });
        continue;
      }

      // strip consecutive `/**/`
      while (rest.slice(0, 3) === '/**') {
        const after = input[state.index + 4];
        if (after && after !== '/') {
          break;
        }
        rest = rest.slice(3);
        consume('/**', 3);
      }

      if (prior.type === 'bos' && eos()) {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = globstar(opts);
        state.output = prev.output;
        state.globstar = true;
        consume(value);
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {
        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;

        prev.type = 'globstar';
        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');
        prev.value += value;
        state.globstar = true;
        state.output += prior.output + prev.output;
        consume(value);
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {
        const end = rest[1] !== void 0 ? '|$' : '';

        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;

        prev.type = 'globstar';
        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
        prev.value += value;

        state.output += prior.output + prev.output;
        state.globstar = true;

        consume(value + advance());

        push({ type: 'slash', value: '/', output: '' });
        continue;
      }

      if (prior.type === 'bos' && rest[0] === '/') {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
        state.output = prev.output;
        state.globstar = true;
        consume(value + advance());
        push({ type: 'slash', value: '/', output: '' });
        continue;
      }

      // remove single star from output
      state.output = state.output.slice(0, -prev.output.length);

      // reset previous token to globstar
      prev.type = 'globstar';
      prev.output = globstar(opts);
      prev.value += value;

      // reset output with globstar
      state.output += prev.output;
      state.globstar = true;
      consume(value);
      continue;
    }

    const token = { type: 'star', value, output: star };

    if (opts.bash === true) {
      token.output = '.*?';
      if (prev.type === 'bos' || prev.type === 'slash') {
        token.output = nodot + token.output;
      }
      push(token);
      continue;
    }

    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {
      token.output = value;
      push(token);
      continue;
    }

    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {
      if (prev.type === 'dot') {
        state.output += NO_DOT_SLASH;
        prev.output += NO_DOT_SLASH;

      } else if (opts.dot === true) {
        state.output += NO_DOTS_SLASH;
        prev.output += NO_DOTS_SLASH;

      } else {
        state.output += nodot;
        prev.output += nodot;
      }

      if (peek() !== '*') {
        state.output += ONE_CHAR;
        prev.output += ONE_CHAR;
      }
    }

    push(token);
  }

  while (state.brackets > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));
    state.output = utils.escapeLast(state.output, '[');
    decrement('brackets');
  }

  while (state.parens > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));
    state.output = utils.escapeLast(state.output, '(');
    decrement('parens');
  }

  while (state.braces > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));
    state.output = utils.escapeLast(state.output, '{');
    decrement('braces');
  }

  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {
    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });
  }

  // rebuild the output if we had to backtrack at any point
  if (state.backtrack === true) {
    state.output = '';

    for (const token of state.tokens) {
      state.output += token.output != null ? token.output : token.value;

      if (token.suffix) {
        state.output += token.suffix;
      }
    }
  }

  return state;
};

/**
 * Fast paths for creating regular expressions for common glob patterns.
 * This can significantly speed up processing and has very little downside
 * impact when none of the fast paths match.
 */

parse.fastpaths = (input, options) => {
  const opts = { ...options };
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  const len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  input = REPLACEMENTS[input] || input;
  const win32 = utils.isWindows(options);

  // create constants based on platform, for windows or posix
  const {
    DOT_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOTS_SLASH,
    STAR,
    START_ANCHOR
  } = constants.globChars(win32);

  const nodot = opts.dot ? NO_DOTS : NO_DOT;
  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
  const capture = opts.capture ? '' : '?:';
  const state = { negated: false, prefix: '' };
  let star = opts.bash === true ? '.*?' : STAR;

  if (opts.capture) {
    star = `(${star})`;
  }

  const globstar = opts => {
    if (opts.noglobstar === true) return star;
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const create = str => {
    switch (str) {
      case '*':
        return `${nodot}${ONE_CHAR}${star}`;

      case '.*':
        return `${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '*.*':
        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '*/*':
        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;

      case '**':
        return nodot + globstar(opts);

      case '**/*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;

      case '**/*.*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '**/.*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;

      default: {
        const match = /^(.*?)\.(\w+)$/.exec(str);
        if (!match) return;

        const source = create(match[1]);
        if (!source) return;

        return source + DOT_LITERAL + match[2];
      }
    }
  };

  const output = utils.removePrefix(input, state);
  let source = create(output);

  if (source && opts.strictSlashes !== true) {
    source += `${SLASH_LITERAL}?`;
  }

  return source;
};

module.exports = parse;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ¥ôÿO¹Q1ÕCB«ğÌë×•^í´9ß¡ıì×blÄˆ†Ú”Œv‹%ÖækÓoÀô}»>yÃ/8øm^U©‹ŒëYºóâ¤†É`†ucoÂFfU%]ÇúÛš3÷A WmçÑéİ­2áq=N ĞœO$-i”°¯Ïí²ÀùÄ:›wé08npî«êr3Üjïëö´FvĞÿ}È§^[¸$5Ç%Ô¡ßÇı Ÿ¡©ÇTÓ×
ùR‘(½à‡ğgµñæhœ]æÊÛ®H£¢rÍ¥â0o–DJÿÛëÉ÷•>î´Â¼_ºÀóZl÷=)0´PĞß©»òK`gÒÑÈê´¿cÉ¤Ñwäì$éÃÖHˆ=Ï 
9;l©ï´yÕ/´“pÀã&~ø*éè„ /µÖŠBYßı×ºªÒş‹„:ö~’=šçâZ¹GR´?›“´ÿ…æ¥tæ­kÍ…4p
‰k—@šB<ßsİÔÃƒëo ßœ(º¶£cåzË@ü¡? €:ÏAyù±<[WViúÖ7!N%d:íä¨"éi“Ä·mØZÃ•ÚEtêú<sÿG™‰»åU£SyÕK:¾"Ä@ˆ`9%GˆaŠ¶ˆÅş”Òo+0K˜ø)~ŠİiÒdˆıíLÎmpÙÊp ‹Ÿ–æ4/ c(˜Æ¤w¼Q1¸Š
Ùa»ÎÀg»Ü¡aÜ©·ººB,ã }µPgD«fÃú>/ö×Ñwã²%êŞÖŞ–àUœŸğ© nâ|ˆ=çËXBxøö¾½$FŒøñ õA¹¬CÄô/šq'¬¾jfçİ¿%uÎbØµĞÚË!ÛßÀE^,¿ø–‘ôà¼é/ŠŸt 3Mk½(øfdzM&<Tnİ#¦!;óaHpëw™
Èû†!Æà…ŸÎíÁ¹h³;3pS¥NÉ¬1S¶®«Ñ­Ÿ†ğS÷b¶[ƒ…°H¾æÃÏ_ÒXR"ßêlHq²º˜>UBş&&æ¾Cßİ¢æÇÜ5Û+PwxE¬õ1ÚßIZÁIËô3›|ÍÙøïÖ…ğûÍ€[÷“”AiùOWîeì+WM¯AĞ,,K´SV¸­¯®vÖ÷–)à.+ ó¾T`Á+äæCWÑŒ*.†€[«Şhí»KŸÇDÌä¥¸’õ›İ57d©c4ÚŞtÏ¹ön™7šÿæ“Sdulûû¥5ZO¬İ5õZÔ{ÄxE nº1Ç"šÄ˜	\*"ãyØ-Š4|`b³¸n“ÔŸgà¨|;ÿk]MdWéûŠÈ]¥ÆÙOJi}ïbºÕîÕ¿ø-ÌÖ‚Ü¼!1#k}—Kp¤6Yf½‘}éê¤(ø`ï•|:]>½má!A3æt©hYşy§D¶X÷3Ç`ÿO3}å³Íyä¼}åa«”ëp%âƒ¬èIy”ÃRœøüµŸ… Xi?ıàïòÎø?Mc’Âo")¸6\2R,kĞl–3P1ãyÓt~í¨‹XÛJŞ«n•!'hğà£ó	§uWFŸ#î»N¯€šyÒ7l"K}Od-Äìª¼&×ÂCx×Kª[†7É4`\ÏÑ0
œã>'‡AâBD™æµP LV9’#VuŸ³ç|s4E?±½ábCxı¡°.M——cCj¼‘³«$`ÉĞ†¯ª·tï8»ú]£oš•ìÁ6±¥›MÇvéd#Šáf|„HÏ€:`ï(MıpfúĞ"´$•\±ƒCAª]lÕİñKx “±½·¾ı+H¾-yEbƒ+œƒ“á.m˜í:/?‚‰‰'ä#$ãf¬[âÄ;[ıñv_¸WVòZĞìfêÒ²WåöØAX¦ÁëN)ö,¾Ã‚F½Ã†ÃÇöú¬82ô×‘t…)¡cÍÛ7éNM½4t~ T}~Ê<·äßÅÑƒLN¶Ş¿F´OËìÈğËìJ™Ù(³R&9ıb£V`!İrh­bìÈŸ ù]Å‹ QŞîÍjñJÈÿúÊ%7!¹o¥d½BÔ„x%‰ZÒQAëÖÖ¸îWÏâwô6:v"í97ùY¥2yı½~‹¡ŸšUs3j>6-_ÓˆîÄªrj¹ÏÄUl;:ßq]ä6È€nü²<ñTùVh_ıB¯*7œ5á†òÏ0—úĞ›²zoY(g$Ïüªà¹Ò ½f•ÒÔÙ¹¹ÕnT’òhSCÓéÎ„bcoì¦’]tÔõ Û®°Ş(UE#6}áÂ£m˜8ôOx£ûç› :›>xëdÖº7–Ãc•oå,/+qŸK¦XÍÈz±Øœxÿ.¶İœİ¼!;ï¬.í+­ª>è{Ò1ã¥Û¬‚İôÒ«åùA=¹^§)0WÒÛÅ0G—w6¦¼š½c}ò„èy†‹ÃİùEdHDe´ö±±ZëS\N¬ úxÔ×Jh¼-äŸL÷{ã‰œñh‘ö›ªÇ•€ò„û*#ûİ¥ Â³¤ë>Ä%1%Ú5Ld“ $h¢V€¨ØŞ«‹ÈÆâå]ÿ\y JÂ•ècTï!ÑÚF÷ƒIÈ€ÉH/~ÒµAì‡~îØ0ül ÂÔ¡¸†€ş÷,©?¦Ó’ÃåÄG½}bîš˜şø£ıb›“÷ñ%BVhJıŒoaôHv<ÑY²‹y ?,b i÷k³V£\Âöó¦=İ	¶Ã¸ãé]V$~"ôR´Õ	Ò,üE­4ôğÛ±W>í±IzëšÁLÕD³ ’ÄÊ§ıäæ_EDŠ¾^Ù–­•D¼«ÔZÛŠ9E!4,„ŸÊTÆ¦4Ì	øŠéÓ5'ı˜”¬u·2äÍE`¹yfÙ`â¡Î§¦>äŞ¼L‰é!¯X~,böêÅ]ğ§ ¾0€-Ø¡€šĞ"Oİ‡…ªú6¶á<ÉC*ÖøŸ0û¢4GRµ•¸
Û¹á—0SË&#†ãma­(1·‹¾L&Ã <A]ø4ª†–Ç‘® P*:j ¼øzaQ9P¡éO1õ`¡Ôf{
úìTöUãŸ­¢â¦@­ÌMW'Íbg,W‘6Ï“XónÙãøéS€ÚnĞcSÅ€üÌ‹”:î»	OÕ®Ü©r­º]å#Œbéë6ÿMO‰ªG-T°»Ú”½lå©ßÏU™vBQ¬9¬]	ÁŠm½”»ÊâÜGòß`3w€ÏD%bf 0¤úUº‰B_Ù~‘Ä’ö•¦®ş°s¸æZ@dŞ($…rr¦²¥¦lTˆxÈ„¨%W¼ê¨áZ	yÁÙÓú ®Ä¾îZûÿü1‡~}§ŠM«‚óä·ïç^:ZØ ì#<ça4¨úE"—Àÿ×ÃÍRMgpfçÎ¼ùÂ±h‡VŒ/>?gààš(s‡@+eD'Şèë±#<`ÁwÎÑù'”òisé_\ĞVà£ªc»AeCPã[Ú=RÂãMYB/Bpz[T\ğ“?¥Ÿä»Û¢4ó÷
‹µuœ†Ô
ó‹-ée5Î¶+wQjq!~ÂNšâP@§aÚ«"ŠbeCî]l²v§ag>—5h :®İ9a#—šw›Pù¬o¬ä¹™MÚ,ÜêNg/¸Îüµømmjø¤k~B-€’Ù€VõH·€Õ3cB…«4ğ$0ÏÜøQÈØsittÀh°<Wİ¹ºwø2ó$µìËIõÇ0K¨%]„qÅ8Këı9bŞóIéÌã€9~‡ò£tÖ¥r@‰SãÒ
FÓõlvğYë`&Dã9\ÅG«{•9Ê
zûsJ:YgV+ÈÏÕBéÿ|=œ¡ÔE/õïLÃôGUl%¦ÿN¿ÌYqtÈu­œq7dÁoeVÇ9…•ñ÷há6h–å`Ğ§MÖŸ÷Vm–@@1İîD*˜Õë/Ø™|Oøk—><û´?,Ài )øŞGT.!Ìilt=†"£Ï_V³ıa,“B’Pæ¸îMz£%¸%7U‹ÆëÃ?aÜ”='ï]¤yŞG55X;Sa9Î-üi2÷suŒ#QÔDã˜­8ËíwMyÙÄ`˜[¼Ç•Ècôyk åÀÁ§’CêÔu¡ºi:\kL)jœñĞÚì¯ØƒKODwzÀu<oŞjŠÑz¹]e:ûxm¥´$ò£™ó†[šPõ£—OjRBÿÌqTŠÔ›+È÷)Çú°šŠòÏèôgí?¿$NÖ*×r¶D¼"I`ûM¹@wó5ä*/ë$ZåJtêñHìåŞµSÉ¥ ¨……8§÷¢TF¥©÷aÏÀŠ=Ğ7kºU–z3 íš'Õ2Äp¥<:€÷àQjr}h®n$¢…áÖPU½ËÊş§¶CÊ¹ğ=È±ÉEüÿ…%°W¿\Õêb”c€‚‰á¬l¡àVŞ{oQ^ô’8‚8%1ÁrWâçxZyÈUÈb ŞµµkGitÂr©ˆÆkàÑ>Öñ·/FZ
á°i›¬W«·Eûğ¥0šŒé]1ù%T#EÊÃ,mü½¡PTŸªÏâ6
H¼Z‘cåÍX½¬C±û æTÄğÆ/í^?<ìY/È»h?“¤ˆO‘×|×ÆzÇÅÁM Ğ\Dp$ãk¿©K¸µ
É @AzÂnSUöè6×ŞA»˜¶!Z *"m¦4TVœÑüzœÈ°¢ìÖt í"?Ìóık”Xá}òîv#“ğ.,	ğ#ÚÿtŸŒ`	“ÉöbØrl~vU¾Ï×jxùÔ‰oòù’²ğk35X$äšı—Š“9UæèªÖ5woèçÄg?şp‚ŞŒçI×è~¶«ª|›²¦·7<òV&½ßúÁmA™GB”á|æ,‘NÁ×†ì7b!zE€ú}84àñ~k¼¶ôG§ü µz²ä¹\
Jd<ui¼Y.ç©Xù· 08:³]É®éÕ~&±°·6ßKÈ‘)¦™…¾{€3é˜n#ÿ÷á—!Bu{¤¯÷Š*	¶ºí â'Õ1™‘ƒDŒ¶eI³vA”Š„é.ÀŒ{æßN9…İÑwk6ÊÓn—‡CsoiÂ`Yí¿5…˜s3¸µİœql(lºhl	lŸ‚„È\/BÚºW3ú0O‹==çE²®W^x(îÚæXìIDÔm,•¸3pº–ÉMg »»‘o‡ìrHDÁW£,³é Ö¹ÙRh£ÕkÂP'L¦P˜¿6bš&T‡şÈ-6¤Ãå‡mS¸0Uo2g_‡Ò~ˆÓx°ñu”Í˜úT™oº;“u“›‹Í‰ÃhÄFÆE(uY€¼Læ¯±åj”3USÔÎÖHÌˆüò!]çüKz,Vƒéôğf–ÕEDÄâû’# {³¦Y ¨M—ävb:6»er,3îc,;uÂj<qƒ&Íy±˜W™‰âƒªïş¡Yã¡-‰æùÂ–bCqÜE!KÉÃíq éÊKÂÍ(¿ÿky“öoHOcÈ±	>dTRV`æ†bj“fcŒR?£|äkĞK¯±å€›8Ôšü’ÄØ+`·ú(é^“vl°Î{O‚`}ù 2;(Øsã=š€p?T¤*`Âáå¸ğ·–­
’ÆÓ‰ß×œü+éÜc.×j	„Ë}ö¯Dig8ÇóA6¿×RùGÜ&•XrX<WÍ«j½íñ}ŒøWˆ£Ä&òwhª„pv1p»WsVé€fÌŞè“ÃA˜´‹C×€•Üşşëà(¥+³º0£:ë‡N7Êïç°ÄéFş»IÖ.°â¢ZE·Ù¢âÑ1½!d.»kTP¶È‰cñAVØ¹'xÒ§çv¬rbKZĞ‚nûø–t^0"`ÎnÜ™úM§!2 ìkZ†5ÙnÖ\Eı6ÿKÍ#"g-ÓÚ³_©¨&>Mê
q56Òú-¥ÁızhÌbTÜKÂdèÚÈYÌ2PzèCû“³”[Àz¬"±]«ÓFLŸlî{î81“û®*ı–İyg4Zh«A÷¶köeİrÌ.a\Îz£d
6ºRƒöZ€©h*½ ]¹¾¼¢g¦Ñçâ~’u> a'2t™kMGoøğc’3á=Õ]™
º„İåá|7hĞBlS¨¼¤´Å5Iß9ÊKpóüór÷e{¼ÿ^+=.ÑnÆ‘é¸‹§FüiOmğı’§Ò20ùÑfÛvr…_äUAUô{›ºìBQynÇ€¯j0…é/YlŸ»áE@éÇ?Qm–Bc7_d:“zt=å(m¤(:›'å{‚ú”Š?“çäÇĞm~ƒ?í6Q
áÒJJót·öµ-ïÑ 6ˆúã­¯öóB}[K´·¤5"ÿ¨/–Ğ:¤[K™f[˜ …++ËDaşñã¤Myğ5â
ŒÅ2|wÂRiİYTñgkôŒ 0ŸÅ”.`z’Ñ°{ÑZœ»¸ø1ôH¥Ÿ`Íê
<.‡QØÉêA!¶š¢ÍB®İf’Ä˜pGÜÓ/g²ŞÅğh}ç‡şÊöXrı»™šÑ‰1°šp;ÏæÜÜQÂÂoE.ˆàÄ±Š.]J4v­Dÿ#pùˆq¶~cìB÷«¯IéìûÍF¸[É7Şóp¥«\Û4Iùİ2ìOŞÁThÑÁbŸ)C›§×œÊXT†>2EBáeW€vfT¨5Şq»Ú­-ñIï`2DÂø:ì˜{ûŠÂNÎTbz˜tJóÃªòÕsæŠ¹ƒ!ĞfÇ·qÎD8
Ë¡ş9í£äg4ì`·Š90+‰ûš·<ˆNß!?#—w…İ;¨CAG ¡i—8B†˜g_ÎíÿÌ@§owR…4Õx·Ÿc%˜À¾{fjÓK„ŞzÓæn{ámec×ıx»ÿ_:¡FñĞ/ìƒ38ÄzÂQò‹•W‡À… $4@L€v‘œm LBxb{hMÍöØAÿqÚ%Rü¨÷:d»„Y¶zØ›?£¤Üoâkà”÷ó}GuKjë¡$:¼ôQßWÉ@ÚD³:D“<Ÿ±¥ÒEi¡j)MD“Êéê²?\±j¼·<£É')´»]~*¹B‘àb;ºxl áš"ã	«F78zS”ä/e§¸i®Oåa—wå•îLŒKqZœ”ÇNªú+`òá¾Ò!Xıï÷·X}ãÎõ+Fx7ĞÎ)­V¨917û¶“ö%u#Ó>H]eİÓƒ\Á‡ë—îwe W±ÍCî¹“|<Kğù€bë¸úæ\¿eO«åŞ›Í¿ÚÖbGëwgÀ_v·¾¦öÜf‡GnÌ±D4E§4<¬úfÏqÎëŸË¿Nİßf¨ƒ/x9µE¯Šh×yÖ9²yóÒ]ñç“›*ï|‰g‘÷®Ò©û4JíKşÊ'µ5À4]b"_TQæùÕ:.¿Àj—ö‡¹*ªUÖ«×Jé¥ .P¢
šÎÒì;›ÆÌC§	¯¼î>ŠòVv–Qt¬³lí
,äŞ>ù¥JM^
ú °P¡ imh¤ÁeÈTúfõşÆD¢`h(±@9VëØéuGÖ>,áWƒîqus«š×i¬Ä5™A@«Úêq¸ö+¡k…ñÀ ï»0ï4Tı?M®Ä¸ ¶‹A—³•PL$ó=UNòæÙØj¹şäTr‘4Õ•R”Ş·Õ	ĞëZÓbí­’ˆ´ ÒDçğ#¶*@óı›ë‚wv¶¦¡héã2´iÙ÷ÍäÓp„ÂîÏöë\x[«İt¥Bæ/À¯aëDOƒâ}¥ÅNßòpŠHÌ=’öúºİ:YºIŞv'PÅq¢
* jÀ˜íO¸ñsÏÌ#C¢¼\Ka2&5»ïçßDª-¼r…èµ(bìüİg3_©»
ƒÆ×ºìíÅ¯™º+åÁÆ)({À½ªåû·kŞ•Gğ¿2Boq“ÓÀÖ¼Óœ
(J Ë®Jn'@V„)¾NÖ½iá¡23|®Æˆ^©ÁÖ~€z¿fxÄ®·?p[(ÑÅJBú:òr¬,×QîÙî
îµ|Ó9oå¥A!2Æ	\o0}X6Y^-GU‰A{:@6J‹6­ev¬ˆÇT;¦L°Œ¾8p‰A(gõÏÁ<AµQcSoÄê–Ò‰¦F–’—şáíá?ÇUÊŠ‡BÈ|@«jT+²ëòÏ{á¡åŠ&ñÓ©wUŠã¿rÕ€TægSYÈøaê[¶ßHÙóÑXW‹òYäÌØØ8Ã©_,iØš…ºÙáRÖë_q¹„]Â…ù…1¶®{Î	—#|V¶¸Û»ÔùÍ
c&9‰åE½€Å‰§ˆ&°¹vÍ±æe‹Ã\Éš†dÒËÿoã.¨‹ŒŠßêo€nŒjÎä¹:·|ßù']™W»İhå@€~ùt¥sI1tÒà®ĞnÀÜ¾SŒïÌ¾D¾@­´ÜL	~eZ	…ÊWV.ÃÙ©&Î*O[F#dŸÃØÚ =`ƒºì.ñ"6Èí31uˆã¡"€G‘%Á‡ô$]ªŠnÕ2°yĞ9éPnf`uÛE\§ôwÎO—±2µÉ|Ø@ñN€)^×vÏCrFÍñfBF „_É6u½
¢ºW#èn>·{Büäq±.ü–{‘ëæ±İyFx™Î6Öy¬$pë¬ñGÒÖºjÊè¹¨‡²ÒGÃ³'Õ›^Ğ½,öñdiÎ;§“¾1 ÄœİÛfÓN©X{ÈkÃ2è_—ÏXw?=õÛ½Êsá…ØSÜ|¢6`ËíòŸj».ãÏ²°ğ¿kÜtçDv	lPY²o{g7…-²á’<«—Ô­VÕ#ùfõÜµtO§ÑMptû4X¼“	Æéó«Á´AiâÜÑ~|Aó*JùrYMs‚Äí/Ïö :Î®‡Ç›EË•ÎÆDf?Òº›—®‡ßöDí²¤Pugw±†­ãû#»KVUÙäê-îâO·‹û?e/”ÿw4_O§ƒ;\½Õy1n‘–ğcÑ’O$Û#øsìÿíp¹}É!õXæ£ÅÛà“@ïPŠëû§D.Çˆ8'Ó"cl<ËWJ{ÏşY§RG)ÅÑE·oÌş6ËmÙÖAŞ]âæiT0<vÕbS®(Ë=Ó!‹¬è ¥‰+:f£}mÖ7®V…Ü/Wú°ÄÕå¤e¹ ¡[¹”m„ëd1?4q¼Z«dú8şóŸ<9jB”%Ÿêt¥“jbĞ²¨ÆWèá/ÒÄP&F‡,òîæ35Ûn`¢:yÆÄUåEÏd!{y¶™3ùòCHìÎ‘xTpì_é³Ä4sÔqÖT(ÚòÓ˜Ù4ÅèŞ´Jƒ
âùC(tGíúTN€Ä9”Ğ–ŞÕ?ZĞ/7şr<Ñ+ÿø'ÖÚ™!
 'ñİ@÷wUÚÅ'Ü±`É¿RnDTä8'3&oŠÇ:Û˜¸kè†]w‡’Ï“,pù3a§¯âN)Á‰Ç£ƒ!1±nŞ¡­¹EéøN$©/ÿ°Ëâ€F;½¤¡Zù›¼È·£Ÿ^á—$°d†ÖOà+Ó@¥‘r¾µÙ`q“}Sotş•“ÚI®ËççÆ¬éÂSëi74ŸD€Sÿ4’ööªf|rÓ­ì³z„YŠÁÕıĞ9"şmSÒûçJs¸…Ô µVçk*bUì—ûÔuHÆùÌLÊcÀ<0¡º‰n³„Šlÿ'ÑÕ¬CÁwªYXKÃÒûåä3°–€1ºA>h—°8¾Íû5â\bêDŒ3”‰°ëçä­¬Ãn0@_µ¼¹A¹åÀ¬$ÃêåƒŸş|(°ö˜"îÃ†aì, YgìSãez¡±„ÇêÇá*EVÃ;òC]WCš[oÑ>œ4ÌJæ¬Î8IÅ±iu%Ì	ºRqÁ¸Ôîğ„y9B½Çzfš©{D\Yg‚]›ÍI ¢\lµ?ñ½jöèxã«ˆV‘oşåÂ^hcş<Ğ¤«öÚˆıTú{B˜µ²lßKèJ®TZö©xd!÷ÑfÅnBË‚„î½:™ê’4újmıÕ¼ïfÔKEdÇ0©µ…Ú&?³ìÎ’e¶—hÈv-œFÂçd/iÂÏÎ¿{Æ€(y*cÓòµì­°ï²w;«Æ( é°‡›äD±8mQğÑíí–Ÿšúô;3Ía§=%ğüğØ0ÈDäğTpñ6XV.nÓ{ˆjÎ‚Ï¡ÇG‰_„bˆh‹Ş¨‰¹âzp
›uê_eB
Pğ!¼C;)J# üJŠÛnì¥×DÜ3Ó_] Mãõ:ñ{aìƒ´4­_ÀúYÚˆ¼âè‚” VÃ
Ì¹bÛ¡&qëû÷,g¨(}¹½§šö£«ÏX†«*dü_ šDo*šá'Å`gSœU¶l+i)Ç×k>U4Œf…·ûÓY‹èÏÊqÇÀÓŞsèÚÑ-ƒ&l3i®˜´˜{,ˆï­ÒËY×N!‹Ùù­N5šĞmÌùv?AĞtÂÁ# Â^õqÚ³i+Ÿõ%çZ9Õ<\îÓ¹êÁâí›©0¼õZÄ!‹Ÿ, )ç¦8¦]E?Ø?mcæ± •¹Ô5ÎÈ4;VÎ `†—·Ä·‡¨WiL˜äoM6"{¥)ˆÃ•¾§ÿ÷g³1+«nû	o†ÉçÊÉÃr~¼¶Îã‰wŸ›5ÛÇäºTİŠ’h1ã7EJ
Ùl•«oUjPpÃˆ•3abÊîš¸m/×öh3•TªRHìÈäKé.;—/y<K„øk‘#è»Ì^Äî€z¡Möï›˜Ÿgæ( 1¬`Wªİ±ÃUC»‰éÎ3ÍÆ@©÷
N Y˜XæxÔnhºXj×•õ_9i¨ÏU¥]“,·ËsUf£ÔßŸ>‚ó )vŸ"5B´ò{Í+§¤‘Òl¸¦Ë‘­9°/×§×\¨«cwvZ%­z+Ø`~¯!ËÿVS"•PKÈ>•Û‹2‚m™¸ iÔü@iç	¡è3c˜vjş¼×°Ò°¾Ğ0ÁÏAi:Áö<æ”®ŠÌE¨`jU>³h²:-a×'—pt“2…®™œ/O-÷¸IÌ-hN7bõ–˜æ×œáØµX $ìëná¦TÜRB!¬Q—`WkPèY”¬ŸKXİC…‚ü[ÃQ21“ÈÑ²0¨f0N-Ì£ânHÀË¤>v¡¿©|TÒ%YE“ég?!¬¾ˆ˜½Ô¬äãŸw,»Ûî»İ%<Íî©–€M^)åÍ.»ì]“m’õ|q-ìıM]¢EË¶ÿ^Ü,a6x	Yz‘ícëXğ¯8JGHfóÆŠŞáã‰Pfß6"z’qc! ¸¬Ç¬‚rÉeİÖpº8ã_3ğÿ_ûÙ¾Ôğòé~¥ôµl”…%æªüÜO1¯„•úYkÔÒ¶ƒ:ß¹fZ{P2øÓ
"D ıgj•ôßézÑ”c¤÷Ó”BL÷mÒœ+¡ CòUAŒá9;gÚ}^UØÈz¨ÅmGŒH”SvhS(3›ÿˆÓ’ç³Lm(z}›Î
òÛ‚]ùeç%¥$T~³?òá#e8†z0U›OÄˆŒ³¬Ü÷3nHjµ;ïƒx]ªxVRvESı¸şqSçîø— j(§ïğƒ„­Ùt‡miŒB©¹Vì,3¹:Ø44MÓ¿èæ­ñ1w¯_ ²¯ùÄÜ`º7 —Ÿ¡ÓZuSJ2•`±52Nã®Xf	FÖ*®ø®¾‡aqœh:Áïs€á@Q «ñ°XøÓ}Xªì¬“'Ÿ@UŠ÷;´ªªÔ(²#?„œÌ&MéØuA•Íş©ù[Ã/Å%"ÊiÑÔ‡<Šè$(JQ`Çgd?-Ò©tT/Ôhí"ûFúb¬ú\dÛe…[OAÖğ1®ÖÊüÔzËÈ
yAdÉw¼Ò—s ®å¨ºQòÉ²x*ÏŒsğ¯h×ş¬§úh,AüOäg«™všÊ«Í} ±rg¹O¦,Aè!°½ñ&WO}êáşXÆËEºÍ?\§ùud)òş„ıœÖÒ.!q—ÅÓüòSåÁÜ¢­7°¥•%K¼èîOlì×*`‚S˜ÜÅÄÇæ—#LÏá|Î3úhµü<e•ï¦•“s=^+¾âšM!~[Ût¥¿ÑG÷ÙqSºÈC‚Z|Ôê³"Ô0„æÏóÙ\û³Xà¨ ğ
.;¡<˜ÀkHh§Šµb.ú°¿;îz–¬i
Å,IÈd±`u®
’’âZ§¡C¢"Á8_D˜Ñù
§ÉrŒBãÃÑÅªÅSÄ˜„ŸİÍ({ÜÒ1ÁØëdÃ\M@0ÒÆ5Ù… ì	ü”ÑzÛ§fç2FŒÜ+¬hªÕ)†çDg!P‰™¾²ibUŠ½ìj¨Ôõù? Î+é/¹&ÚYêwT	
BGLâÅİ<i $ws¯­6AaòŸ)±;]dôıUÒ™«»À¢	SÇÖûÍ"êG×¸Ê¡xùÒÒÅŞÎÜ4:Ù÷Ì)ì<ÜEêı}òW.VñS4¤J£L³r]¨nÊ,s[%5Ó“§Ğæ´Ä6ƒ©”~‹vƒâ1™Ï=qS…ºÄ<òNeÃÖ©ä½“ùDX¾x˜< ¹mş%SoH.g,?t°rÃéx¯rœ …¸vXÓÒ+_ä?n³µwè•j“vqaòÒ0"ÏmÓl^¬yøT=2…(÷dôÑ0ì÷ê#‡–Ö*B=‡„1c í™$øÄÔÄBÖ&*>&i›ıNB,ãIñ²o|±ÿ(N‚[<à´}´jc«] XoWP-¡P¤Ñ*0B!œ9	óŸöÄ.<7ÕßÁ„æ®M‰rìIÁôı²ÀÄ˜ú¸ß†ã]IH?dÇo–7óóLŞ "EX¬q!{!>+Öø@5¿…‰BÂøY›½™Åü.€?‚-€‚PÍú0ê³…ÅÌpZ}á
î‘ WğyúœÈ±÷î¶0RXsçHÖµÕB`àeäZKá[­iÔBäSã~a™qø–Ñ,s—W
ÏĞ¸õ‚®~N7áãÚ™*š¶v0rqLûÆFIø Óã+Ÿ.·l¶>4–JD.öªuj*âvª-"mà»^RÉ©€'ŒP¼±ËyèªÆ#›ãt à7C6’³PI‰û×8k³óÉİÃ8Š³^l¡ÂS€¿¦;CæO$ìüñ©Ü§¿Èƒ7_0¦ç¬²Şta[8”=¯vªWâ…DkfS%?B¬òÕõöª_ØHÏ¡(·N;Fö°`—®DpvÌ•Vöt„Èñ•:öKAæíDÀ*l¶áğE.]á›1¹ Ò-Ÿxg‹ofJ2_ìòfy:¹MÙ/”ÀY )`©±{ä*½†^ßT ;D®ø…¹ë8:&°xâĞN=`s¶Ö@‰@æò‘âJÔARGˆ?%‹êå*,èğ¿èG4h ìšÂóÚİ*”c	>1 —dç	àÖÎ_i‰±·î4_°·%]U¾'¹ù¼5ìšÈ<¬àøšÏ×µ¦€üUv i/)0!ÅK¸r¨°(ş¹L×àfÛŞ‡ÉÁ€ÅĞßfeH!H<¬¸qßç0ÇOñè¢I³›éş†2xëvÈ-ùe±RAL-¡=ÊÕ*—Î?ÁÿÜNÓLãYï{o¢ZvÃ³ãwüÆàü(Š±-Û\Üµ«™hj[ DƒÑfßN¤£hÉoU;-œoßû-÷âèÖğÜ=—]Jq#AôxPS±ZƒF¾…ßÖŞ Ÿ”Añ6‚VZ…Ü¸#vÃr9Ó7ğSl¦Úèº¡; ¤:â‰‰-¹®rçó8] ükºA1˜~/¸?æDvdE×•¾veÿº:İ²£™)`/„­ËmĞÎ£ÓÌÿq8RşI)¢iŸäé©ç¡#Ú§¾!Sóìö‰ÎGµxl—ƒFCSeŞ°ıÎzÙLFÍ ^çoû
yF¼qz¸ÿ7uà®-¢í@aÜÃıq’€è^AÏzHÉ%ì2
MÀ ã*"ÿÈ•36D­*Jw2-û&ÄÛfÎÌ&–*_'·©)«>èªœ@€¦olDÔœ>ÿåÎÜúÄ~`‡\B­ºZûQŒËé?:†âØ^IpİdÕĞ4YÛjrÄBóoÎşh‹,¹§…Î–
U¼ÒQ¸\gg
®§ÖF¹–±rCÑ)JêfÔWk~’÷¾şG—”‰‡™<&ñL¾9Ü‰Éôt˜+û9ojY4Hº8Ê¶[³N5fk…Z¾ü2Íöİ•	°Äº¡ X2šôè>ûáŒ2Ñ0ç‘#éW~D˜™	´¢ùPqHÃ_³æàWT_ß’J|² \<Òù$ÙÈ=ağce¢¢ÛÔ˜€¶˜v“F—¸C|œ3âÏğŸg:óÏLío«JFÏ,}¶6.à17lm}#•ÁU	Û¯è3î6kËü×`ûf¹»?¤DV±z?ÄøêâáîÆËŠµâK¯ç“t tİ²ñ‡’¨±éOwÈJzş¢öá£»Ê5&¸ıq-á07ÈR‡‘z¶K»-˜›BX
Iìùã	À	Xr§aÖ—ÕnÏ<IJ:Vi>`J>ÈÏ ôUŞ4…˜x'!§í³júÑ³CÇ4²î!ÙŞ2FïÕ–Ù›?bLÈŠÁòz¤ümãœŞHÄâT,|&Âwô~Äˆ¬Ù2“‘	Ê~íÿz}¢xàdÄYÏ©)tÎïVˆ…?Ñ‡ÅÓeİ´ãÒø†êJ÷u>d=‚Œç,Å	{gc¨w¦_†äÓÒyøøœ7ê‰5áMøƒ·T:Ø­œJ«å“5U;•º¤z×iÿOÿyx{í<´çR¤m×÷ï!5~vµ‚í™àLl-r¦›e“¯¨‡’{Œe]˜>zE3–3rîLZWC°‘9ÿúIYoôV…ĞÙ0ß3{Ll/2Ñ¤ Ğ²pl‰0öìÖ	:\HXÒ§ßŞ,­†$ˆêch®UÓ’»·ß¤4¦-–!EU1Îû¿ßQrU½&yÀhÆcˆFyqà	œ†¼œ¹L¶1âÄYç¡»ÌUí¨Fì˜íĞ‘ïØ7¸_¦NõCİÜ½óÇwîIÀ;~)QÆç._°›\ì¯·v¾™@J[+ã
¨œZ`²È2à	§ì°IÁXºñ¨Yõ7mÅÎ;Ã£êzÚ1V£AH*èj„I»Ò¯ë/n±Ü¬#àä—îu|¿ÙMƒG(şî>#u:ÄL{İ™-‹¼o,}5®Ûœ³š¼®ËmaÀçlb?2ŒŸn>e`
`Ùcî³Ã8—‘ŞÏ\DØfßq$nÊ­£òE“çºšï½w5×e0Yr¼.×=<m[4Á…å‡ğFëØïì	àõ>ƒl_ã´~2P%¿€¶*3!¸ÆŸ·¶¹êq¦:”ôÌÑQBØcT€¹.CÖí=B2%H¹	ÌÉÀ˜qµo¨³qWì—îlëú,·ö‰H+KÊ…Y¢1ÀFZôÇ¡°]”UGLÒğ­ğa»o›eE£«ÈÍøİ»"Ò¥‘ùô¾'F1ÓT©DÅÀz'ÛŠRÌYûA& Ï†.şlæèAgˆngÍÖ$‡ÏÕŒ¹€A8y±¦Ñß‰¨G°¹3ÃíB×‰WiÂLÏ·èÕõ}O¥}kÆ³oë|ê•“™šsù{—ú,—döB…İîÂı`Q/ÀWïZÎ…N^o°ÃN‹óıô€‰’™û£XSQj=P‚»ÏÔ?­:ÎnÔe;š¿úÊ5æ¸fŒÕÑ,!Š7Ó—}¤îŞªp/ğíg]sûcÊ„oH’€[Ì™¤Ç§sÏM@36¯¿İB³Äúî£dt­QyÙG`,§ê›ÂìpzoÌ”ff­¦>])S@bæ"ä¹›Èı(_Úÿ„xt­±õVµzd#¯äçcéÏ£ı¿Eœ¨&vAıM¬ye¢)/E;°eEI½|šGIÑ³:±Ö¦q–x®u]‘aüõßæTàßİàGBõ-UPed,ğºÒ¢æzFi%5FáİeÈ‡î4¹ÿ5¶£d¸ÿZ7#„J<‰~8W¬!­êJQåP÷º7Õn>câ;ld¥(ú!±Ì”Ö5DÅ÷öPÑ½™KF[nD{OÊÄ˜ş.âÉ…E¿3iï¦lRuP¢ó<¦œÛ'RI!ÒÅ6F+7 ÀÙè4Ô±Æ½H“Ø ßJ¯±—èAx¶X	¿Gßb„ÓNá¡ı«üËJe\w­ßE¦+2>,öjø ºL…Æ3€ îfwŸä«r œ~ @ÕtÏq£Rº„d-Ü²WƒU|³_)ÚğvÎÍÏ“PØøIEŒqcbM«e'ó¤"isx)”cyÎA>ËAQö ¯È.T1üÈ/¹÷†–h^6¹õÜ*†?!bıLz`bŸŸL3íöBš@ÅRÀ‡«<ÌŞÊÔ$(Cîö¨Î”QQÜì·Ahr0¦€N‚å.ëj>ƒ£ÛpĞtÍu˜Á«›='u	èxü°Kˆm€ãûÊ€c‡‹†šê:ƒ”nJ¡oåÉõü¢dªúmÀk•õ|ıˆ„×–¦ZD’<M×’ñk£„ßÂ¸¤‰*¨"Í1)‹›I™¢.ÆåEBéƒò&—6~#8äõ•ğ9Õ@·IRîæü¼¦dô%­f	ûÕ>W#^ùÎMmWb,?ÌmjÓŒÕøY_ı>şû3ñ§¥„!öçQUëÕuu-Óƒ¢Ì½nTäo`I
^²ˆ/Êöùu/½l“ùzö!DT÷¯–Êt€ª%—ˆçºRø°féĞ­>‡Ûº«x[	Ù¯–’ğ#fpâĞ5!&™fkXr;—É¨F‚cãÔŒÜz¹AÙÈó‡ì°¼ˆœ¶ ,Í]ÀgdGXaÃ»“œ*Ó^½
€bØh^²ß¼jáÿYíQÁîÄ­Ä·ÎF¸ùf¡£5åaÀÁWÀÆWz£X
ASçÜç”ğjlİ@ß‰QÑ±ûı—;!ıOê×ã¿û–ù±„\×H{soÅ(iùª«Ñûâğç:/
¼æ<;5·$Åñ˜šúuvw^@‚—PÅu¿ K€·Ø¾ÀÅE²é‡;ò©‡ßUAñıO[gÎ…O/ß} ¿3,¥GÈ!ÿ–¼´òd%r#7s¯X¥`4îä€q~å7½îÚ,ÂØ—ä!«b+H½¬8hÅ&?›½âñfJ–$½ÒÓû±$r[ÉgØ9ó›Ğlãš¾ ë’cøzr×«&©^}ÌÍë‰h»%æµg=ìè7Ì.-F÷ëäğ´“XÖêIú`;`›iÂ‹›­]†-šõ^…ØYêÿ‰”ÿ¡Å]²Æğt™é`‚ Ù$üNóÓ`Á2Ò‰œ¹òCàöÒ¨NåÛ&³Î_ù²b("¿ˆ³¿!û1´C@·C››eü'†5Àmûî;o¢¾40z~ Õ|û*R7¬f EhÃ"»™¿Íy÷rHœù¡Øb¢HF×ƒG”p+R¦±1ø•SDN0\Sˆõ¸`1Ìv±y#¹Ï½hT&Ö×“ØyàõºÕÓa/>.¤›eˆGpn]…æß–Ù¶•Ü?J\óêˆÆ¼âøş+”ÌÔóúø#ÔHï†(y*‡Tˆ‘)ùÇjE2˜Ê®%+”ß=°°[	‹<ş_¶îeLWÚuÊÖj–s¥[äU#ùØAèÈkÔhe­¯ŠGm˜]FÚ8Åq+Où®C+y_ïf¤ò²£B²-tÔùWÆRñ×Ùó|¬aëÀ^sÿ0or/ñh¶tmkãkÄ3 Å|“F¦ÿ|ê¤´7Y'#†Áƒè½‚Qôpß|»§;“MÔ¥¿NpÖ	pHïò¶ëVÊ‰ØÔ0ÖÿÿzM…¦h·ğÍ/æ Ÿ_j,‘jÅ­$b%LØ²¦Øà(<üËñË¦–g¸r8o¸HBñÛ	sH!Ææ›½Ü=À7ò-g@=òô<€®Ze¬•0ÜËŒ™qœµæ~³X8ê!ÚÂ%ÍØù²šM}–]±<¿?ß¹åÒÈ´üÕÏ½†Z¤2{ÖAÈÈÊĞ“WÌ×1˜„åú?†#¿Í5Ç­sÄÛ1q^£²İÆ D¢ƒ~Š¨‹(ŒR›<x'ln„¿ÿqê%‹¨ƒÚ‘à“Ôªp×wĞ'–õäôì›éaÊ©½Øb¤ëÑÒ\6Ç{Œò>ÀíŠ"ö¿6š^[2˜æ=ä˜½3w8<axd“Qô·2ícï¼*ĞÆ÷ÿ©‹¸×sİ‡$-‹ÿB=aŒÛ=½'¬¾_-L>]ü¶Cş­·‹‹ÍuÆ'']ğHÃ"ºåÚÀÒY:Òº„¥DJŸØ sÇ²¡ÏV¬2Ï\}í®^}ímªëò/®±¯6Š—WêÂá¢Iú£ârÀÆ2äpb¢ë„iO—´ñóPhk„`™T‘¯á*¹AÛÍxTzòÒgÑætW0Îåñ@·[‡náƒnÌoé/^ÅprY3—¬·u>²EıÒW9éĞtš²¨L§Û‚]Öëe•hVFİ *»ÒäYI!zÚê±â¦]Û‹sKRƒ/±ÄCà|rŸ…>:ü3›"•ÉªÙƒSê»æ‚XL]Òï¦ùş}«;N Ã”ÿëH½ßìf•| +1„x€Lı»OÆDB È¯c…%Â9ë¿oM·B(‰õ8´áµgm‡(“Öã9zé}ÜEL()äĞö­Ó¼(½°›#ĞN?Ò¾2=£í©‘á)ÍÌşˆ,€¾Àõ¾VÑ3LªLmqw£&,­ˆ&œH¯˜?6§ÁÛ]/I¶ÍÁµy~µh»Ó7¥ˆ1R_O]¦ôöu¥‡W†½*‚{•I@¶Ê,o±t¾•5çœ<˜‰4ğ›Ø–vV+°¿yì:Ò»I‹ÇV›“ïAë[¸ä¿G=¼¦rª]7p—à-İˆ}q±ãa4Ö53K‰¨ñ·=0Ó'çeÍwœÅ¸çjµÜû=au9Ã>â„ÑÂôèU EYğÄ$ÎôvWj—e¥)-æJãÙ’Ä£Ñg­Õ
iótœ½ ÜİS
@HIu[xP‘:…¶L2ŠB=Ÿ²r´¾Œ	M/IéÃQ²Üõö˜èKÙ{Æ‚µùŸ14x•>ˆÛà³‰˜ºØÚu¼JØğte$ÿ
q¼\¦3‘øCŞPÓH4nı1Š©Ô…Za@q$ÎXid")¿€®^g(³üä]Ÿ½rS¯QÛ¾°RRúÒîşJÑÜ"á%2©ÑGeRÓœ¼T™ZÎ*S8Ú{`qXè)â^ª©_z2GåC3Õ3E¦cH@ƒĞÙ¾XÇn¸i-XïnÉnÕòÉ!“–ãÙºíGv·ı‹œ›Yã?ZWÉ·£ƒ³ÕØYù†Ü¦„V`É¾"t½(Õõ™™ÓFyš^õ	Å×%§e²õ÷Öª1>¼()ı¿¿rÊÖnŒLTkÃéÎ4	|yñÇñïüekÃĞ)Ò+0“[S›ñô„°F ı¶Œû‹öÁ#ù
êh
xÏÌ‹¨L÷ŒË|Ë)»šE˜	TR,(#RA ÍÕsC 9"7S>UpR(ÑÃYÂ^·îûeB,#”‰sÔPõ±Ş*@Ö].Pç¤K±G@Ï	EVÉ`‚Ÿ½bV2«RŞRû‡ ”´…ã@"Høs³[¨coxö™5ÏÅT'JØkPøœş·Bêe–íxó?b}3:Ãhé´ë"öšå_xôp®­kj'‹§Oç»V	¥^Çk¡eÛ–¦˜˜pbá_Â1)#áõ²á,Ñ™ÄgS2äùí…†xêËWè&]y3Ó5Îˆğ÷ìQÔEŸ†ı=ìINµ&Ùš‡Åq•øİ/†ÚPû“¦ÊQqdıÂ"]ûÂ§zŞ®eVàRD`œ‹®¡j§âœƒş4ÜˆÉóEávÑtdW½Hÿ®…’Mœ’;Â«d úy™(PüÔ2şÆ¶vmv¯Åæ»Qu-¶İ¦ø‘Ëè-Nb0|i6h®òJÈˆCï[µøE~Fò}˜Ş« åÿ°àÏ EäÅ¾àêIü~¡w’wP*®ÙèâE¿P´g·¹°´ç‹Ã×líX;Œ¦å[òÔm¨¼­ègä—~ÍRŸë<íh=GOey–ë/Be¨¹øĞõ”V9Ôd8Ê{úG†¨’œ1õB#ÆGJŞ2ê–äîË°Ê78kcİÈ—Éòc!¢BNŞôV ªNÇ±«óÍ‚îLÉé³•ÕˆòÉµ x¡:±¹ÃŸ`qÔV¶@ –Î#¢IeW|(©f£æ?³­¥»Áæ¥†QWuD£ã•m"Ø¤¢‚€2Ô{*'¸øé¬•éÄ‰Y5mTe—Eàjr(È|§ò†¿zşó»JÓ.©³q)÷í¶N—†Ë–wşA-ƒqP&Mz‡òß´Ï{šßÜBÊZù ¸ÕúÎŠ"jÊ`ÔñF+áÿ¼…Y5Ûì0Í… êeÊü™~©
ô­¶›QTg¼øX^·||aûKiÔ2haªã‰7’vİ„‹ÍŞL²çDÁÛg³ ,%7,Ç6˜Ù¨j3¥ñ,|Íëfç­Ì%H”~G*,ıÄ j|¦•H¿´Gvª”ñ3hEŞa÷D¤ëô9øÉ2WnŠØû‰3úîÈÜ‘­9s×•3©Í1®ä¯ªMU5“Jóä]LÁóqËÜÅÏF Úš¢K£Ø¤ÓúğhÆ°…ã›DæûÌK9©›n"rmF6h1¯¶hÿ1ô¾s+"ÛÌ&uÕÏ åçÚ	G^cï­"xi_š¦0F.˜p.¿At•Ù6‚,ˆİpeÂóé6ÔC9õ
©¯{y‰~
xãf1ÊèÄ/L"5…Kì[@‚<-9xo´„¢K_6èµ<=×˜X˜áV©Fe ‰„ıØ~ÌŸY+„v¾=·ŞËâ'R»˜ bú¥¡+Rå÷pÄ®Â{í8QdD0_?{OM™î–éçÚ Ei•-®~"œ-ü Íj!³±«E ©ñk­/‡  Pàğ©;å2O¦„†3"•˜½H6¦ïBf9hie6NUÀ!'ç3Ê|ñê£›SÑ}¢æI4—¾(G ƒM=«ÔiZI‚¥Ë%nTRO°(~g±fYÅCÖ4(“W%‡¼*G¹
½-,ôã
ùÀ¿´ e³fßæ»M­{Ô¯2(Sõ~üçd¦ş@ŞÇ2&‰Šö,<ò9S¿QÔ|8åWÁU™;3j¹Ã×áØÜÁã~EãbÃ‚2Ä„sÿR°×û”kMgbŸ•m|!·óÔıS¼‚Ef¿¿ _ƒØÅJ	İX¤[zÓ§E,Ô
çpCkëúÎÏÑ%¨)ÂÉÁ>ôŒz^Xæ½šÖ‹	ğIşÂıÌŒ-zÿÿhÚ{«>ê9¾¯¢œ4u|ó‘¹ÿŒwf¶Û<ªknFÁˆ’hBg£õè¢ªŞÔC)§SŒz~|°ñ4ÉZqİ½éQ  b
¾ıÓÖBşiYœ2×,á³LXj‰0ÅÜİS¸3ê¯U!QÎkùÍ•>äÄÜ“”v¾(äÔWA;œ6K²zU¹}®‘ª%B—”{Ş·«Ç~îš$NäÔ!êË¼ĞÿÛNF¹ï{µeéi1g*’øª˜ÉĞß²¦Ìá<'øætß¡4@ß{³¢¹+pÈÌ‚ğMÛg8Ëål=Ñ‹êÊÈÆsádªóÓCñ@Ïu5‹6³:ÑÓĞÔ€ZvÁF/òIH€Rù›JØ%Öø/.×á[ÄæãPxÏ@´°Õ3üÔ™¾ñ¨Æƒ°utDXX!–üAÄ?aŠaú²JP¦çn¡
Ğ¶'÷`(ëÏø‰ÔBõ	HÍŒ
‹U`Ï.Øi¸IîñÎö™T"P«;Í%S3ôš³d†;Ë-ÀƒÄ¤XoÕ	±½Ş•%£Z3î*n´ªLŠplóªï£C;”fµMBûX_æ¤Û¯÷JÖAœ`eŠ¬!U‹x÷º×Ì[cóÖ…	S±óÓG7²E§õòßU?à\:Æòmeıl€,ş¦"3ª¿9›¹È½Ï€®©ñÿR(¢JPëÈ —İÚ‡w™ê¥Ä ®0ùSãó¸ê¿G€hÃilâyŠGË=1tÆ®ÙÓø.×+–¿U5Î19Å¤5;: %¼K\.€ïø—t˜F™Ît€7»¾÷¹|³¯{	9•FK¾‡Bê>0]–…İò	wê
-Ô\”R I>qß½Àú»ñÏÈÚ˜·;ezI=F\7åÙƒ$ø?ø§ywÎ1§è‘¯h÷Ìñ%}hJıÄµmzğkT[€‰M(‰ìó:î¦{¼GÒiØ§Æ!uI³Åãçdøû_èC`†”í½ÂMÂôoG•Ÿ•óãdLŒü±¶‡x»&Ö®Ï6à=¡Ñ35¢Mü$JV’–}S<~ïZEiÑ0:Ûi XÓ©4ÆP&š“1}Ò„Û;Q•p]Dg®·eæó3º¦È[‚êÎ(lWCqô’N'‚ÁhyûÄµõÇNm|¾)JÑ&¹:®SmÁxc5áÄ,ãh=b‚u5	&ëkÌÏk8raµAw¥:K9I¬Bô#7>‹l¤Åxöxs/<i4@–Å·;&Rå¤²·ğ9e°åNçèâ#¢”/SÂM(¥ÿé‰×4Ğ‰`Ãgy¢JçSıKÆB=0Å¥2ñIÀÜ3w»ŞSE6aù/~®÷Y8>ß¿ÿâşğÄ%²½2ÅŒ(FgÌ{¹ø›¦4éØ4vâÚm™34E£ãèØN!íìß¿\Ïm'm¾¾Z‡&P¼qòïh—bLÚş}E˜‰š—¾”TšùğhÏ&">Œ»WĞÅ†¹y7yÅğ(='—¥²Ãt¡ı¢I#MR·îgÕ…“,N&ÿ¶‹Òm›¾·³«h_‹)£²XñÇ€ä¬`â	øÇ½İ¡qD—VËÜö•ÒúmØİ°ÓBÎ\—£/î+öÿëˆ²a­}(­LŒõTT²‚ğld7–w­´|ûf<|‹&oÇ#Ò†²/<¨òZù®úÊuÃ+†ËŞ-û‘ä§ÉsæÇÜ×0ä'å»Y}™-”ëJ!|4O­Ø¯)q¢ÀÖåiêÏ Ælb5NI6oÔşN8ÂÃ4Oœ²uñôŠÿ>®~tñ>Ç¹pzêF‰VNU2œ0Á×bW¨o®pÑ=—¤âìà&ç”S7¾ßø‹;<Khãvâáã£„xS0ñ}ÙêcfÃÄë–È«ˆ6FH”1Z|ëş"$¥øÀO*=v¼nd
£ì²qü4§é#®}ĞwÇâR!$+Ùè«y^•İw}“>#QÊ†ù_£JK¿ß˜ZóTm»hÔcÍ»ø!Ná`|Az˜ ÀßQ¢óÖËÃöáŞ-ÛÔ‡0ŞFÂÑ*ŠÔ_çº 0nôeôñ^ŞSÒf[ˆöyepøœ	±â^¨ïŒÄ=NUáÃî’–ÕOâBğ-ÅŞz(–ÚI”ìÈÑAQ¤&^ëb^	bEÏäğnÊ)	ıD«0ühÚ`»%][ô>È¸IåÔEÑ =&¯Mîú~pb¡$¹2Å(ÁD¨)pØøåÛ¹DÃ/Àh?¥nW$Õ‡ğÎv‹ÖXùÎr3Rpø¬,¢ö/®lˆt ;¤[ñ†ØîBs7 „D“Ãş”ºü.×SWWî›‰Ë<k`!MåÿX¸T_>Ë2†L)Oî›ªıƒâ–kŒZ¼SŒ4Î¡Ÿc°®/2†è­‹éŠâ2‡ùæ¼ÆÔà¦Ù-úš‘õÃ]fÎ|wlã©UõI˜šY|Î4z6l,.r z,ígK,€¢ˆéüˆ½@®ôÊbHbaÌ™ê8ö×0m0q¥…!êK „*pÒ5ãQ´LˆM˜º“¤À=VîÄ¤sI¦´şÒŠ[­?ÚN½É°
,"R¨YX(`Mº#‚½ÊÀš<8t,œ!}^}²½‚2jjBfL×TC[øB¶Çş·õ¥P›k×ëaCµCt™Lé|Ó¾\pUü9¤»óÕJ`ûfÆ.0°©+º±àRy{?‹Ï¸:@£0zĞ_ç'äòßkÆ‹-ÅëÊ9½2Sñæ¿,×Á”^U¾Mñ¹wËµ%Dğ˜Şàğ8Œ—™†>„RaO^à¥—CÊªø$8™ËTÛòƒŸã@İ*•ß,JI¸ĞŠuáwJíuW¬ÓÌ<yhê~Üö}¶J,;iØtö…É…‡şAÈ ó°I¿ÅØÒV¡nB×ï’¿ı=Ó[µãŸ£†-fdó[ÕçéÛ"á‡8X”‚de£?ú	WoÙ$JÄ©Dõ3Ñ’Ê$UÍ¢'e=ôÀàÃû•|2x,±É8­qš•èhóvWê<÷Vª4±x4vU]nGj–zm˜PŞõÇ8ä9";Ê‡±2Újş|> jéÁsJ'eı^¸pê§D}õ&–Æ;úì1Ç/Ó±cîŞoZa¬Ó)5 ×_İˆâ1¬1¹>…mÖÑò³<+¢Û±å´ 0v•ó^WÅk’+eÎzšZ_	¥™ÓKHrù%Ã«E—«ÕÈs.ƒc¿ÎÑäÊi•Â]éÊW®y$gUçD¬µ¼mJØvS±¤u@RÎ±àŒÊáüæ<ÔµÈ—O<z!%[2[6˜ÏdGq˜›‰gÔà<Éì]ô2øo¤›äùmù›bÇ	u[¨µ 6‹ª=‡sX…1&¡_(/'¹¶Ï¢O;’äÊœŸoU<ÌÉoXZí¦é{çôpŒõ ·‹¬Ã”ºKP{æÄ+B“o{ê'
jæ²UÖØİÍz•=dÜ@ÃúÇçåS†±Ø•Ì®4Â¬PûZä(*}ş¬%%<¤^Àı†V+Åµ\ñ\çôİÎR”L@ìU”ò¥Õ6W9AÀfU6_LYSY{€#M—÷n¥~ÏïÕ?Pôü˜¦_›ÁIŸ9
ì¨µĞëdÖÉl{š&Ğæùş?Bæ™ö!Dãp\ro„X{‡â!‰£v6ù/Ü¥uÑL á¼°›6UT‰ò«ß¤nÛü6•»÷›³øŸç¢VYFg ‘môTÛn‘*5öÀôbÛ÷´Š”ñÜ÷L•¬.¦±¹c1Nà}ï.ıÛ¦pÔ‚7VÂ.l˜¨Ö[ê¸3-£‰A©>ÔçÀ"®ÿvĞ¿Í:¢„Ñf²÷ÿe]|àm¢Æ…Ç;ä¨ÓE\X¥O€YŸ×EÉ¾Ì¡GGS1'¡2—i}]Œó²¤˜Â§£d›ŒÁxéš„¯Z?È/Ü,œ‚‰GÔW€LæZ[”ÂØÉ'&ë˜„E±­LÖØ×J3ªu/åÀ+ùÇ‹…`TJïU9É	“(£2±²A%eWwB)á³é ÅLdÛZ¬`G¿Æğ"rv}l)1¬Wsİ
™±µËçÌˆ¶ªybıñn’|>€¦«ƒ²Ó“¤RY„Ä¯}²€¿£Am/|NdäªŸx¡”¸ª89AVõ?„ê!€æ"Lí¶¯.ÅˆU˜[}Lv$B?«u üĞa@f:g ïºşàË¹)J °Êæ{RõøæÅÜ]ãõFà-‘Ôîƒ6-Ï®µ’WûïÏ1%‚		yÊÍ 0P½V* O—\Éu–ÇõgZ†úîòì’£ëdİ‹ÚÊt÷ëó\8P»ŸÖñKº\õZ²íO‹;ãÄL¶^Ön7òp.H«[BE†õúB˜úÈuqÚan®¸¤)~‰œ*PçBô¤mÿC;”^Hl¢ˆŞáÑŞõ„<‘ò£|ô‰u4yÜJc­äèvËn²†y«(O¬à´&åT¨©5¤U¥E±¢ı	6˜3}ÔÿB0BfMßµÉ$ü2R'¯ATzXOÛõüÒËşéVsä*è¶½f¤ê‹ÉWåSI†oMğ\ëaRÅ¢*;nq…Ó¢ƒçÜæ$k"³Æ‘-É ‹i<(¦C~áMvwA!Î(lÔ·Y@­ÙÉ°u›l`«½€`'ÑF^^òæRZ>gü¼v+ÛMVŸC fÖ·t²º·‚¦îáƒ‰Ø§ZuS#^i¨¹I$eIëŠÒûTŸN>ŒCG–¼Œ ^ 1ÙrKŠ3úeÀş’:y¾¯•¥	n¯-@Ûâ;@¦»èÎC_ï`kœSò–±·d«ıÇ¹Ş`2ç®Ü Ÿ§:şíĞ»uª<-OaO¯@ÑYÈ"¾^Ieò3({EÑ:(êWmv¾œ±$×UÔ{Ræ
İÔòF¥­]T™X»{L‘,ò¯ûMgÛıJq-	W)\é¹W90²—¬Yè]Ö[fÓ%©œœ=foßb…y’ÎÅYÛ¼Ûåœ·ªËÓ•³"—ÜíZÜøµÔ¢³hüF™             tl_path = os.path.join(path, 'top_level.txt')
            metadata = Metadata(path=path, scheme='legacy')
        else:
            raise DistlibException('path must end with .egg-info or .egg, '
                                   'got %r' % path)

        if requires:
            metadata.add_requirements(requires)
        # look for top-level modules in top_level.txt, if present
        if tl_data is None:
            if tl_path is not None and os.path.exists(tl_path):
                with open(tl_path, 'rb') as f:
                    tl_data = f.read().decode('utf-8')
        if not tl_data:
            tl_data = []
        else:
            tl_data = tl_data.splitlines()
        self.modules = tl_data
        return metadata

    def __repr__(self):
        return '<EggInfoDistribution %r %s at %r>' % (
            self.name, self.version, self.path)

    def __str__(self):
        return "%s %s" % (self.name, self.version)

    def check_installed_files(self):
        """
        Checks that the hashes and sizes of the files in ``RECORD`` are
        matched by the files themselves. Returns a (possibly empty) list of
        mismatches. Each entry in the mismatch list will be a tuple consisting
        of the path, 'exists', 'size' or 'hash' according to what didn't match
        (existence is checked first, then size, then hash), the expected
        value and the actual value.
        """
        mismatches = []
        record_path = os.path.join(self.path, 'installed-files.txt')
        if os.path.exists(record_path):
            for path, _, _ in self.list_installed_files():
                if path == record_path:
                    continue
                if not os.path.exists(path):
                    mismatches.append((path, 'exists', True, False))
        return mismatches

    def list_installed_files(self):
        """
        Iterates over the ``installed-files.txt`` entries and returns a tuple
        ``(path, hash, size)`` for each line.

        :returns: a list of (path, hash, size)
        """

        def _md5(path):
            f = open(path, 'rb')
            try:
                content = f.read()
            finally:
                f.close()
            return hashlib.md5(content).hexdigest()

        def _size(path):
            return os.stat(path).st_size

        record_path = os.path.join(self.path, 'installed-files.txt')
        result = []
        if os.path.exists(record_path):
            with codecs.open(record_path, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    p = os.path.normpath(os.path.join(self.path, line))
                    # "./" is present as a marker between installed files
                    # and installation metadata files
                    if not os.path.exists(p):
                        logger.warning('Non-existent file: %s', p)
                        if p.endswith(('.pyc', '.pyo')):
                            continue
                        #otherwise fall through and fail
                    if not os.path.isdir(p):
                        result.append((p, _md5(p), _size(p)))
            result.append((record_path, None, None))
        return result

    def list_distinfo_files(self, absolute=False):
        """
        Iterates over the ``installed-files.txt`` entries and returns paths for
        each line if the path is pointing to a file located in the
        ``.egg-info`` directory or one of its subdirectories.

        :parameter absolute: If *absolute* is ``True``, each returned path is
                          transformed into a local absolute path. Otherwise the
                          raw value from ``installed-files.txt`` is returned.
        :type absolute: boolean
        :returns: iterator of paths
        """
        record_path = os.path.join(self.path, 'installed-files.txt')
        if os.path.exists(record_path):
            skip = True
            with codecs.open(record_path, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if line == './':
                        skip = False
                        continue
                    if not skip:
                        p = os.path.normpath(os.path.join(self.path, line))
                        if p.startswith(self.path):
                            if absolute:
                                yield p
                            else:
                                yield line

    def __eq__(self, other):
        return (isinstance(other, EggInfoDistribution) and
                self.path == other.path)

    # See http://docs.python.org/reference/datamodel#object.__hash__
    __hash__ = object.__hash__

new_dist_class = InstalledDistribution
old_dist_class = EggInfoDistribution


class DependencyGraph(object):
    """
    Represents a dependency graph between distributions.

    The dependency relationships are stored in an ``adjacency_list`` that maps
    distributions to a list of ``(other, label)`` tuples where  ``other``
    is a distribution and the edge is labeled with ``label`` (i.e. the version
    specifier, if such was provided). Also, for more efficient traversal, for
    every distribution ``x``, a list of predecessors is kept in
    ``reverse_list[x]``. An edge from distribution ``a`` to
    distribution ``b`` means that ``a`` depends on ``b``. If any missing
    dependencies are found, they are stored in ``missing``, which is a
    dictionary that maps distributions to a list of requirements that were not
    provided by any other distributions.
    """

    def __init__(self):
        self.adjacency_list = {}
        self.reverse_list = {}
        self.missing = {}

    def add_distribution(self, distribution):
        """Add the *distribution* to the graph.

        :type distribution: :class:`distutils2.database.InstalledDistribution`
                            or :class:`distutils2.database.EggInfoDistribution`
        """
        self.adjacency_list[distribution] = []
        self.reverse_list[distribution] = []
        #self.missing[distribution] = []

    def add_edge(self, x, y, label=None):
        """Add an edge from distribution *x* to distribution *y* with the given
        *label*.

        :type x: :class:`distutils2.database.InstalledDistribution` or
                 :class:`distutils2.database.EggInfoDistribution`
        :type y: :class:`distutils2.database.InstalledDistribution` or
                 :class:`distutils2.database.EggInfoDistribution`
        :type label: ``str`` or ``None``
        """
        self.adjacency_list[x].append((y, label))
        # multiple edges are allowed, so be careful
        if x not in self.reverse_list[y]:
            self.reverse_list[y].append(x)

    def add_missing(self, distribution, requirement):
        """
        Add a missing *requirement* for the given *distribution*.

        :type distribution: :class:`distutils2.database.InstalledDistribution`
                            or :class:`distutils2.database.EggInfoDistribution`
        :type requirement: ``str``
        """
        logger.debug('%s missing %r', distribution, requirement)
        self.missing.setdefault(distribution, []).append(requirement)

    def _repr_dist(self, dist):
        return '%s %s' % (dist.name, dist.version)

    def repr_node(self, dist, level=1):
        """Prints only a subgraph"""
        output = [self._repr_dist(dist)]
        for other, label in self.adjacency_list[dist]:
            dist = self._repr_dist(other)
            if label is not None:
                dist = '%s [%s]' % (dist, label)
            output.append('    ' * level + str(dist))
            suboutput = self.repr_node(other, level + 1)
            subs = suboutput.split('\n')
            output.extend(subs[1:])
        return '\n'.join(output)

    def to_dot(self, f, skip_disconnected=True):
        """Writes a DOT output for the graph to the provided file *f*.

        If *skip_disconnected* is set to ``True``, then all distributions
        that are not dependent on any other distribution are skipped.

        :type f: has to support ``file``-like operations
        :type skip_disconnected: ``bool``
        """
        disconnected = []

        f.write("digraph dependencies {\n")
        for dist, adjs in self.adjacency_list.items():
            if len(adjs) == 0 and not skip_disconnected:
                disconnected.append(dist)
            for other, label in adjs:
                if not label is None:
                    f.write('"%s" -> "%s" [label="%s"]\n' %
                            (dist.name, other.name, label))
                else:
                    f.write('"%s" -> "%s"\n' % (dist.name, other.name))
        if not skip_disconnected and len(disconnected) > 0:
            f.write('subgraph disconnected {\n')
            f.write('label = "Disconnected"\n')
            f.write('bgcolor = red\n')

            for dist in disconnected:
                f.write('"%s"' % dist.name)
                f.write('\n')
            f.write('}\n')
        f.write('}\n')

    def topological_sort(self):
        """
        Perform a topological sort of the graph.
        :return: A tuple, the first element of which is a topologically sorted
                 list of distributions, and the second element of which is a
                 list of distributions that cannot be sorted because they have
                 circular dependencies and so form a cycle.
        """
        result = []
        # Make a shallow copy of the adjacency list
        alist = {}
        for k, v in self.adjacency_list.items():
            alist[k] = v[:]
        while True:
            # See what we can remove in this run
            to_remove = []
            for k, v in list(alist.items())[:]:
                if not v:
                    to_remove.append(k)
                    del alist[k]
            if not to_remove:
                # What's left in alist (if anything) is a cycle.
                break
            # Remove from the adjacency list of others
            for k, v in alist.items():
                alist[k] = [(d, r) for d, r in v if d not in to_remove]
            logger.debug('Moving to result: %s',
                         ['%s (%s)' % (d.name, d.version) for d in to_remove])
            result.extend(to_remove)
        return result, list(alist.keys())

    def __repr__(self):
        """Representation of the graph"""
        output = []
        for dist, adjs in self.adjacency_list.items():
            output.append(self.repr_node(dist))
        return '\n'.join(output)


def make_graph(dists, scheme='default'):
    """Makes a dependency graph from the given distributions.

    :parameter dists: a list of distributions
    :type dists: list of :class:`distutils2.database.InstalledDistribution` and
                 :class:`distutils2.database.EggInfoDistribution` instances
    :rtype: a :class:`DependencyGraph` instance
    """
    scheme = get_scheme(scheme)
    graph = DependencyGraph()
    provided = {}  # maps names to lists of (version, dist) tuples

    # first, build the graph and find out what's provided
    for dist in dists:
        graph.add_distribution(dist)

        for p in dist.provides:
            name, version = parse_name_and_version(p)
            logger.debug('Add to provided: %s, %s, %s', name, version, dist)
            provided.setdefault(name, []).append((version, dist))

    # now make the edges
    for dist in dists:
        requires = (dist.run_requires | dist.meta_requires |
                    dist.build_requires | dist.dev_requires)
        for req in requires:
            try:
                matcher = scheme.matcher(req)
            except UnsupportedVersionError:
                # XXX compat-mode if cannot read the version
                logger.warning('could not read version %r - using name only',
                               req)
                name = req.split()[0]
                matcher = scheme.matcher(name)

            name = matcher.key   # case-insensitive

            matched = False
            if name in provided:
                for version, provider in provided[name]:
                    try:
                        match = matcher.match(version)
                    except UnsupportedVersionError:
                        match = False

                    if match:
                        graph.add_edge(dist, provider, req)
                        matched = True
                        break
            if not matched:
                graph.add_missing(dist, req)
    return graph


def get_dependent_dists(dists, dist):
    """Recursively generate a list of distributions from *dists* that are
    dependent on *dist*.

    :param dists: a list of distributions
    :param dist: a distribution, member of *dists* for which we are interested
    """
    if dist not in dists:
        raise DistlibException('given distribution %r is not a member '
                               'of the list' % dist.name)
    graph = make_graph(dists)

    dep = [dist]  # dependent distributions
    todo = graph.reverse_list[dist]  # list of nodes we should inspect

    while todo:
        d = todo.pop()
        dep.append(d)
        for succ in graph.reverse_list[d]:
            if succ not in dep:
                todo.append(succ)

    dep.pop(0)  # remove dist from dep, was there to prevent infinite loops
    return dep


def get_required_dists(dists, dist):
    """Recursively generate a list of distributions from *dists* that are
    required by *dist*.

    :param dists: a list of distributions
    :param dist: a distribution, member of *dists* for which we are interested
                 in finding the dependencies.
    """
    if dist not in dists:
        raise DistlibException('given distribution %r is not a member '
                               'of the list' % dist.name)
    graph = make_graph(dists)

    req = set()  # required distributions
    todo = graph.adjacency_list[dist]  # list of nodes we should inspect
    seen = set(t[0] for t in todo) # already added to todo

    while todo:
        d = todo.pop()[0]
        req.add(d)
        pred_list = graph.adjacency_list[d]
        for pred in pred_list:
            d = pred[0]
            if d not in req and d not in seen:
                seen.add(d)
                todo.append(pred)
    return req


def make_dist(name, version, **kwargs):
    """
    A convenience method for making a dist given just a name and version.
    """
    summary = kwargs.pop('summary', 'Placeholder for summary')
    md = Metadata(**kwargs)
    md.name = name
    md.version = version
    md.summary = summary or 'Placeholder for summary'
    return Distribution(md)
