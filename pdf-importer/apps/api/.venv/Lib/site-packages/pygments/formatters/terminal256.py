"""
    pygments.formatters.terminal256
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    Formatter for 256-color terminal output with ANSI sequences.

    RGB-to-XTERM color conversion routines adapted from xterm256-conv
    tool (http://frexx.de/xterm-256-notes/data/xterm256-conv2.tar.bz2)
    by Wolfgang Frisch.

    Formatter version 1.

    :copyright: Copyright 2006-2025 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.
"""

# TODO:
#  - Options to map style's bold/underline/italic/border attributes
#    to some ANSI attrbutes (something like 'italic=underline')
#  - An option to output "style RGB to xterm RGB/index" conversion table
#  - An option to indicate that we are running in "reverse background"
#    xterm. This means that default colors are white-on-black, not
#    black-on-while, so colors like "white background" need to be converted
#    to "white background, black foreground", etc...

from pygments.formatter import Formatter
from pygments.console import codes
from pygments.style import ansicolors


__all__ = ['Terminal256Formatter', 'TerminalTrueColorFormatter']


class EscapeSequence:
    def __init__(self, fg=None, bg=None, bold=False, underline=False, italic=False):
        self.fg = fg
        self.bg = bg
        self.bold = bold
        self.underline = underline
        self.italic = italic

    def escape(self, attrs):
        if len(attrs):
            return "\x1b[" + ";".join(attrs) + "m"
        return ""

    def color_string(self):
        attrs = []
        if self.fg is not None:
            if self.fg in ansicolors:
                esc = codes[self.fg.replace('ansi','')]
                if ';01m' in esc:
                    self.bold = True
                # extract fg color code.
                attrs.append(esc[2:4])
            else:
                attrs.extend(("38", "5", "%i" % self.fg))
        if self.bg is not None:
            if self.bg in ansicolors:
                esc = codes[self.bg.replace('ansi','')]
                # extract fg color code, add 10 for bg.
                attrs.append(str(int(esc[2:4])+10))
            else:
                attrs.extend(("48", "5", "%i" % self.bg))
        if self.bold:
            attrs.append("01")
        if self.underline:
            attrs.append("04")
        if self.italic:
            attrs.append("03")
        return self.escape(attrs)

    def true_color_string(self):
        attrs = []
        if self.fg:
            attrs.extend(("38", "2", str(self.fg[0]), str(self.fg[1]), str(self.fg[2])))
        if self.bg:
            attrs.extend(("48", "2", str(self.bg[0]), str(self.bg[1]), str(self.bg[2])))
        if self.bold:
            attrs.append("01")
        if self.underline:
            attrs.append("04")
        if self.italic:
            attrs.append("03")
        return self.escape(attrs)

    def reset_string(self):
        attrs = []
        if self.fg is not None:
            attrs.append("39")
        if self.bg is not None:
            attrs.append("49")
        if self.bold or self.underline or self.italic:
            attrs.append("00")
        return self.escape(attrs)


class Terminal256Formatter(Formatter):
    """
    Format tokens with ANSI color sequences, for output in a 256-color
    terminal or console.  Like in `TerminalFormatter` color sequences
    are terminated at newlines, so that paging the output works correctly.

    The formatter takes colors from a style defined by the `style` option
    and converts them to nearest ANSI 256-color escape sequences. Bold and
    underline attributes from the style are preserved (and displayed).

    .. versionadded:: 0.9

    .. versionchanged:: 2.2
       If the used style defines foreground colors in the form ``#ansi*``, then
       `Terminal256Formatter` will map these to non extended foreground color.
       See :ref:`AnsiTerminalStyle` for more information.

    .. versionchanged:: 2.4
       The ANSI color names have been updated with names that are easier to
       understand and align with colornames of other projects and terminals.
       See :ref:`this table <new-ansi-color-names>` for more information.


    Options accepted:

    `style`
        The style to use, can be a string or a Style subclass (default:
        ``'default'``).

    `linenos`
        Set to ``True`` to have line numbers on the terminal output as well
        (default: ``False`` = no line numbers).
    """
    name = 'Terminal256'
    aliases = ['terminal256', 'console256', '256']
    filenames = []

    def __init__(self, **options):
        Formatter.__init__(self, **options)

        self.xterm_colors = []
        self.best_match = {}
        self.style_string = {}

        self.usebold = 'nobold' not in options
        self.useunderline = 'nounderline' not in options
        self.useitalic = 'noitalic' not in options

        self._build_color_table()  # build an RGB-to-256 color conversion table
        self._setup_styles()  # convert selected style's colors to term. colors

        self.linenos = options.get('linenos', False)
        self._lineno = 0

    def _build_color_table(self):
        # colors 0..15: 16 basic colors

        self.xterm_colors.append((0x00, 0x00, 0x00))  # 0
        self.xterm_colors.append((0xcd, 0x00, 0x00))  # 1
        self.xterm_colors.append((0x00, 0xcd, 0x00))  # 2
        self.xterm_colors.append((0xcd, 0xcd, 0x00))  # 3
        self.xterm_colors.append((0x00, 0x00, 0xee))  # 4
        self.xterm_colors.append((0xcd, 0x00, 0xcd))  # 5
        self.xterm_colors.append((0x00, 0xcd, 0xcd))  # 6
        self.xterm_colors.append((0xe5, 0xe5, 0xe5))  # 7
        self.xterm_colors.append((0x7f, 0x7f, 0x7f))  # 8
        self.xterm_colors.append((0xff, 0x00, 0x00))  # 9
        self.xterm_colors.append((0x00, 0xff, 0x00))  # 10
        self.xterm_colors.append((0xff, 0xff, 0x00))  # 11
        self.xterm_colors.append((0x5c, 0x5c, 0xff))  # 12
        self.xterm_colors.append((0xff, 0x00, 0xff))  # 13
        self.xterm_colors.append((0x00, 0xff, 0xff))  # 14
        self.xterm_colors.append((0xff, 0xff, 0xff))  # 15

        # colors 16..232: the 6x6x6 color cube

        valuerange = (0x00, 0x5f, 0x87, 0xaf, 0xd7, 0xff)

        for i in range(217):
            r = valuerange[(i // 36) % 6]
            g = valuerange[(i // 6) % 6]
            b = valuerange[i % 6]
            self.xterm_colors.append((r, g, b))

        # colors 233..253: grayscale

        for i in range(1, 22):
            v = 8 + i * 10
            self.xterm_colors.append((v, v, v))

    def _closest_color(self, r, g, b):
        distance = 257*257*3  # "infinity" (>distance from #000000 to #ffffff)
        match = 0

        for i in range(0, 254):
            values = self.xterm_colors[i]

            rd = r - values[0]
            gd = g - values[1]
            bd = b - values[2]
            d = rd*rd + gd*gd + bd*bd

            if d < distance:
                match = i
                distance = d
        return match

    def _color_index(self, color):
        index = self.best_match.get(color, None)
        if color in ansicolors:
            # strip the `ansi/#ansi` part and look up code
            index = color
            self.best_match[color] = index
        if index is None:
            try:
                rgb = int(str(color), 16)
            except ValueError:
                rgb = 0

            r = (rgb >> 16) & 0xff
            g = (rgb >> 8) & 0xff
            b = rgb & 0xff
            index = self._closest_color(r, g, b)
            self.best_match[color] = index
        return index

    def _setup_styles(self):
        for ttype, ndef in self.style:
            escape = EscapeSequence()
            # get foreground from ansicolor if set
            if ndef['ansicolor']:
                escape.fg = self._color_index(ndef['ansicolor'])
            elif ndef['color']:
                escape.fg = self._color_index(ndef['color'])
            if ndef['bgansicolor']:
                escape.bg = self._color_index(ndef['bgansicolor'])
            elif ndef['bgcolor']:
                escape.bg = self._color_index(ndef['bgcolor'])
            if self.useboldšYb‰>xâzó€zx›d§æ6äà‘Ù¶‚É Ê{	³Öo> Û([JÄeËÃÁ Î;’Í†ñ¼Š®GI`oıñ••{,¿xÏARUÍ`ÒğÖ¨Ùh
ªZl¬Á³Óƒ¹;¦‘tqÿöÛ¹~jwÅ1ÓS"—Œvö¬h¢æ¾`ÅöÔQ´”5ô¬§æÍª )™Gmzo£Z†#¦³è7ô¼F-‹®Ãl5íS?ÄHjmd	XwúTvjSÇ‰¬—ãDmÜÀ5£28=ĞÄ½!³ÜÏÜîSÃÁüÏxZ`$¯ ¤>¦e¡’˜§»/µ@¯C*#GÂ‰ÔGŸ¡Ê£Ë<g¤Š0†ÉáÁÿWÔû]ÔoRÍÇ]&…Dù¿å¼1}"Ñí0PŸç$x
 G”ú«zôŸç‘¿÷$vDçYš!¥KÊæVWÄdæÇ|aoæ„ 7<‚ÃhÙ…šSšHzåˆp²Î3¯‹Kt¦QwË<~±2OúÏ8|õÌ¤ìaC˜ó×OHÒ­;¯nËljT«’¹?6Çó&9ƒBÏñ’?4šxå´w&’Îkõ7Î±ÿZêÕ‰l	ƒŒø¢Í$`Ô0toºÏ;›à|äòUÖ+•C Ì/|„N“ß gF¼·°!è.²|9/4;ÛìRM—>štÕiR¦éäo5úÃ3¡-ÜJÕğµOê;¶tjó>a?Â@úm·`µpCÃÓÛC=Ù”O] ãŞ Œbè?e¡ë¾GT¿1P2Ê³kÎgnØÀ)½Ûå©üİÅsàO?–õ©q?şR[˜4ô ı8e»öZ¯|ÕoY_!™üÈ0}ËºõmÍäo¤B…V§ô?CÿÔ?•t›lÒ":öô:ÂLiÕ šFõcínÅÓ¶.ô4 mEñ+
ùtEeâ4QÎ;­JÜ¢ıÅ´xà•¬¹×}áY˜±²®±zøŸÜ€d9¢F(¤Üæ5|WÓ	oa’<Ñ"Âêáú®ZË: +Ç‹Jçêu 6ÊW’ô·ëM)8ò v,F…†ÊîFj3¹ä:]Îâ•îpÔ	Ç‹fáÙN&GŒü{{e§uÎ"<d1&	ªM]%æ'fI‘Ï·ö5åó¯–Ö:À,Ws	>Å°²à|¹óçF –@SÌŒl „å§(UÁ%Ú]­+?ùşP7]îâeLJÉ/AÁL­ÿq÷¦ÓŸ‚€Y×vÚ@zìG5¨MOŸ¯£!ø¿Ô *3éuS
ÅÍÒğœ>drÁ	2ÌÅB¯ğßlŸÌîUu­^(³Œ/öÄ"€W4^i –Ã[^ü=¿¢š{ñ¶$w›Q“Â€Ş”}şËŠ«·”Ùh¼Š1Ä¼òÉïc'¼ÃB<¬­„¿lh‡šHN$ûRÀñ¹L_OÊ'ôtoàÍñ¿Ô‘½»÷+IÂ&Ñ©§JğÍµ’écáèúZOÛùqÓTX’SK›÷2íù×h^z½€:ã¥¼ÁÎ 1Íño!Qt-ÆÂû†¯
§Ê5ëŒ™µj"„´$²‘.E
å­àÊ~Ê¯Ï%Ä›Å¬G,@{³ ~$úê•Jš¢Ñ±IÙ—Ñ0-öğN£ÿ*K;u}Ó†Üv_EÈ™ ‹%gÃ"S^´¶T]Ò2v†nZGªTiØxDñìœûW²±V’Ê‚ï§É˜)9¥tšd*ôj‘Æá8~ççY–eíjˆŸ JU‰°›èÓìÎVö†š¯¿Q‰ÉZ7)bÁĞ#SzMyÔb]‰Š[çCÉb™kùr™ÛÒvêeïFSğ¶‡ßûI¾\/v³¶îøGÆQ	ÀŸ9”g'l ô**–³‰J7ı=ø2Sp'ôµºJ£ÅRÒ»V9÷ÿ+ õ"_iéÇÕ~T5†`Y¢L¿ïwĞœñjá0ÏÆA›ı#™ŠĞ{ÆM½ÚœÖ3’A…øú;©êšø{|'µ@
’£Š.¥Û3|:£"¶*¿d×Æâ’Vñ¬ÙU©½á¢†'z^„dæn•{~¥á,³ÔÙ¿}='Wù@‡ÿRÂ0gc,µ"¼&iLî’Ô.N,óéÍPÆÓ L§{ñ¾úz¨v)e\Š½¡AÔÇÚ*$eé€ï¾tù˜cà°'.†:w¨È…Í½D}íîé¾ûÌ¡÷ÖÄª´×:´ÖÛ g™DS)²Tx‹ÑæxwĞ³4¹?234ãO5»ûs´Û•LÀ­8+0¬«/¨±$?£—Í‚ªÎo¿êúÛ1›‡!4ìèÁØ"8cS‘uŸc·’á7`98—8Ù–*æ QpÍj½ŠÁF8 šÙÀÚæõ>¬›_Æ€ıs(ƒ4\(Æø8µÚÊqPQÏJÌÎXĞ~49as\}
6i«Õ¨9xn=C½ú;®¯°Q6A\;øœEŠÏÌ‚ËÏ×M9I.›âÛU=»*á0U¶P%ã¼5wô`ƒüÀêd~ÏŞÁg£µ$„O¶‰àÆŠ_˜`¹9cşißjáÀÿšhr‡ÃKi“ØşQ~ÌìVÍ°åõæby^;#¾%·ìŞdÎÓÈØÎî¹ ;OØ®°åºÃİã¯Çtgúyœğ¬Ë#ÍÏ;]KÕ‘6±|r8ˆª:±ã”ÿ‹Ø-?ı¨|'TN¬–‰óÅåÂštÃ‰)”Şr¬‰‘6<¨uI"V#ñz6Ä×Y[¾:]ˆóÛ:ØÖUè:mî‡q[2MÁÅÁã•u>HÚ^Ûø/¾µŒæˆŠX]ÓÙBÈô‡nU&‡£`nÙŞ—P¯<u­•+Zşl>’ä|Œ°MB—ÎsûÍy%|rœ¶GŸÏæZ!w7ç˜wİ}’òûÄ‘WãêDCÅuÙßÒ	&ö”I"Ù¿÷;Lcã¨Óš`‡Â
,¥_Nƒã¥zø·×Å¿0•é©RHùÿÆJÕí©ÃÉ¦Ä`f7‚›¿œÖ±3Z¹âl¦¬ç…_#r=—²õGKª_;k`ôîÈd@²ıJÙ½ŸøïÕ!ÏóEñÈ®ÓÜÇ #(¯ÓrbÕ?÷‚ÆùD}5“UÜ™'BÚ½e!…6é<–‰°g(Øİ¥ëÌ+ÒlOÒıo¬j]ÇÁˆ˜…Ü…úç&…tX!ÊËìO›‹Ej+¼íz¸ÁY0‰[!¨ı®U×¿'M@d¶a‚Ë®$ğÜ›ƒÑ-ÇUÖ¼ü-¶
¸löÜóC»Â8dç%dL§Ôšá!¨PÃ~ë	ÏÖYL©õbÊ!ËÀöMşSºØ¿…. ¯óä{7RİA’ O!¶:wµ/’šìy–Qô¿À³B3…Û+6¸“ãÑU Lâg³İ1R[¤ˆÈö~T·nÅÆ¨	b¼ñKn™±˜wˆkÿvq§dáòjÒ«lÃY1©¬~„f0çª9HÔ8”·Z\dÃ›¢åøÆçÓâ‹Åk(·¸1ƒÄ9gï~¥°7ÑÁèœk8²úÑî?àâùÕ€Ëæ†›³ÊgZğ~Nê5´ÓöÏÓ–Ü©N}Ñããş)Ùj»‰$K[ëİÍRXÃ›k'e’È.}Ó¤Ï %«‡v0V¸Sü@fÖ´¹ı—ÚseÖ+«ÿ“,Öv@†E—O"¯%SóH8¹Dhššh[n}Ì	?œJ:ï¸U6ØJeÖ¯æZ¢weúN$Ëá–X›^ìé[¤28[9
íÆWUıèz¢cóW6\”S6˜©eú²…±k—
ŞÀGÁM‰¨ÁqpYcš“QŸ½EGÁÕÎ,u^‰”MÎKfëßü>îºÚW1?şàPM.ı×ºı¨ºTúƒMà§kK/ÂiWéñ=í™Ÿ•ôÄÍ~{ıºÕì8½`3 Â7ó^ZÀíè C¯>æ=\' w7èp‹©ëÙŒw‘5-³/ée<Äÿ°á©¡`„•´yw4¼–ñ%_$Ù¥ô£mc—ñ-­>ij©.
¡W’Ùmæ>Dº<ê“ªŞ×}'´/—L¿£ÛÖ$gÄ8¥mÿn…¸0Á¸¾¶—iö»Ëkè÷¬Á»ÙOãÅ’$ùHg*7¼›*÷“\ş¸ˆpŸÚ£ŞËU9%¨aA­#ZòÂ—K?¾½)¦É›8³Zc·Ñ)Á!ØÚ¸¬í»ï¨Oğ¸ÍjU\Ü-Ú— t‘×R ÓeÂqì~şÊ,–ì¯–<†üLaU	ô¥0kÓÎZC·ÆHgNÙëC3t|'I -·O°¸cy*îë’Ò	ˆD©GRwÆŒní]G0õˆväJÍÿc#‡¤$Oë´ûL œ15é/ùñ1QÏÉG<ªÅ·y€/c¦ˆ—å›I•nuÖ†x€^?ÔêOgîãn_ªa2R§‹k•U0#ç'ieŠçx“·´Oº®‚—¬z23Šß¤.Èï¦û»®-ŸÁLçÇ>C©Ãı\ºX~’ÎtXEŸí´È^—0íÁZh¹˜´ËqÌw(åt&p]ûGæR¨ƒ…æĞñ&@ºlÿ%‰oUz’_Œúy—ÂoÙÙ«&‚uR­Ñ9!§AÑ³